[
  {
  "title": "MinMaxStack: O(1) Min and Max Queries with an Auxiliary Stack",
  "content": [
    "A regular stack supports push/pop/peek in O(1), but asking for the current minimum or maximum normally takes O(n) because you would have to scan all elements.",
    "This MinMaxStack solves that by maintaining a second stack that tracks the min and max at every depth, enabling getMin() and getMax() in O(1)."
  ],
  "images": [
    "algorithms_pics/min_max_stack.png"
  ],
  "description": [
    "## Problem Statement",
    "Design a stack data structure that supports the following operations efficiently:",
    "- `push(number)`",
    "- `pop()`",
    "- `peek()`",
    "- `getMin()`",
    "- `getMax()`",
    "",
    "The goal is for every operation to run in **O(1) time**.",
    "",
    "---",
    "## Key Idea: Store Min/Max Per Stack Level",
    "The implementation uses **two stacks**:",
    "- `stack`: stores the actual values (normal stack behavior).",
    "- `minMaxStack`: stores, for each depth, a small record `{min, max}` representing:",
    "  - the minimum value seen in `stack` up to that depth",
    "  - the maximum value seen in `stack` up to that depth",
    "",
    "The stacks grow and shrink together. This ensures the top of `minMaxStack` always corresponds to the top of `stack`.",
    "",
    "---",
    "## How `push()` Works",
    "When pushing a new value `number`:",
    "1. Create `newMinMax = {\"min\": number, \"max\": number}`.",
    "2. If the stack is not empty, compare against the previous min/max (the top of `minMaxStack`):",
    "- `newMinMax[\"min\"] = min(previousMin, number)`",
    "- `newMinMax[\"max\"] = max(previousMax, number)`",
    "3. Push `newMinMax` onto `minMaxStack` and push `number` onto `stack`.",
    "",
    "This guarantees that at each depth you have the correct min and max up to that point.",
    "",
    "---",
    "## How `pop()` Works",
    "Popping must keep both stacks synchronized:",
    "- pop the top of `minMaxStack` (discard min/max info for that depth)",
    "- pop and return the top of `stack`",
    "",
    "---",
    "## Constant-Time Min/Max Queries",
    "The magic is that `getMin()` and `getMax()` do not compute anything—they just read the top record:",
    "- `getMin()` returns `minMaxStack[-1][\"min\"]`",
    "- `getMax()` returns `minMaxStack[-1][\"max\"]`",
    "",
    "Because the top record always describes the entire stack at its current size, both operations are O(1).",
    "",
    "---",
    "## Why This Works",
    "This structure works because:",
    "- Each push stores the min/max **up to that level**.",
    "- When you pop, you remove the matching min/max snapshot.",
    "- The current min and max are always available at the top snapshot.",
    "",
    "You can think of `minMaxStack` as a history of the stack’s min/max as it evolves over time.",
    "",
    "---",
    "## Complexity Analysis",
    "Let `n` be the number of elements currently in the stack.",
    "",
    "### Time Complexity",
    "Each operation touches only the top of one or two lists:",
    "- `push`: O(1)",
    "- `pop`: O(1)",
    "- `peek`: O(1)",
    "- `getMin`: O(1)",
    "- `getMax`: O(1)",
    "",
    "### Space Complexity",
    "`minMaxStack` stores one `{min, max}` record per element in the stack:",
    "- **Space:** `O(n)`",
    "",
    "---",
    "## Practical Notes",
    "- This approach is similar to the classic **MinStack** problem, extended to also track the maximum.",
    "- Using Python dicts is convenient; tuples `(minValue, maxValue)` would work as well and may be slightly lighter-weight.",
    "",
    "---",
    "## Summary",
    "MinMaxStack achieves constant-time min and max queries by keeping an auxiliary stack of `{min, max}` snapshots:",
    "- two stacks, kept perfectly in sync",
    "- each level stores the min and max up to that point",
    "- all operations remain O(1) time, with O(n) additional space"
  ],
  "date": "2026-02-03"
},
  {
  "title": "Balanced Brackets in O(n): Validating (), [], {} with a Stack",
  "content": [
    "Checking whether brackets are balanced is a classic stack problem: every opening bracket must be closed in the correct order and with the correct type.",
    "This implementation supports three bracket types—parentheses, square brackets, and curly braces—and ignores all other characters."
  ],
  "images": [
    "algorithms_pics/balanced_brackets.png"
  ],
  "description": [
    "## Problem Statement",
    "Given a string, determine whether all brackets are **balanced**.",
    "Balanced means:",
    "- every opening bracket has a corresponding closing bracket,",
    "- brackets close in the correct **LIFO** order (last opened, first closed),",
    "- and types must match: `(` with `)`, `[` with `]`, `{` with `}`.",
    "",
    "If the string is balanced, return `True`; otherwise return `False`.",
    "",
    "---",
    "## Core Idea: Use a Stack",
    "A stack models the nesting structure of brackets perfectly:",
    "- when you see an opening bracket, push it",
    "- when you see a closing bracket, it must match the most recent opening bracket (the stack top)",
    "",
    "If it doesn’t match (or the stack is empty), the string is not balanced.",
    "",
    "---",
    "## Data Structures Used",
    "- `openingBrackets = \"([{\"`",
    "- `closingBrackets = \")]}`\"",
    "- `matchingBrackets = { \")\": \"(\", \"]\": \"[\", \"}\": \"{\" }`",
    "- `stack = []`",
    "",
    "`matchingBrackets` makes it easy to check whether a closing bracket corresponds to the correct opening bracket at the top of the stack.",
    "",
    "---",
    "## How the Algorithm Works",
    "The function scans the string once:",
    "",
    "1. **Opening bracket** (`(`, `[`, `{`):",
    "- push it onto the stack",
    "",
    "2. **Closing bracket** (`)`, `]`, `}`):",
    "- if the stack is empty → there is nothing to close → return `False`",
    "- otherwise check the top element:",
    "  - if it equals the expected opening bracket (`matchingBrackets[char]`) → pop it",
    "  - else → wrong type or wrong nesting → return `False`",
    "",
    "3. **Other characters**:",
    "- ignored (they neither open nor close brackets)",
    "",
    "After scanning all characters:",
    "- the string is balanced only if the stack is empty",
    "",
    "---",
    "## Why the Final Stack Check Matters",
    "A string like `\"((\"` never triggers a mismatch during scanning (there are no closing brackets),",
    "but it is still unbalanced because openings remain unmatched.",
    "That’s why the final condition is:",
    "- `return len(stack) == 0`",
    "",
    "---",
    "## Complexity Analysis",
    "Let `n` be the length of the string.",
    "",
    "### Time Complexity: `O(n)`",
    "Each character is processed once, and each stack operation is O(1).",
    "",
    "### Space Complexity: `O(n)` (worst case)",
    "In the worst case, the string contains only opening brackets, so the stack can grow to size `n`.",
    "",
    "---",
    "## Summary",
    "Balanced bracket checking is a perfect use-case for a stack:",
    "- push openings",
    "- pop when the correct closing bracket appears",
    "- fail fast on mismatches",
    "- ensure nothing remains open at the end",
    "",
    "This yields a clean, linear-time solution that correctly handles nested and interleaved bracket structures."
  ],
  "date": "2026-02-04"
},
  {
  "title": "Sunset Views: Linear Scan vs Monotonic Stack",
  "content": [
    "In the Sunset Views problem, you’re given building heights and a viewing direction. A building has a sunset view if every building between it and the edge of the city (in the viewing direction) is strictly shorter.",
    "This post explains two popular O(n) solutions: a simple linear scan with a running maximum, and a monotonic-stack approach that maintains only valid candidates."
  ],
  "images": [
    "algorithms_pics/sunset_views_running_max.png",
    "algorithms_pics/sunset_views_monotonic_stack.png"
  ],
  "description": [
    "## Problem Statement",
    "You are given an array `buildings`, where `buildings[i]` is the height of the building at index `i`, and a string `direction` which is either `\"EAST\"` or `\"WEST\"`.",
    "",
    "A building has a sunset view if you can look from that building toward `direction` and never encounter a building of **greater or equal** height blocking the view.",
    "Return the indices of buildings with a sunset view in increasing order.",
    "",
    "---",
    "## Solution 1: Running Maximum (Single Scan)",
    "**Idea:** walk from the side where the sun is, keep track of the tallest building seen so far. A building has a view if it is taller than everything seen before (from that direction).",
    "",
    "### How it works",
    "- Choose a start index and step based on `direction`:",
    "  - If direction is `WEST`, scan left → right (start at index 0).",
    "  - If direction is `EAST`, scan right → left (start at last index).",
    "",
    "- Maintain `runningMaxHeight`:",
    "  - If `buildingHeight > runningMaxHeight`, this building is not blocked → add its index.",
    "  - Update `runningMaxHeight = max(runningMaxHeight, buildingHeight)`.",
    "",
    "- If you scanned from right → left (direction `EAST`), the collected indices are in reverse order, so reverse them at the end.",
    "",
    "### Why it’s correct",
    "When scanning from the sunset side, all buildings between the current building and the edge have already been seen.",
    "So `runningMaxHeight` represents the tallest possible blocker.",
    "Only a strictly taller building can see over everything before it.",
    "",
    "### Complexity",
    "- **Time:** `O(n)` (one pass)",
    "- **Space:** `O(k)` for the output list (auxiliary space is `O(1)`)",
    "",
    "---",
    "## Solution 2: Monotonic Stack (Candidate Maintenance)",
    "**Idea:** keep a stack of candidate building indices that currently have an unobstructed view. When a new building is tall enough, it invalidates (pops) shorter-or-equal candidates behind it.",
    "",
    "### How it works",
    "- Choose start index and step so you traverse **away from the viewing edge**:",
    "  - If direction is `EAST`, scan left → right.",
    "  - If direction is `WEST`, scan right → left.",
    "",
    "- Maintain `candidateBuildings` as a stack of indices, with strictly decreasing heights along the scan direction.",
    "",
    "For each building at `idx`:",
    "- While the stack is not empty and the height at the top index is `<= buildingHeight`, pop it.",
    "  - Those popped buildings are now blocked by the current one.",
    "- Push `idx`.",
    "",
    "- If direction is `WEST`, reverse the resulting stack at the end to return indices in increasing order.",
    "",
    "### Why it’s correct",
    "The stack always contains buildings that are not blocked by any building encountered so far in the scan direction.",
    "Whenever a taller (or equal) building appears, it becomes a blocker for everything shorter-or-equal behind it, so those entries can be removed permanently.",
    "Each index is pushed once and popped at most once, keeping the total work linear.",
    "",
    "### Complexity",
    "- **Time:** `O(n)` (amortized; each element pushed/popped at most once)",
    "- **Space:** `O(n)` in the worst case for the stack (e.g., strictly decreasing heights)",
    "",
    "---",
    "## Which Approach Should You Prefer?",
    "- If you want the simplest solution and only need the sunset-view indices: **Running Maximum** is the cleanest and uses constant auxiliary space.",
    "- If you want a reusable pattern for “remove dominated candidates” problems (next greater element, skyline-like filters): **Monotonic Stack** is a great technique to practice.",
    "",
    "In this specific problem, both are linear-time, but the running-max scan is usually the most direct.",
    "",
    "---",
    "## Summary",
    "Both algorithms solve Sunset Views efficiently:",
    "- **Running Maximum:** scan from the sunset side; keep the tallest seen so far.",
    "- **Monotonic Stack:** maintain a stack of valid candidates and pop blocked buildings as you go.",
    "",
    "They illustrate two common patterns for array problems: prefix maxima and monotonic stacks."
  ],
  "date": "2026-02-05"
},
  {
  "title": "Best Digits: Build the Largest Number by Removing k Digits (Greedy Stack)",
  "content": [
    "Given a numeric string and an integer k, the Best Digits problem asks you to remove exactly k digits so the remaining digits form the largest possible number (while preserving relative order).",
    "This solution uses a greedy strategy implemented with a stack: whenever a larger digit arrives, it removes smaller digits to its left—if removals are still allowed."
  ],
  "images": [
    "algorithms_pics/best_digits.png"
  ],
  "description": [
    "## Problem Statement",
    "You are given:",
    "- `number`: a string of digits (e.g., \"462839\"),",
    "- `numDigits`: an integer `k` representing how many digits must be removed.",
    "",
    "Return the **largest possible number** (as a string) you can make by removing exactly `k` digits, without reordering the remaining digits.",
    "",
    "---",
    "## Key Insight: Greedy Removal of Smaller Digits",
    "To maximize the resulting number, you want **big digits as early as possible**.",
    "So when you scan left-to-right and see a digit that is larger than the digit(s) before it, it can be beneficial to delete those smaller digits—because replacing them with a larger digit in a more significant position increases the number.",
    "",
    "This is exactly what the stack represents:",
    "- the stack stores the “current best” digits of the result built so far",
    "- it is maintained in a way that avoids keeping a smaller digit in front of a larger one when deletions are still possible",
    "",
    "---",
    "## How the Algorithm Works",
    "### 1) Scan the digits left to right",
    "For each `digit` in `number`:",
    "- While you still have deletions available (`numDigits > 0`) **and**",
    "- the stack isn’t empty **and**",
    "- the current digit is greater than the stack’s top digit,",
    "",
    "pop the stack (remove that smaller digit) and decrement `numDigits`.",
    "",
    "Then push the current digit onto the stack.",
    "",
    "This enforces the rule:",
    "- if a larger digit arrives, it should move left by deleting smaller digits before it (as long as we are allowed to delete).",
    "",
    "### 2) Remove remaining digits from the end (if needed)",
    "If after scanning the whole number you still have deletions left, you remove digits from the **end** of the stack.",
    "",
    "Why the end?",
    "- If no future digit was large enough to trigger removals, the number is already in a non-increasing pattern.",
    "- In that situation, deleting from the rightmost side sacrifices the least significant digits, which is optimal.",
    "",
    "---",
    "## Why This Greedy Strategy Is Correct",
    "This approach always prioritizes improving the most significant positions first:",
    "- removing a smaller digit before a larger digit increases the number more than any change you could make later",
    "- the stack ensures you only keep a digit if it can’t be improved by shifting a larger digit left using available deletions",
    "",
    "Once you can’t pop anymore (no deletions left or the stack top is already >= the current digit), you commit the digit to the result and move on.",
    "",
    "---",
    "## Complexity Analysis",
    "Let `n` be the length of `number`.",
    "",
    "### Time Complexity: `O(n)`",
    "Each digit is pushed onto the stack once.",
    "Each digit can be popped at most once.",
    "So the total number of stack operations is linear.",
    "",
    "### Space Complexity: `O(n)`",
    "In the worst case (e.g., digits in non-increasing order), the stack may store all digits.",
    "",
    "---",
    "## Summary",
    "Best Digits is a great example of a greedy algorithm powered by a stack:",
    "- scan digits left-to-right",
    "- pop smaller digits when a larger digit arrives (while you can still delete)",
    "- if deletions remain, remove from the end",
    "",
    "The result is an optimal solution that runs in linear time and is easy to implement."
  ],
  "date": "2026-02-06"
}





]
