[
  {
  "title": "MinMaxStack: O(1) Min and Max Queries with an Auxiliary Stack",
  "content": [
    "A regular stack supports push/pop/peek in O(1), but asking for the current minimum or maximum normally takes O(n) because you would have to scan all elements.",
    "This MinMaxStack solves that by maintaining a second stack that tracks the min and max at every depth, enabling getMin() and getMax() in O(1)."
  ],
  "images": [
    "algorithms_pics/min_max_stack.png"
  ],
  "description": [
    "## Problem Statement",
    "Design a stack data structure that supports the following operations efficiently:",
    "- `push(number)`",
    "- `pop()`",
    "- `peek()`",
    "- `getMin()`",
    "- `getMax()`",
    "",
    "The goal is for every operation to run in **O(1) time**.",
    "",
    "---",
    "## Key Idea: Store Min/Max Per Stack Level",
    "The implementation uses **two stacks**:",
    "- `stack`: stores the actual values (normal stack behavior).",
    "- `minMaxStack`: stores, for each depth, a small record `{min, max}` representing:",
    "  - the minimum value seen in `stack` up to that depth",
    "  - the maximum value seen in `stack` up to that depth",
    "",
    "The stacks grow and shrink together. This ensures the top of `minMaxStack` always corresponds to the top of `stack`.",
    "",
    "---",
    "## How `push()` Works",
    "When pushing a new value `number`:",
    "1. Create `newMinMax = {\"min\": number, \"max\": number}`.",
    "2. If the stack is not empty, compare against the previous min/max (the top of `minMaxStack`):",
    "- `newMinMax[\"min\"] = min(previousMin, number)`",
    "- `newMinMax[\"max\"] = max(previousMax, number)`",
    "3. Push `newMinMax` onto `minMaxStack` and push `number` onto `stack`.",
    "",
    "This guarantees that at each depth you have the correct min and max up to that point.",
    "",
    "---",
    "## How `pop()` Works",
    "Popping must keep both stacks synchronized:",
    "- pop the top of `minMaxStack` (discard min/max info for that depth)",
    "- pop and return the top of `stack`",
    "",
    "---",
    "## Constant-Time Min/Max Queries",
    "The magic is that `getMin()` and `getMax()` do not compute anything—they just read the top record:",
    "- `getMin()` returns `minMaxStack[-1][\"min\"]`",
    "- `getMax()` returns `minMaxStack[-1][\"max\"]`",
    "",
    "Because the top record always describes the entire stack at its current size, both operations are O(1).",
    "",
    "---",
    "## Why This Works",
    "This structure works because:",
    "- Each push stores the min/max **up to that level**.",
    "- When you pop, you remove the matching min/max snapshot.",
    "- The current min and max are always available at the top snapshot.",
    "",
    "You can think of `minMaxStack` as a history of the stack’s min/max as it evolves over time.",
    "",
    "---",
    "## Complexity Analysis",
    "Let `n` be the number of elements currently in the stack.",
    "",
    "### Time Complexity",
    "Each operation touches only the top of one or two lists:",
    "- `push`: O(1)",
    "- `pop`: O(1)",
    "- `peek`: O(1)",
    "- `getMin`: O(1)",
    "- `getMax`: O(1)",
    "",
    "### Space Complexity",
    "`minMaxStack` stores one `{min, max}` record per element in the stack:",
    "- **Space:** `O(n)`",
    "",
    "---",
    "## Practical Notes",
    "- This approach is similar to the classic **MinStack** problem, extended to also track the maximum.",
    "- Using Python dicts is convenient; tuples `(minValue, maxValue)` would work as well and may be slightly lighter-weight.",
    "",
    "---",
    "## Summary",
    "MinMaxStack achieves constant-time min and max queries by keeping an auxiliary stack of `{min, max}` snapshots:",
    "- two stacks, kept perfectly in sync",
    "- each level stores the min and max up to that point",
    "- all operations remain O(1) time, with O(n) additional space"
  ],
  "date": "2026-02-03"
},
  {
  "title": "Balanced Brackets in O(n): Validating (), [], {} with a Stack",
  "content": [
    "Checking whether brackets are balanced is a classic stack problem: every opening bracket must be closed in the correct order and with the correct type.",
    "This implementation supports three bracket types—parentheses, square brackets, and curly braces—and ignores all other characters."
  ],
  "images": [
    "algorithms_pics/balanced_brackets.png"
  ],
  "description": [
    "## Problem Statement",
    "Given a string, determine whether all brackets are **balanced**.",
    "Balanced means:",
    "- every opening bracket has a corresponding closing bracket,",
    "- brackets close in the correct **LIFO** order (last opened, first closed),",
    "- and types must match: `(` with `)`, `[` with `]`, `{` with `}`.",
    "",
    "If the string is balanced, return `True`; otherwise return `False`.",
    "",
    "---",
    "## Core Idea: Use a Stack",
    "A stack models the nesting structure of brackets perfectly:",
    "- when you see an opening bracket, push it",
    "- when you see a closing bracket, it must match the most recent opening bracket (the stack top)",
    "",
    "If it doesn’t match (or the stack is empty), the string is not balanced.",
    "",
    "---",
    "## Data Structures Used",
    "- `openingBrackets = \"([{\"`",
    "- `closingBrackets = \")]}`\"",
    "- `matchingBrackets = { \")\": \"(\", \"]\": \"[\", \"}\": \"{\" }`",
    "- `stack = []`",
    "",
    "`matchingBrackets` makes it easy to check whether a closing bracket corresponds to the correct opening bracket at the top of the stack.",
    "",
    "---",
    "## How the Algorithm Works",
    "The function scans the string once:",
    "",
    "1. **Opening bracket** (`(`, `[`, `{`):",
    "- push it onto the stack",
    "",
    "2. **Closing bracket** (`)`, `]`, `}`):",
    "- if the stack is empty → there is nothing to close → return `False`",
    "- otherwise check the top element:",
    "  - if it equals the expected opening bracket (`matchingBrackets[char]`) → pop it",
    "  - else → wrong type or wrong nesting → return `False`",
    "",
    "3. **Other characters**:",
    "- ignored (they neither open nor close brackets)",
    "",
    "After scanning all characters:",
    "- the string is balanced only if the stack is empty",
    "",
    "---",
    "## Why the Final Stack Check Matters",
    "A string like `\"((\"` never triggers a mismatch during scanning (there are no closing brackets),",
    "but it is still unbalanced because openings remain unmatched.",
    "That’s why the final condition is:",
    "- `return len(stack) == 0`",
    "",
    "---",
    "## Complexity Analysis",
    "Let `n` be the length of the string.",
    "",
    "### Time Complexity: `O(n)`",
    "Each character is processed once, and each stack operation is O(1).",
    "",
    "### Space Complexity: `O(n)` (worst case)",
    "In the worst case, the string contains only opening brackets, so the stack can grow to size `n`.",
    "",
    "---",
    "## Summary",
    "Balanced bracket checking is a perfect use-case for a stack:",
    "- push openings",
    "- pop when the correct closing bracket appears",
    "- fail fast on mismatches",
    "- ensure nothing remains open at the end",
    "",
    "This yields a clean, linear-time solution that correctly handles nested and interleaved bracket structures."
  ],
  "date": "2026-02-04"
},
  {
  "title": "Sunset Views: Linear Scan vs Monotonic Stack",
  "content": [
    "In the Sunset Views problem, you’re given building heights and a viewing direction. A building has a sunset view if every building between it and the edge of the city (in the viewing direction) is strictly shorter.",
    "This post explains two popular O(n) solutions: a simple linear scan with a running maximum, and a monotonic-stack approach that maintains only valid candidates."
  ],
  "images": [
    "algorithms_pics/sunset_views_running_max.png",
    "algorithms_pics/sunset_views_monotonic_stack.png"
  ],
  "description": [
    "## Problem Statement",
    "You are given an array `buildings`, where `buildings[i]` is the height of the building at index `i`, and a string `direction` which is either `\"EAST\"` or `\"WEST\"`.",
    "",
    "A building has a sunset view if you can look from that building toward `direction` and never encounter a building of **greater or equal** height blocking the view.",
    "Return the indices of buildings with a sunset view in increasing order.",
    "",
    "---",
    "## Solution 1: Running Maximum (Single Scan)",
    "**Idea:** walk from the side where the sun is, keep track of the tallest building seen so far. A building has a view if it is taller than everything seen before (from that direction).",
    "",
    "### How it works",
    "- Choose a start index and step based on `direction`:",
    "  - If direction is `WEST`, scan left → right (start at index 0).",
    "  - If direction is `EAST`, scan right → left (start at last index).",
    "",
    "- Maintain `runningMaxHeight`:",
    "  - If `buildingHeight > runningMaxHeight`, this building is not blocked → add its index.",
    "  - Update `runningMaxHeight = max(runningMaxHeight, buildingHeight)`.",
    "",
    "- If you scanned from right → left (direction `EAST`), the collected indices are in reverse order, so reverse them at the end.",
    "",
    "### Why it’s correct",
    "When scanning from the sunset side, all buildings between the current building and the edge have already been seen.",
    "So `runningMaxHeight` represents the tallest possible blocker.",
    "Only a strictly taller building can see over everything before it.",
    "",
    "### Complexity",
    "- **Time:** `O(n)` (one pass)",
    "- **Space:** `O(n)` for the output list (auxiliary space is `O(1)`)",
    "",
    "---",
    "## Solution 2: Monotonic Stack (Candidate Maintenance)",
    "**Idea:** keep a stack of candidate building indices that currently have an unobstructed view. When a new building is tall enough, it invalidates (pops) shorter-or-equal candidates behind it.",
    "",
    "### How it works",
    "- Choose start index and step so you traverse **away from the viewing edge**:",
    "  - If direction is `EAST`, scan left → right.",
    "  - If direction is `WEST`, scan right → left.",
    "",
    "- Maintain `candidateBuildings` as a stack of indices, with strictly decreasing heights along the scan direction.",
    "",
    "For each building at `idx`:",
    "- While the stack is not empty and the height at the top index is `<= buildingHeight`, pop it.",
    "  - Those popped buildings are now blocked by the current one.",
    "- Push `idx`.",
    "",
    "- If direction is `WEST`, reverse the resulting stack at the end to return indices in increasing order.",
    "",
    "### Why it’s correct",
    "The stack always contains buildings that are not blocked by any building encountered so far in the scan direction.",
    "Whenever a taller (or equal) building appears, it becomes a blocker for everything shorter-or-equal behind it, so those entries can be removed permanently.",
    "Each index is pushed once and popped at most once, keeping the total work linear.",
    "",
    "### Complexity",
    "- **Time:** `O(n)` (amortized; each element pushed/popped at most once)",
    "- **Space:** `O(n)` in the worst case for the stack (e.g., strictly decreasing heights)",
    "",
    "---",
    "## Which Approach Should You Prefer?",
    "- If you want the simplest solution and only need the sunset-view indices: **Running Maximum** is the cleanest and uses constant auxiliary space.",
    "- If you want a reusable pattern for “remove dominated candidates” problems (next greater element, skyline-like filters): **Monotonic Stack** is a great technique to practice.",
    "",
    "In this specific problem, both are linear-time, but the running-max scan is usually the most direct.",
    "",
    "---",
    "## Summary",
    "Both algorithms solve Sunset Views efficiently:",
    "- **Running Maximum:** scan from the sunset side; keep the tallest seen so far.",
    "- **Monotonic Stack:** maintain a stack of valid candidates and pop blocked buildings as you go.",
    "",
    "They illustrate two common patterns for array problems: prefix maxima and monotonic stacks."
  ],
  "date": "2026-02-05"
},
  {
  "title": "Best Digits: Build the Largest Number by Removing k Digits (Greedy Stack)",
  "content": [
    "Given a numeric string and an integer k, the Best Digits problem asks you to remove exactly k digits so the remaining digits form the largest possible number (while preserving relative order).",
    "This solution uses a greedy strategy implemented with a stack: whenever a larger digit arrives, it removes smaller digits to its left—if removals are still allowed."
  ],
  "images": [
    "algorithms_pics/best_digits.png"
  ],
  "description": [
    "## Problem Statement",
    "You are given:",
    "- `number`: a string of digits (e.g., \"462839\"),",
    "- `numDigits`: an integer `k` representing how many digits must be removed.",
    "",
    "Return the **largest possible number** (as a string) you can make by removing exactly `k` digits, without reordering the remaining digits.",
    "",
    "---",
    "## Key Insight: Greedy Removal of Smaller Digits",
    "To maximize the resulting number, you want **big digits as early as possible**.",
    "So when you scan left-to-right and see a digit that is larger than the digit(s) before it, it can be beneficial to delete those smaller digits—because replacing them with a larger digit in a more significant position increases the number.",
    "",
    "This is exactly what the stack represents:",
    "- the stack stores the “current best” digits of the result built so far",
    "- it is maintained in a way that avoids keeping a smaller digit in front of a larger one when deletions are still possible",
    "",
    "---",
    "## How the Algorithm Works",
    "### 1) Scan the digits left to right",
    "For each `digit` in `number`:",
    "- While you still have deletions available (`numDigits > 0`) **and**",
    "- the stack isn’t empty **and**",
    "- the current digit is greater than the stack’s top digit,",
    "",
    "pop the stack (remove that smaller digit) and decrement `numDigits`.",
    "",
    "Then push the current digit onto the stack.",
    "",
    "This enforces the rule:",
    "- if a larger digit arrives, it should move left by deleting smaller digits before it (as long as we are allowed to delete).",
    "",
    "### 2) Remove remaining digits from the end (if needed)",
    "If after scanning the whole number you still have deletions left, you remove digits from the **end** of the stack.",
    "",
    "Why the end?",
    "- If no future digit was large enough to trigger removals, the number is already in a non-increasing pattern.",
    "- In that situation, deleting from the rightmost side sacrifices the least significant digits, which is optimal.",
    "",
    "---",
    "## Why This Greedy Strategy Is Correct",
    "This approach always prioritizes improving the most significant positions first:",
    "- removing a smaller digit before a larger digit increases the number more than any change you could make later",
    "- the stack ensures you only keep a digit if it can’t be improved by shifting a larger digit left using available deletions",
    "",
    "Once you can’t pop anymore (no deletions left or the stack top is already >= the current digit), you commit the digit to the result and move on.",
    "",
    "---",
    "## Complexity Analysis",
    "Let `n` be the length of `number`.",
    "",
    "### Time Complexity: `O(n)`",
    "Each digit is pushed onto the stack once.",
    "Each digit can be popped at most once.",
    "So the total number of stack operations is linear.",
    "",
    "### Space Complexity: `O(n)`",
    "In the worst case (e.g., digits in non-increasing order), the stack may store all digits.",
    "",
    "---",
    "## Summary",
    "Best Digits is a great example of a greedy algorithm powered by a stack:",
    "- scan digits left-to-right",
    "- pop smaller digits when a larger digit arrives (while you can still delete)",
    "- if deletions remain, remove from the end",
    "",
    "The result is an optimal solution that runs in linear time and is easy to implement."
  ],
  "date": "2026-02-06"
},
  {
  "title": "Sorting a Stack Using Recursion: In-Place Ordering with the Call Stack",
  "content": [
    "Stacks are great at LIFO operations, but sorting them is tricky because you can only access the top element.",
    "This solution sorts a stack using recursion only—no extra data structures like an auxiliary stack—by leveraging the call stack to temporarily hold elements."
  ],
  "images": [
    "algorithms_pics/sort_stack_recursive.png"
  ],
  "description": [
    "## Problem Statement",
    "Given a stack of numbers, sort it so that the smallest elements end up at the bottom and the largest elements end up at the top (i.e., the top of the stack is the maximum).",
    "",
    "Constraints typically include:",
    "- You may only use standard stack operations (`pop`, `append/push`, peek).",
    "- Do not use additional data structures to store the elements (beyond recursion).",
    "",
    "---",
    "## High-Level Strategy",
    "The algorithm splits the task into two recursive steps:",
    "",
    "1. **Sort the stack minus its top element** (`sortStack`).",
    "2. **Insert the removed element back into the correct position** in the now-sorted stack (`insertInSortedOrder`).",
    "",
    "This is analogous to insertion sort:",
    "- repeatedly take one element out",
    "- insert it into the correct spot of an already-sorted structure",
    "",
    "---",
    "## `sortStack(stack)` Explained",
    "`sortStack` performs the following:",
    "- Base case: if the stack is empty, it is already sorted.",
    "- Otherwise:",
    "  1. Pop the top element (`top`).",
    "  2. Recursively sort the remaining stack.",
    "  3. Insert `top` back into the correct position using `insertInSortedOrder`.",
    "",
    "Over time, recursion empties the stack completely, then rebuilds it in sorted order while unwinding.",
    "",
    "---",
    "## `insertInSortedOrder(stack, value)` Explained",
    "This helper assumes the stack is already sorted (largest at top). It inserts `value` into the right place.",
    "",
    "### Base case",
    "If either:",
    "- the stack is empty, or",
    "- the top element is `<= value`,",
    "",
    "then `value` belongs on top and can be pushed immediately.",
    "",
    "### Recursive case",
    "If the top element is greater than `value`, then `value` must go deeper:",
    "1. Pop the top element and store it temporarily.",
    "2. Recursively insert `value` into the smaller stack.",
    "3. Push the stored top element back.",
    "",
    "This effectively \"opens a gap\" in the stack for `value`, while preserving the sorted order of all other elements.",
    "",
    "---",
    "## Why This Works",
    "The correctness relies on a simple invariant:",
    "- Before inserting a value, the stack is already sorted.",
    "",
    "`sortStack` ensures that invariant by sorting the smaller stack first.",
    "Then `insertInSortedOrder` places the removed element into its correct position without breaking the order.",
    "",
    "As recursion unwinds, every popped element is reinserted into an increasingly larger sorted stack, resulting in a fully sorted stack at the end.",
    "",
    "---",
    "## Complexity Analysis",
    "Let `n` be the number of elements in the stack.",
    "",
    "### Time Complexity: `O(n^2)`",
    "- `sortStack` is called `n` times (once per element).",
    "- Each `insertInSortedOrder` can, in the worst case, traverse nearly the whole stack (pop many elements) → `O(n)`.",
    "- Total: `O(n * n) = O(n^2)`.",
    "",
    "### Space Complexity: `O(n)`",
    "No extra data structure is created, but recursion uses the call stack:",
    "- `sortStack` recursion depth is `n`.",
    "- `insertInSortedOrder` can also recurse up to `n` in the worst case (during an insertion).",
    "",
    "The overall auxiliary space is `O(n)` due to recursion frames.",
    "",
    "---",
    "## Practical Notes",
    "- This approach is elegant for interviews because it uses only recursion and stack operations.",
    "- For large stacks, recursion depth can become a limitation in Python (recursion limit). In those cases, an iterative solution using an auxiliary stack is often more practical.",
    "",
    "---",
    "## Summary",
    "This recursive stack-sorting method works by:",
    "- repeatedly popping the stack until empty,",
    "- sorting the smaller stack,",
    "- inserting each popped value back in sorted order using a recursive helper.",
    "",
    "It’s a clean demonstration of how recursion can replace an explicit auxiliary stack, at the cost of `O(n^2)` time and `O(n)` call-stack space."
  ],
  "date": "2026-02-07"
},
  {
  "title": "Next Greater Element in a Circular Array (Two Monotonic-Stack Strategies)",
  "content": [
    "We want, for every element, the first greater value we encounter when scanning to the right—wrapping around at the end.",
    "This post explains two O(n) solutions using a monotonic stack: a forward double-pass (stack of indices) and a backward double-pass (stack of values)."
  ],
  "images": [
    "algorithms_pics/next_greater_element_circular.png"
  ],
  "description": [
    "![Next Greater Element in a Circular Array](algorithms_pics/next_greater_element_circular.png)",
    "",
    "## Problem in one sentence",
    "Given an array, return a new array where `result[i]` is the **next greater element to the right** of `array[i]`. If none exists, return `-1` for that position. The array is **circular**, so after the last index you continue at index `0`.",
    "",
    "## The key trick: simulate circularity with a double pass",
    "A circular scan can be simulated by iterating **twice** over the array (length `n` → `2n` steps) and mapping every step back into `[0..n-1]` using:",
    "",
    "- `circularIdx = idx % n`",
    "",
    "That way, each position “sees” the elements to its right **including** the wrap-around part.",
    "",
    "## Why a monotonic stack works here",
    "In both solutions, we maintain a stack that is **monotonic decreasing** (in terms of values).",
    "",
    "- While the current value is **greater** than what’s represented at the stack top, we can resolve that top element’s answer: the current value is its next greater element.",
    "- Each element is pushed and popped at most a constant number of times, which keeps the overall runtime linear.",
    "",
    "## Algorithm 1: forward double pass (stack holds indices)",
    "### What the stack represents",
    "- The stack stores **indices** whose next greater element hasn’t been found yet.",
    "- The indices on the stack are arranged so that their values are **strictly decreasing** from bottom to top.",
    "",
    "### How it progresses",
    "1. Iterate `idx` from `0` to `2n - 1` and compute `circularIdx` via modulo.",
    "2. While the stack isn’t empty and `array[stackTop] < array[circularIdx]`:",
    "   - Pop `top` and set `result[top] = array[circularIdx]` (we found the next greater value for that index).",
    "3. Push `circularIdx` onto the stack.",
    "",
    "### Notes",
    "- Initializing `result` with `-1` means “no greater element found”.",
    "- This version pushes indices even in the second pass; it still works, but it may push duplicates. The time remains O(n) because each push/pop is bounded by the `2n` loop.",
    "",
    "## Algorithm 2: backward double pass (stack holds values)",
    "### What the stack represents",
    "- The stack stores **candidate values** that could be the next greater element for earlier positions.",
    "- After cleanup, the top of the stack is the **closest** value to the right that is strictly greater than the current element (in the circular sense).",
    "",
    "### How it progresses",
    "1. Iterate `idx` from `2n - 1` down to `0` and compute `circularIdx` via modulo.",
    "2. Pop from the stack while the top value is `<= array[circularIdx]`:",
    "   - Those values can’t be the *next greater* for the current element (they’re not greater).",
    "3. If the stack is not empty now, its top is the next greater value → write it into `result[circularIdx]`.",
    "4. Push `array[circularIdx]` onto the stack.",
    "",
    "### Why `<=` matters here",
    "Using `<=` ensures duplicates don’t count as “greater”. If the next value is equal, we pop it and continue searching for a *strictly* greater one.",
    "",
    "## Complexity",
    "Let `n` be the length of the array:",
    "",
    "- **Time:** `O(n)` (the loop runs `2n` steps, and each element is pushed/popped a bounded number of times).",
    "- **Space:** `O(n)` for the stack and output array.",
    "",
    "## When to prefer which version",
    "- **Forward (indices):** feels very direct—when you see a bigger number, you immediately resolve smaller ones waiting on the stack.",
    "- **Backward (values):** often reads nicely as “maintain the next-greater candidates to the right”; also avoids storing indices by storing values directly."
  ],
  "date": "2026-02-08"
}







]
