[
  {
  "title": "MinMaxStack: O(1) Min and Max Queries with an Auxiliary Stack",
  "content": [
    "A regular stack supports push/pop/peek in O(1), but asking for the current minimum or maximum normally takes O(n) because you would have to scan all elements.",
    "This MinMaxStack solves that by maintaining a second stack that tracks the min and max at every depth, enabling getMin() and getMax() in O(1)."
  ],
  "images": [
    "algorithms_pics/min_max_stack.png"
  ],
  "description": [
    "## Problem Statement",
    "Design a stack data structure that supports the following operations efficiently:",
    "- `push(number)`",
    "- `pop()`",
    "- `peek()`",
    "- `getMin()`",
    "- `getMax()`",
    "",
    "The goal is for every operation to run in **O(1) time**.",
    "",
    "---",
    "## Key Idea: Store Min/Max Per Stack Level",
    "The implementation uses **two stacks**:",
    "- `stack`: stores the actual values (normal stack behavior).",
    "- `minMaxStack`: stores, for each depth, a small record `{min, max}` representing:",
    "  - the minimum value seen in `stack` up to that depth",
    "  - the maximum value seen in `stack` up to that depth",
    "",
    "The stacks grow and shrink together. This ensures the top of `minMaxStack` always corresponds to the top of `stack`.",
    "",
    "---",
    "## How `push()` Works",
    "When pushing a new value `number`:",
    "1. Create `newMinMax = {\"min\": number, \"max\": number}`.",
    "2. If the stack is not empty, compare against the previous min/max (the top of `minMaxStack`):",
    "- `newMinMax[\"min\"] = min(previousMin, number)`",
    "- `newMinMax[\"max\"] = max(previousMax, number)`",
    "3. Push `newMinMax` onto `minMaxStack` and push `number` onto `stack`.",
    "",
    "This guarantees that at each depth you have the correct min and max up to that point.",
    "",
    "---",
    "## How `pop()` Works",
    "Popping must keep both stacks synchronized:",
    "- pop the top of `minMaxStack` (discard min/max info for that depth)",
    "- pop and return the top of `stack`",
    "",
    "---",
    "## Constant-Time Min/Max Queries",
    "The magic is that `getMin()` and `getMax()` do not compute anything—they just read the top record:",
    "- `getMin()` returns `minMaxStack[-1][\"min\"]`",
    "- `getMax()` returns `minMaxStack[-1][\"max\"]`",
    "",
    "Because the top record always describes the entire stack at its current size, both operations are O(1).",
    "",
    "---",
    "## Why This Works",
    "This structure works because:",
    "- Each push stores the min/max **up to that level**.",
    "- When you pop, you remove the matching min/max snapshot.",
    "- The current min and max are always available at the top snapshot.",
    "",
    "You can think of `minMaxStack` as a history of the stack’s min/max as it evolves over time.",
    "",
    "---",
    "## Complexity Analysis",
    "Let `n` be the number of elements currently in the stack.",
    "",
    "### Time Complexity",
    "Each operation touches only the top of one or two lists:",
    "- `push`: O(1)",
    "- `pop`: O(1)",
    "- `peek`: O(1)",
    "- `getMin`: O(1)",
    "- `getMax`: O(1)",
    "",
    "### Space Complexity",
    "`minMaxStack` stores one `{min, max}` record per element in the stack:",
    "- **Space:** `O(n)`",
    "",
    "---",
    "## Practical Notes",
    "- This approach is similar to the classic **MinStack** problem, extended to also track the maximum.",
    "- Using Python dicts is convenient; tuples `(minValue, maxValue)` would work as well and may be slightly lighter-weight.",
    "",
    "---",
    "## Summary",
    "MinMaxStack achieves constant-time min and max queries by keeping an auxiliary stack of `{min, max}` snapshots:",
    "- two stacks, kept perfectly in sync",
    "- each level stores the min and max up to that point",
    "- all operations remain O(1) time, with O(n) additional space"
  ],
  "date": "2026-02-03"
}


]
