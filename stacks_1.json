[
  {
  "title": "MinMaxStack: O(1) Min and Max Queries with an Auxiliary Stack",
  "content": [
    "A regular stack supports push/pop/peek in O(1), but asking for the current minimum or maximum normally takes O(n) because you would have to scan all elements.",
    "This MinMaxStack solves that by maintaining a second stack that tracks the min and max at every depth, enabling getMin() and getMax() in O(1)."
  ],
  "images": [
    "algorithms_pics/min_max_stack.png"
  ],
  "description": [
    "## Problem Statement",
    "Design a stack data structure that supports the following operations efficiently:",
    "- `push(number)`",
    "- `pop()`",
    "- `peek()`",
    "- `getMin()`",
    "- `getMax()`",
    "",
    "The goal is for every operation to run in **O(1) time**.",
    "",
    "---",
    "## Key Idea: Store Min/Max Per Stack Level",
    "The implementation uses **two stacks**:",
    "- `stack`: stores the actual values (normal stack behavior).",
    "- `minMaxStack`: stores, for each depth, a small record `{min, max}` representing:",
    "  - the minimum value seen in `stack` up to that depth",
    "  - the maximum value seen in `stack` up to that depth",
    "",
    "The stacks grow and shrink together. This ensures the top of `minMaxStack` always corresponds to the top of `stack`.",
    "",
    "---",
    "## How `push()` Works",
    "When pushing a new value `number`:",
    "1. Create `newMinMax = {\"min\": number, \"max\": number}`.",
    "2. If the stack is not empty, compare against the previous min/max (the top of `minMaxStack`):",
    "- `newMinMax[\"min\"] = min(previousMin, number)`",
    "- `newMinMax[\"max\"] = max(previousMax, number)`",
    "3. Push `newMinMax` onto `minMaxStack` and push `number` onto `stack`.",
    "",
    "This guarantees that at each depth you have the correct min and max up to that point.",
    "",
    "---",
    "## How `pop()` Works",
    "Popping must keep both stacks synchronized:",
    "- pop the top of `minMaxStack` (discard min/max info for that depth)",
    "- pop and return the top of `stack`",
    "",
    "---",
    "## Constant-Time Min/Max Queries",
    "The magic is that `getMin()` and `getMax()` do not compute anything—they just read the top record:",
    "- `getMin()` returns `minMaxStack[-1][\"min\"]`",
    "- `getMax()` returns `minMaxStack[-1][\"max\"]`",
    "",
    "Because the top record always describes the entire stack at its current size, both operations are O(1).",
    "",
    "---",
    "## Why This Works",
    "This structure works because:",
    "- Each push stores the min/max **up to that level**.",
    "- When you pop, you remove the matching min/max snapshot.",
    "- The current min and max are always available at the top snapshot.",
    "",
    "You can think of `minMaxStack` as a history of the stack’s min/max as it evolves over time.",
    "",
    "---",
    "## Complexity Analysis",
    "Let `n` be the number of elements currently in the stack.",
    "",
    "### Time Complexity",
    "Each operation touches only the top of one or two lists:",
    "- `push`: O(1)",
    "- `pop`: O(1)",
    "- `peek`: O(1)",
    "- `getMin`: O(1)",
    "- `getMax`: O(1)",
    "",
    "### Space Complexity",
    "`minMaxStack` stores one `{min, max}` record per element in the stack:",
    "- **Space:** `O(n)`",
    "",
    "---",
    "## Practical Notes",
    "- This approach is similar to the classic **MinStack** problem, extended to also track the maximum.",
    "- Using Python dicts is convenient; tuples `(minValue, maxValue)` would work as well and may be slightly lighter-weight.",
    "",
    "---",
    "## Summary",
    "MinMaxStack achieves constant-time min and max queries by keeping an auxiliary stack of `{min, max}` snapshots:",
    "- two stacks, kept perfectly in sync",
    "- each level stores the min and max up to that point",
    "- all operations remain O(1) time, with O(n) additional space"
  ],
  "date": "2026-02-03"
},
  {
  "title": "Balanced Brackets in O(n): Validating (), [], {} with a Stack",
  "content": [
    "Checking whether brackets are balanced is a classic stack problem: every opening bracket must be closed in the correct order and with the correct type.",
    "This implementation supports three bracket types—parentheses, square brackets, and curly braces—and ignores all other characters."
  ],
  "images": [
    "algorithms_pics/balanced_brackets.png"
  ],
  "description": [
    "## Problem Statement",
    "Given a string, determine whether all brackets are **balanced**.",
    "Balanced means:",
    "- every opening bracket has a corresponding closing bracket,",
    "- brackets close in the correct **LIFO** order (last opened, first closed),",
    "- and types must match: `(` with `)`, `[` with `]`, `{` with `}`.",
    "",
    "If the string is balanced, return `True`; otherwise return `False`.",
    "",
    "---",
    "## Core Idea: Use a Stack",
    "A stack models the nesting structure of brackets perfectly:",
    "- when you see an opening bracket, push it",
    "- when you see a closing bracket, it must match the most recent opening bracket (the stack top)",
    "",
    "If it doesn’t match (or the stack is empty), the string is not balanced.",
    "",
    "---",
    "## Data Structures Used",
    "- `openingBrackets = \"([{\"`",
    "- `closingBrackets = \")]}`\"",
    "- `matchingBrackets = { \")\": \"(\", \"]\": \"[\", \"}\": \"{\" }`",
    "- `stack = []`",
    "",
    "`matchingBrackets` makes it easy to check whether a closing bracket corresponds to the correct opening bracket at the top of the stack.",
    "",
    "---",
    "## How the Algorithm Works",
    "The function scans the string once:",
    "",
    "1. **Opening bracket** (`(`, `[`, `{`):",
    "- push it onto the stack",
    "",
    "2. **Closing bracket** (`)`, `]`, `}`):",
    "- if the stack is empty → there is nothing to close → return `False`",
    "- otherwise check the top element:",
    "  - if it equals the expected opening bracket (`matchingBrackets[char]`) → pop it",
    "  - else → wrong type or wrong nesting → return `False`",
    "",
    "3. **Other characters**:",
    "- ignored (they neither open nor close brackets)",
    "",
    "After scanning all characters:",
    "- the string is balanced only if the stack is empty",
    "",
    "---",
    "## Why the Final Stack Check Matters",
    "A string like `\"((\"` never triggers a mismatch during scanning (there are no closing brackets),",
    "but it is still unbalanced because openings remain unmatched.",
    "That’s why the final condition is:",
    "- `return len(stack) == 0`",
    "",
    "---",
    "## Complexity Analysis",
    "Let `n` be the length of the string.",
    "",
    "### Time Complexity: `O(n)`",
    "Each character is processed once, and each stack operation is O(1).",
    "",
    "### Space Complexity: `O(n)` (worst case)",
    "In the worst case, the string contains only opening brackets, so the stack can grow to size `n`.",
    "",
    "---",
    "## Summary",
    "Balanced bracket checking is a perfect use-case for a stack:",
    "- push openings",
    "- pop when the correct closing bracket appears",
    "- fail fast on mismatches",
    "- ensure nothing remains open at the end",
    "",
    "This yields a clean, linear-time solution that correctly handles nested and interleaved bracket structures."
  ],
  "date": "2026-02-04"
}



]
