 [
  {
    "title": "Calculating the Nth Fibonacci Number Using Recursion",
    
    "content": [
        "This Python script demonstrates how to calculate the Nth Fibonacci number using a recursive approach."
    ],
    
    "images": [
        "algorithms_pics/recursive_fibonacci.png"
    ],
    
    "description": [
        "### Key Features of the Script:",
        
        "1. **Fibonacci Sequence:**",
        "   - The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the previous two numbers.",
        
        "2. **Recursive Approach:**",
        "   - The function calls itself recursively to compute the Fibonacci number at position `n`.",
        "   - The base cases are defined: `gertNthFib(1) = 0` and `gertNthFib(2) = 1`.",
        "   - For `n > 2`, the function returns `gertNthFib(n-1) + gertNthFib(n-2)`, simulating the Fibonacci sequence.",
        
        "3. **Output:**",
        "   - The function returns the Nth Fibonacci number as specified by the input.",
        
        "### Complexity Analysis:",
        
        "**Time Complexity:**",
        "- Each call to `gertNthFib(n)` results in two additional recursive calls until the base case is reached.",
        "- This results in an **exponential time complexity of O(2^n)**, making it inefficient for large values of `n`.",
        
        "**Space Complexity:**",
        "- The recursive approach uses a call stack proportional to `n`, leading to a space complexity of **O(n)** in the worst case.",
        "- Since no additional data structures are used, only recursive stack memory is required."
    ],
    
    "date": "2025-01-07"
},
  {
    "title": "Finding the Nth Fibonacci Number Using Iteration",
    
    "content": [
        "This Python script calculates the Nth Fibonacci number using an iterative approach to ensure efficiency and simplicity."
    ],
    
    "images": [
        "algorithms_pics/nth_fibonacci.png"
    ],
    
    "description": [
        "### Key Features of the Script:",
        
        "1. **Fibonacci Sequence:**",
        "   - The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the previous two numbers.",
        
        "2. **Iterative Calculation:**",
        "   - Instead of using recursion, the script uses a loop to calculate the sequence iteratively.",
        "   - This approach avoids excessive memory usage or stack overflow issues.",
        
        "3. **Logic Flow:**",
        "   - For the first Fibonacci number (`n = 1`), it returns 0.",
        "   - For the second Fibonacci number (`n = 2`), it returns 1.",
        "   - For `n > 2`, the script calculates the sequence by summing the last two numbers until the Nth number is reached.",
        
        "4. **Output:**",
        "   - The function returns the Nth Fibonacci number as specified by the input.",
        
        "### Complexity Analysis:",
        
        "**Time Complexity:**",
        "- The function iterates through the sequence using a single loop.",
        "- Since the loop runs `n-2` times, the overall time complexity is **O(n)**.",
        
        "**Space Complexity:**",
        "- The function only uses two integer variables (`prev` and `curr`).",
        "- Since no additional lists or recursive calls are used, the space complexity is **O(1)**."
    ],
    
    "date": "2025-01-08"
}
,
{
    "title": "Calculating Product Sums of Nested Arrays in Python",
    
    "content": [
        "This Python script computes the product sum of a nested array. The product sum is calculated by summing all elements of the array, with elements inside nested arrays being multiplied by their depth."
    ],
    
    "images": [
        "algorithms_pics/product_sum.png"
    ],
    
    "description": [
        "### Key Features of the Product Sum Script:",
        
        "1. **Recursive Approach:**",
        "   - The function `productSum()` uses recursion to handle nested arrays. When an element is a list, the function calls itself with an incremented depth.",
        
        "2. **Depth Multiplier:**",
        "   - For every level of nesting, the sum of elements is multiplied by the current depth. This adds weight to elements that are deeper in the array structure.",
        
        "3. **Handling Mixed Structures:**",
        "   - The function can handle arrays with a mix of integers and nested arrays, processing them seamlessly.",
        
        "### How It Works:",
        
        "1. The script initializes the `result` to 0 and iterates over the elements of the input array.",
        "2. If an element is a list, the function recursively calculates its product sum with an incremented depth.",
        "3. If an element is an integer, it is added directly to the `result`.",
        "4. After iterating through the array, the cumulative sum is multiplied by the current depth and returned.",
        
        "### Complexity Analysis:",
        
        "**Time Complexity:**",
        "- The function processes every element (integers + nested lists) exactly once.",
        "- Since every element contributes to the total sum, the time complexity is **O(E)**, where `E` is the total number of elements, including both integers and nested lists.",
        
        "**Space Complexity:**",
        "- The recursive calls require a stack proportional to the depth `d` of the nested list.",
        "- In the worst case, where the nesting depth is maximum (e.g., a deeply nested list), the space complexity is **O(d)**."
    ],
    
    "date": "2025-01-09"
}

]
