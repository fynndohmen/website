 [
  {
    "title": "Calculating the Nth Fibonacci Number Using Recursion",
    
    "content": [
        "This Python script demonstrates how to calculate the Nth Fibonacci number using a recursive approach."
    ],
    
    "images": [
        "algorithms_pics/recursive_fibonacci.png"
    ],
    
    "description": [
        "### Key Features of the Script:",
        
        "1. **Fibonacci Sequence:**",
        "   - The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the previous two numbers.",
        
        "2. **Recursive Approach:**",
        "   - The function calls itself recursively to compute the Fibonacci number at position `n`.",
        "   - The base cases are defined: `gertNthFib(1) = 0` and `gertNthFib(2) = 1`.",
        "   - For `n > 2`, the function returns `gertNthFib(n-1) + gertNthFib(n-2)`, simulating the Fibonacci sequence.",
        
        "3. **Output:**",
        "   - The function returns the Nth Fibonacci number as specified by the input.",
        
        "### Complexity Analysis:",
        
        "**Time Complexity:**",
        "- Each call to `gertNthFib(n)` results in two additional recursive calls until the base case is reached.",
        "- This results in an **exponential time complexity of O(2^n)**, making it inefficient for large values of `n`.",
        
        "**Space Complexity:**",
        "- The recursive approach uses a call stack proportional to `n`, leading to a space complexity of **O(n)** in the worst case.",
        "- Since no additional data structures are used, only recursive stack memory is required."
    ],
    
    "date": "2025-01-07"
},
  {
    "title": "Finding the Nth Fibonacci Number Using Iteration",
    
    "content": [
        "This Python script calculates the Nth Fibonacci number using an iterative approach to ensure efficiency and simplicity."
    ],
    
    "images": [
        "algorithms_pics/nth_fibonacci.png"
    ],
    
    "description": [
        "### Key Features of the Script:",
        
        "1. **Fibonacci Sequence:**",
        "   - The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the previous two numbers.",
        
        "2. **Iterative Calculation:**",
        "   - Instead of using recursion, the script uses a loop to calculate the sequence iteratively.",
        "   - This approach avoids excessive memory usage or stack overflow issues.",
        
        "3. **Logic Flow:**",
        "   - For the first Fibonacci number (`n = 1`), it returns 0.",
        "   - For the second Fibonacci number (`n = 2`), it returns 1.",
        "   - For `n > 2`, the script calculates the sequence by summing the last two numbers until the Nth number is reached.",
        
        "4. **Output:**",
        "   - The function returns the Nth Fibonacci number as specified by the input.",
        
        "### Complexity Analysis:",
        
        "**Time Complexity:**",
        "- The function iterates through the sequence using a single loop.",
        "- Since the loop runs `n-2` times, the overall time complexity is **O(n)**.",
        
        "**Space Complexity:**",
        "- The function only uses two integer variables (`prev` and `curr`).",
        "- Since no additional lists or recursive calls are used, the space complexity is **O(1)**."
    ],
    
    "date": "2025-01-08"
}
,
{
    "title": "Calculating Product Sums of Nested Arrays in Python",
    
    "content": [
        "This Python script computes the product sum of a nested array. The product sum is calculated by summing all elements of the array, with elements inside nested arrays being multiplied by their depth."
    ],
    
    "images": [
        "algorithms_pics/product_sum.png"
    ],
    
    "description": [
        "### Key Features of the Product Sum Script:",
        
        "1. **Recursive Approach:**",
        "   - The function `productSum()` uses recursion to handle nested arrays. When an element is a list, the function calls itself with an incremented depth.",
        
        "2. **Depth Multiplier:**",
        "   - For every level of nesting, the sum of elements is multiplied by the current depth. This adds weight to elements that are deeper in the array structure.",
        
        "3. **Handling Mixed Structures:**",
        "   - The function can handle arrays with a mix of integers and nested arrays, processing them seamlessly.",
        
        "### How It Works:",
        
        "1. The script initializes the `result` to 0 and iterates over the elements of the input array.",
        "2. If an element is a list, the function recursively calculates its product sum with an incremented depth.",
        "3. If an element is an integer, it is added directly to the `result`.",
        "4. After iterating through the array, the cumulative sum is multiplied by the current depth and returned.",
        
        "### Complexity Analysis:",
        
        "**Time Complexity:**",
        "- The function processes every element (integers + nested lists) exactly once.",
        "- Since every element contributes to the total sum, the time complexity is **O(E)**, where `E` is the total number of elements, including both integers and nested lists.",
        
        "**Space Complexity:**",
        "- The recursive calls require a stack proportional to the depth `d` of the nested list.",
        "- In the worst case, where the nesting depth is maximum (e.g., a deeply nested list), the space complexity is **O(d)**."
    ],
    
    "date": "2025-01-09"
},
  {
"title": "Generating All Permutations (Recursive Build with Slicing)",
"content": [
"This Python routine produces every permutation of an input array using a clean recursive strategy that builds the current permutation while shrinking the remaining pool of elements."
],
"images": ["algorithms_pics/permutations_recursive.png"],
"description": [
"### Problem Statement:",
"- Given an array of distinct (or even non-distinct) values, generate **all permutations**.",
"- Return them as a list of lists, where each inner list is one ordering of the original elements.",
"",
"---",
"### How the Algorithm Works:",
"1. **Driver:** `getPermutations(array)` initializes a result list and calls `permutationsHelper(array, [], permutations)`.",
"",
"2. **State Representation:**",
"   - `array`: the pool of elements **not yet used**.",
"   - `currentPermutation`: the **partial permutation** being built.",
"   - `permutations`: the **output collector**.",
"",
"3. **Base Case:**",
"   - `if not len(array) and len(currentPermutation):`",
"   - When there’s nothing left to choose (`array` empty), the current build is a **complete permutation** → append it.",
"",
"4. **Recursive Step:**",
"   - Iterate `i` through the remaining elements.",
"   - Choose `array[i]`, form:",
"     - `newArray = array[:i] + array[i + 1:]` (all remaining except the chosen one),",
"     - `newPermutation = currentPermutation + [array[i]]` (extend the path).",
"   - Recurse on `(newArray, newPermutation)`; this explores the subtree where `array[i]` occupies the **next position**.",
"",
"---",
"### Why It Enumerates Everything Exactly Once:",
"- Each level fixes one more position in the permutation.",
"- Slicing removes the chosen item, so deeper calls **cannot reuse** it.",
"- The tree has branching factor equal to the remaining items count: `n, n-1, ..., 1` → exactly `n!` leaves.",
"",
"---",
"### Complexity:",
"- **Output size:** There are `n!` permutations; any correct algorithm must output them all.",
"- **Time (rough):** `O(n · n!)` to visit leaves and build each permutation of length `n`.",
"- **Time (with slicing overhead):** Due to `array[:i] + array[i+1:]` creating a fresh list at each step, the **upper bound** is `O(n^2 · n!)`.",
"- **Space:** `O(n · n!)` for storing results; auxiliary recursion depth is `O(n)` plus temporary lists from slicing."
],
"date": "2025-11-10"
}


]
