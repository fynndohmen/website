[
{
  "title": "Kadane's Algorithm: Maximum Subarray Sum",
  "content": [
    "Kadane’s Algorithm efficiently finds the maximum sum of a contiguous subarray within a one-dimensional array of numbers."
  ],
  "images": ["algorithms_pics/kadanes_algorithm.png"],
  "description": [
    "### Problem Statement:",
    "- Given an array of integers, find the **maximum sum** of any **contiguous subarray**.",
    "- The array can include both positive and negative numbers.",
    "",
    "---",
    "### How Kadane’s Algorithm Works:",
    "- The algorithm uses two variables to keep track of important values while iterating through the array:",
    "  1. `maxEndingHere`: the maximum sum of a subarray ending at the current position.",
    "  2. `maxSoFar`: the maximum sum found so far in the entire array.",
    "",
    "### Step-by-Step Logic:",
    "**Initialization:**",
    "- Both `maxEndingHere` and `maxSoFar` are initialized to the first element of the array.",
    "",
    "**Main Loop:**",
    "- For each element `num` in the array (starting from index 1), two actions are performed:",
    "",
    "```python",
    "maxEndingHere = max(num, maxEndingHere + num)",
    "```",
    "- This line decides whether to:",
    "  - Start a new subarray from the current number (`num`), or",
    "  - Extend the previous subarray by adding the current number to `maxEndingHere`.",
    "- It always chooses the option that results in the greater sum.",
    "",
    "```python",
    "maxSoFar = max(maxSoFar, maxEndingHere)",
    "```",
    "- This updates the global maximum `maxSoFar` if the new `maxEndingHere` is greater.",
    "",
    "**Final Output:**",
    "- Once all elements have been processed, `maxSoFar` holds the maximum subarray sum.",
    "",
    "---",
    "### Complexity Analysis:",
    "**Time Complexity:** O(n) — the array is traversed once.",
    "**Space Complexity:** O(1) — only constant extra space is used.",
    "",
    "---",
    "**Why This Is Dynamic Programming:**",
    "Kadane’s Algorithm builds on the idea of solving subproblems — the best subarray sum ending at each index — and combining those sub-results to find the overall solution. This reuse of intermediate results and optimal substructure is characteristic of dynamic programming."
  ],
  "date": "2025-07-06"
},
{
  "title": "Stable Internships: Solving the Stable Matching Problem",
  "content": [
    "This Python function implements a variation of the Stable Marriage Problem — commonly known as the Stable Matching Problem — to assign interns to teams based on mutual preferences."
  ],
  "images": ["algorithms_pics/stable_matching.png"],
  "description": [
    "### Problem Statement:",
    "- Given two equally sized lists: one representing interns and one representing teams.",
    "- Each intern ranks the teams in order of preference.",
    "- Each team ranks the interns in order of preference.",
    "- The goal is to match each intern to one team such that the final set of pairings is **stable** — meaning no intern and team prefer each other over their current matches.",
    "",
    "---",
    "### Algorithm Overview:",
    "- The algorithm is a modified version of the **Gale-Shapley algorithm**.",
    "- Interns propose to teams in the order of their preference lists.",
    "- Each team accepts the best intern so far (according to their preference) and may drop a previous match if a better one proposes.",
    "",
    "---",
    "### Detailed Explanation:",
    "1. **Setup:**",
    "   - `chosenInterns` keeps track of which intern is currently matched to which team.",
    "   - `freeInterns` starts with all interns unassigned.",
    "   - `currentInternChoices` tracks the next team each intern will propose to.",
    "   - `teamMaps` converts each team’s preference list into a dictionary for fast rank lookup.",
    "",
    "2. **Proposal Loop:**",
    "   - While there are unassigned interns, take one and let them propose to their next preferred team.",
    "   - If the team is free, the intern is assigned.",
    "   - If the team already has an intern, the team compares the new and old interns:",
    "     - If the new intern ranks higher, they replace the old one (who goes back into the pool).",
    "     - If not, the new intern tries the next team on their list in the next iteration.",
    "",
    "3. **Result:**",
    "   - When the loop ends, all interns are matched and no unstable pairs exist.",
    "",
    "---",
    "### Key Properties:",
    "- **Stability:** No pair (intern, team) exists where both prefer each other over their current match.",
    "- **Termination:** The algorithm always finishes in a finite number of steps.",
    "- **Optimality:** The result is optimal for the proposing side (interns in this case).",
    "",
    "---",
    "### Complexity Analysis:",
    "**Time Complexity:** O(n²), where `n` is the number of interns (or teams).",
    "- Each intern may propose to every team in the worst case.",
    "**Space Complexity:** O(n²) for storing preference maps and match information.",
    "",
    "---",
    "This matching algorithm is widely used in real-world applications, such as matching medical students to hospitals, assigning students to schools, or pairing job applicants to companies."
  ],
  "date": "2025-07-07"
},
{
  "title": "Union-Find Data Structure with Path Compression and Union by Rank",
  "content": [
    "This Python implementation of the Union-Find (also known as Disjoint Set Union - DSU) data structure efficiently tracks a collection of disjoint sets. It supports two main operations: finding the representative (root) of a set and merging two sets together."
  ],
  "images": ["algorithms_pics/union_find.png"],
  "description": [
    "### Problem Context:",
    "The Union-Find structure is commonly used in algorithms dealing with **connected components**, such as **Kruskal’s algorithm** for Minimum Spanning Trees, or in **cycle detection** within undirected graphs.",
    "",
    "---",
    "### Components of the Union-Find Structure:",
    "",
    "1. **`createSet(value)`**",
    "- Initializes a new set containing a single element.",
    "- The value is its own parent, and its initial rank (tree depth) is set to 0.",
    "",
    "2. **`find(value)` with Path Compression**",
    "- Returns the root representative of the set that contains `value`.",
    "- Uses **path compression**, which flattens the tree by making every node point directly to the root. This dramatically speeds up future queries.",
    "",
    "3. **`union(valueOne, valueTwo)` with Union by Rank**",
    "- Merges the sets containing `valueOne` and `valueTwo`.",
    "- Uses **union by rank** to ensure that the smaller tree is attached to the larger one, minimizing depth.",
    "- If ranks are equal, one tree becomes root and its rank increases.",
    "",
    "---",
    "### Time and Space Complexity Analysis:",
    "",
    "**`createSet(value)`**",
    "- Time Complexity: **O(1)** — Constant time to insert the value into two dictionaries.",
    "- Space Complexity: **O(1)** per call — One entry added to each of the `parents` and `ranks` dictionaries.",
    "",
    "**`find(value)`**",
    "- Time Complexity: **Amortized O(α(n))**, where **α(n)** is the inverse Ackermann function — extremely slow-growing and nearly constant for all practical input sizes.",
    "- Space Complexity: **O(1)** auxiliary (aside from recursive call stack if implemented recursively).",
    "",
    "**`union(valueOne, valueTwo)`**",
    "- Time Complexity: **Amortized O(α(n))**, because it calls `find` and does constant-time rank comparisons and updates.",
    "- Space Complexity: **O(1)** — only performs dictionary updates.",
    "",
    "---",
    "### Why It's Efficient:",
    "- By combining **path compression** (during `find`) and **union by rank**, this implementation achieves nearly constant time per operation, even for a large number of elements and operations.",
    "",
    "This makes Union-Find one of the most powerful tools for managing dynamic connectivity and disjoint-set problems efficiently."
  ],
  "date": "2025-07-08"
}



]
