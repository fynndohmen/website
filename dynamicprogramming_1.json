[
{
  "title": "Maximum Subset Sum with No Adjacent Elements",
  "content": [
    "This Python function solves the problem of finding the maximum sum of non-adjacent elements in an array. It ensures that no two selected elements are next to each other."
  ],
  "images": ["algorithms_pics/max_subset_sum.png"],
  "description": [
    "### Problem Statement:",
    "- Given an array of integers, return the maximum sum of non-adjacent elements.",
    "- You may not pick two elements that are next to each other.",
    "- The array can include negative numbers, but the result should reflect the best possible sum under the constraint.",
    "",
    "---",
    "### First Approach: Using a DP Array",
    "This method uses an auxiliary array (`maxSums`) to store the maximum sum at each position.",
    "",
    "**How it works:**",
    "1. Initialize `maxSums[0] = array[0]` and `maxSums[1] = max(array[0], array[1])`.",
    "2. For each index `i` from 2 to end of array:",
    "   - Either take the current element and add it to `maxSums[i-2]`, or skip it and carry forward `maxSums[i-1]`.",
    "   - Set `maxSums[i] = max(maxSums[i-1], maxSums[i-2] + array[i])`.",
    "3. The final value in `maxSums[-1]` is the result.",
    "",
    "**Time Complexity:** O(n) — one pass through the array.",
    "**Space Complexity:** O(n) — due to the `maxSums` array.",
    "",
    "---",
    "### Second Approach: Optimized Space with Two Variables",
    "This method optimizes space by maintaining only two variables: `first` and `second`.",
    "",
    "**How it works:**",
    "1. Initialize `second = array[0]` and `first = max(array[0], array[1])`.",
    "2. For each element from index 2 onward:",
    "   - Compute `current = max(first, second + array[i])`.",
    "   - Update `second = first` and `first = current`.",
    "3. At the end, `first` contains the maximum sum.",
    "",
    "**Time Complexity:** O(n) — iterates through array once.",
    "**Space Complexity:** O(1) — only a constant amount of memory is used.",
    "",
    "---",
    "**Why This Is Dynamic Programming:**",
    "This problem follows the principles of dynamic programming because it breaks the problem into smaller subproblems (maximum sum up to each index), stores the results of those subproblems (either in an array or variables), and uses those stored results to build up the solution efficiently without recomputing. The decision at each index depends on previously computed optimal results, which is a core characteristic of dynamic programming."
  ],
  "date": "2025-06-30"
},
{
  "title": "Number of Ways to Make Change",
  "content": [
    "This Python function calculates the number of distinct ways to make change for a given amount using a list of coin denominations."
  ],
  "images": ["algorithms_pics/coin_change_ways.png"],
  "description": [
    "### Problem Statement:",
    "- Given an integer `n` and a list of coin denominations `denoms`, determine how many different combinations of the coins can sum up to `n`.",
    "- Each coin may be used unlimited times.",
    "",
    "---",
    "### How the Algorithm Works:",
    "- An array `ways` of size `n + 1` is initialized to store the number of ways to make each amount from `0` to `n`.",
    "- `ways[0]` is set to 1 because there is exactly one way to make `0` — by choosing no coins.",
    "- The outer loop iterates over each denomination in `denoms`.",
    "- The inner loop iterates over all amounts from `1` to `n`.",
    "- For every amount greater than or equal to the current denomination, we update the ways to make that amount by adding the number of ways to make `amount - denom`.",
    "",
    "This means we're building up the solution to the full amount by using previously computed solutions to smaller subproblems.",
    "",
    "**Time Complexity:** O(n * d), where `n` is the target amount and `d` is the number of denominations.",
    "**Space Complexity:** O(n) for the `ways` array.",
    "",
    "---",
    "**Why This Is Dynamic Programming:**",
    "This algorithm solves a problem by breaking it into overlapping subproblems — the number of ways to make change for smaller amounts — and stores the results of those subproblems in the `ways` array. It reuses those stored results to build up solutions to larger subproblems. This bottom-up approach with memoization is a hallmark of dynamic programming."
  ],
  "date": "2025-06-31"
}


]
  
