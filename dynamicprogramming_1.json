[
{
  "title": "Maximum Subset Sum with No Adjacent Elements",
  "content": [
    "This Python function solves the problem of finding the maximum sum of non-adjacent elements in an array. It ensures that no two selected elements are next to each other."
  ],
  "images": ["algorithms_pics/max_subset_sum.png"],
  "description": [
    "### Problem Statement:",
    "- Given an array of integers, return the maximum sum of non-adjacent elements.",
    "- You may not pick two elements that are next to each other.",
    "- The array can include negative numbers, but the result should reflect the best possible sum under the constraint.",
    "",
    "---",
    "### First Approach: Using a DP Array",
    "This method uses an auxiliary array (`maxSums`) to store the maximum sum at each position.",
    "",
    "**How it works:**",
    "1. Initialize `maxSums[0] = array[0]` and `maxSums[1] = max(array[0], array[1])`.",
    "2. For each index `i` from 2 to end of array:",
    "   - Either take the current element and add it to `maxSums[i-2]`, or skip it and carry forward `maxSums[i-1]`.",
    "   - Set `maxSums[i] = max(maxSums[i-1], maxSums[i-2] + array[i])`.",
    "3. The final value in `maxSums[-1]` is the result.",
    "",
    "**Time Complexity:** O(n) — one pass through the array.",
    "**Space Complexity:** O(n) — due to the `maxSums` array.",
    "",
    "---",
    "### Second Approach: Optimized Space with Two Variables",
    "This method optimizes space by maintaining only two variables: `first` and `second`.",
    "",
    "**How it works:**",
    "1. Initialize `second = array[0]` and `first = max(array[0], array[1])`.",
    "2. For each element from index 2 onward:",
    "   - Compute `current = max(first, second + array[i])`.",
    "   - Update `second = first` and `first = current`.",
    "3. At the end, `first` contains the maximum sum.",
    "",
    "**Time Complexity:** O(n) — iterates through array once.",
    "**Space Complexity:** O(1) — only a constant amount of memory is used.",
    "",
    "---",
    "**Why This Is Dynamic Programming:**",
    "This problem follows the principles of dynamic programming because it breaks the problem into smaller subproblems (maximum sum up to each index), stores the results of those subproblems (either in an array or variables), and uses those stored results to build up the solution efficiently without recomputing. The decision at each index depends on previously computed optimal results, which is a core characteristic of dynamic programming."
  ],
  "date": "2025-06-30"
},
{
  "title": "Number of Ways to Make Change",
  "content": [
    "This Python function calculates the number of distinct ways to make change for a given amount using a list of coin denominations."
  ],
  "images": ["algorithms_pics/coin_change_ways.png"],
  "description": [
    "### Problem Statement:",
    "- Given an integer `n` and a list of coin denominations `denoms`, determine how many different combinations of the coins can sum up to `n`.",
    "- Each coin may be used unlimited times.",
    "",
    "---",
    "### How the Algorithm Works:",
    "- An array `ways` of size `n + 1` is initialized to store the number of ways to make each amount from `0` to `n`.",
    "- `ways[0]` is set to 1 because there is exactly one way to make `0` — by choosing no coins.",
    "- The outer loop iterates over each denomination in `denoms`.",
    "- The inner loop iterates over all amounts from `1` to `n`.",
    "",
    "**What exactly happens in the inner loop?**",
    "- For each amount `amount` from `1` to `n`, the algorithm checks if the current coin `denom` can contribute to that amount (i.e., `denom <= amount`).",
    "- If it can, it means we can form `amount` by first forming `amount - denom`, and then adding the current coin `denom`.",
    "- The value `ways[amount - denom]` represents the number of ways to make `amount - denom`, so all of those ways become valid ways to make `amount` when we include `denom`.",
    "- Thus, we add `ways[amount - denom]` to `ways[amount]`.",
    "",
    "This process builds up the total number of combinations for each amount in a bottom-up manner, reusing previously computed values.",
    "",
    "**Time Complexity:** O(n * d), where `n` is the target amount and `d` is the number of denominations.",
    "**Space Complexity:** O(n) for the `ways` array.",
    "",
    "---",
    "**Why This Is Dynamic Programming:**",
    "This algorithm solves a complex problem by breaking it down into overlapping subproblems — specifically, the number of ways to make smaller amounts. It stores the results of these subproblems in the `ways` array and reuses them to build up solutions to larger amounts. This bottom-up reuse of prior results is a classic dynamic programming technique."
  ],
  "date": "2025-07-01"
}
,
{
  "title": "Minimum Number of Coins for Change",
  "content": [
    "This Python function determines the minimum number of coins needed to make a specific amount of change using given coin denominations. It now returns `-1` if the amount cannot be formed with the available coins."
  ],
  "images": ["algorithms_pics/min_coins_change.png"],
  "description": [
    "### Problem Statement:",
    "- Given an integer `n` (target amount) and a list of coin denominations `denoms`, compute the minimum number of coins required to make `n`.",
    "- If it is not possible to form `n` with the given denominations, return `-1`.",
    "",
    "---",
    "### How the Algorithm Works:",
    "- An array `numOfCoins` of size `n + 1` is initialized with all values set to `float('inf')`, except for index `0`, which is set to `0`.",
    "- `numOfCoins[i]` represents the minimum number of coins needed to make amount `i`.",
    "",
    "The outer loop iterates over each coin denomination.",
    "The inner loop iterates through every amount from `0` to `n`.",
    "",
    "### Key Logic in the Inner Loop:",
    "```python",
    "if denom <= amount:",
    "    numOfCoins[amount] = min(numOfCoins[amount], 1 + numOfCoins[amount - denom])",
    "```",
    "- This checks if the current coin can contribute to the current amount.",
    "- If so, it updates the number of coins needed to reach that amount by comparing the current best value with one more coin plus the number of coins needed for the remaining amount (`amount - denom`).",
    "",
    "---",
    "### Final Return Statement:",
    "```python",
    "return numOfCoins[n] if numOfCoins[n] != float('inf') else -1",
    "```",
    "- After processing all denominations and amounts, if `numOfCoins[n]` is still infinity, that means no combination was found to form amount `n` — in that case, return `-1`.",
    "- Otherwise, return the computed minimum number of coins.",
    "",
    "**Time Complexity:** O(n * d), where `n` is the target amount and `d` is the number of denominations.",
    "**Space Complexity:** O(n) — for the `numOfCoins` array.",
    "",
    "---",
    "**Why This Is Dynamic Programming:**",
    "This algorithm uses a bottom-up approach to solve a problem by building solutions to all smaller subproblems first. It stores intermediate results (minimum coins for smaller amounts) and reuses them, avoiding redundant work. This optimal substructure and overlapping subproblems pattern is a hallmark of dynamic programming."
  ],
  "date": "2025-07-02"
}



]
  
