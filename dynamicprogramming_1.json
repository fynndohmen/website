[
{
  "title": "Maximum Subset Sum with No Adjacent Elements",
  "content": [
    "This Python function solves the problem of finding the maximum sum of non-adjacent elements in an array. It ensures that no two selected elements are next to each other."
  ],
  "images": ["algorithms_pics/max_subset_sum.png"],
  "description": [
    "### Problem Statement:",
    "- Given an array of integers, return the maximum sum of non-adjacent elements.",
    "- You may not pick two elements that are next to each other.",
    "- The array can include negative numbers, but the result should reflect the best possible sum under the constraint.",
    "",
    "---",
    "### First Approach: Using a DP Array",
    "This method uses an auxiliary array (`maxSums`) to store the maximum sum at each position.",
    "",
    "**How it works:**",
    "1. Initialize `maxSums[0] = array[0]` and `maxSums[1] = max(array[0], array[1])`.",
    "2. For each index `i` from 2 to end of array:",
    "   - Either take the current element and add it to `maxSums[i-2]`, or skip it and carry forward `maxSums[i-1]`.",
    "   - Set `maxSums[i] = max(maxSums[i-1], maxSums[i-2] + array[i])`.",
    "3. The final value in `maxSums[-1]` is the result.",
    "",
    "**Time Complexity:** O(n) — one pass through the array.",
    "**Space Complexity:** O(n) — due to the `maxSums` array.",
    "",
    "---",
    "### Second Approach: Optimized Space with Two Variables",
    "This method optimizes space by maintaining only two variables: `first` and `second`.",
    "",
    "**How it works:**",
    "1. Initialize `second = array[0]` and `first = max(array[0], array[1])`.",
    "2. For each element from index 2 onward:",
    "   - Compute `current = max(first, second + array[i])`.",
    "   - Update `second = first` and `first = current`.",
    "3. At the end, `first` contains the maximum sum.",
    "",
    "**Time Complexity:** O(n) — iterates through array once.",
    "**Space Complexity:** O(1) — only a constant amount of memory is used.",
    "",
    "---",
    "**Why This Is Dynamic Programming:**",
    "This problem follows the principles of dynamic programming because it breaks the problem into smaller subproblems (maximum sum up to each index), stores the results of those subproblems (either in an array or variables), and uses those stored results to build up the solution efficiently without recomputing. The decision at each index depends on previously computed optimal results, which is a core characteristic of dynamic programming."
  ],
  "date": "2025-06-30"
},
{
  "title": "Number of Ways to Make Change",
  "content": [
    "This Python function calculates the number of distinct ways to make change for a given amount using a list of coin denominations."
  ],
  "images": ["algorithms_pics/coin_change_ways.png"],
  "description": [
    "### Problem Statement:",
    "- Given an integer `n` and a list of coin denominations `denoms`, determine how many different combinations of the coins can sum up to `n`.",
    "- Each coin may be used unlimited times.",
    "",
    "---",
    "### How the Algorithm Works:",
    "- An array `ways` of size `n + 1` is initialized to store the number of ways to make each amount from `0` to `n`.",
    "- `ways[0]` is set to 1 because there is exactly one way to make `0` — by choosing no coins.",
    "- The outer loop iterates over each denomination in `denoms`.",
    "- The inner loop iterates over all amounts from `1` to `n`.",
    "",
    "**What exactly happens in the inner loop?**",
    "- For each amount `amount` from `1` to `n`, the algorithm checks if the current coin `denom` can contribute to that amount (i.e., `denom <= amount`).",
    "- If it can, it means we can form `amount` by first forming `amount - denom`, and then adding the current coin `denom`.",
    "- The value `ways[amount - denom]` represents the number of ways to make `amount - denom`, so all of those ways become valid ways to make `amount` when we include `denom`.",
    "- Thus, we add `ways[amount - denom]` to `ways[amount]`.",
    "",
    "_In short: `ways[amount] += ways[amount - denom]` counts exactly all new combinations that include the current coin `denom`._",
    "",
    "**When do new combinations appear?**",
    "- **Special case (only this coin is allowed):** New combinations appear exactly when `amount` is a multiple of `denom`. Example: with only 5-cent coins, amounts 5, 10, 15, ... each gain a way.",
    "- **General case (multiple coins are allowed):** New combinations appear whenever `amount - denom` is already formable with the coins processed so far — even if `amount - denom` is not a multiple of `denom`. Example: with `denoms = [1, 5]`, for `amount = 6` and `denom = 5`, `6 - 5 = 1` is formable (using `1`), so `5 + 1` adds a new combination.",
    "",
    "#### Worked example (denoms = [1, 5, 10, 25], n = 10):",
    "- **Start:** `ways[0] = 1`, everything else `0`.",
    "- **Coin 1:** Each amount `a ≥ 1` gets `ways[a] += ways[a-1]`. After processing coin 1, every `ways[a]` becomes `1`. ➜ First **1** at `ways[10]` corresponds to `10×1`.",
    "- **Coin 5:** For `a = 5..10`, do `ways[a] += ways[a-5]`.",
    "  - At `a = 5`: `ways[5]` goes from `1` to `2` (either `5×1` or `1×5`) ➜ first **2**.",
    "  - At `a = 10`: `ways[10]` goes from `1` to `3` by adding `ways[5] = 2` (the two ways to make `5` plus another `5`): `5+5` and `5 + five 1s` ➜ becomes **3**.",
    "- **Coin 10:** For `a = 10`, add `ways[0] = 1`, so `ways[10]` becomes **4** thanks to `1×10`.",
    "- **Coin 25:** No effect for `n = 10`.",
    "- **Final combinations for 10:** `10×1`, `5×1 + 1×5`, `2×5`, `1×10` (total **4**).",
    "",
    "This process builds up the total number of combinations for each amount in a bottom-up manner, reusing previously computed values.",
    "",
    "**Time Complexity:** O(n * d), where `n` is the target amount and `d` is the number of denominations.",
    "**Space Complexity:** O(n) for the `ways` array.",
    "",
    "---",
    "**Why This Is Dynamic Programming:**",
    "This algorithm solves a complex problem by breaking it down into overlapping subproblems — specifically, the number of ways to make smaller amounts. It stores the results of these subproblems in the `ways` array and reuses them to build up solutions to larger amounts. This bottom-up reuse of prior results is a classic dynamic programming technique."
  ],
  "date": "2025-07-01"
},
{
  "title": "Minimum Number of Coins for Change",
  "content": [
    "This Python function determines the minimum number of coins needed to make a specific amount of change using given coin denominations. It now returns `-1` if the amount cannot be formed with the available coins."
  ],
  "images": ["algorithms_pics/min_coins_change.png"],
  "description": [
    "### Problem Statement:",
    "- Given an integer `n` (target amount) and a list of coin denominations `denoms`, compute the minimum number of coins required to make `n`.",
    "- If it is not possible to form `n` with the given denominations, return `-1`.",
    "",
    "---",
    "### How the Algorithm Works:",
    "- An array `numOfCoins` of size `n + 1` is initialized with all values set to `float('inf')`, except for index `0`, which is set to `0`.",
    "- `numOfCoins[i]` represents the minimum number of coins needed to make amount `i`.",
    "",
    "The outer loop iterates over each coin denomination.",
    "The inner loop iterates through every amount from `0` to `n`.",
    "",
    "### Key Logic in the Inner Loop:",
    "```python",
    "if denom <= amount:",
    "    numOfCoins[amount] = min(numOfCoins[amount], 1 + numOfCoins[amount - denom])",
    "```",
    "- This checks if the current coin can contribute to the current amount.",
    "- If so, it updates the number of coins needed to reach that amount by comparing the current best value with one more coin plus the number of coins needed for the remaining amount (`amount - denom`).",
    "",
    "---",
    "### Final Return Statement:",
    "```python",
    "return numOfCoins[n] if numOfCoins[n] != float('inf') else -1",
    "```",
    "- After processing all denominations and amounts, if `numOfCoins[n]` is still infinity, that means no combination was found to form amount `n` — in that case, return `-1`.",
    "- Otherwise, return the computed minimum number of coins.",
    "",
    "**Time Complexity:** O(n * d), where `n` is the target amount and `d` is the number of denominations.",
    "**Space Complexity:** O(n) — for the `numOfCoins` array.",
    "",
    "---",
    "**Why This Is Dynamic Programming:**",
    "This algorithm uses a bottom-up approach to solve a problem by building solutions to all smaller subproblems first. It stores intermediate results (minimum coins for smaller amounts) and reuses them, avoiding redundant work. This optimal substructure and overlapping subproblems pattern is a hallmark of dynamic programming."
  ],
  "date": "2025-07-02"
},
{
  "title": "Calculating Levenshtein Distance (Edit Distance) in Python",
  "content": [
    "This Python function calculates the Levenshtein Distance between two strings — the minimum number of single-character edits (insertions, deletions, or substitutions) needed to transform one string into another."
  ],
  "images": ["algorithms_pics/levenshtein_distance.png"],
  "description": [
    "### Problem Statement:",
    "- Given two strings `str1` and `str2`, compute the minimum number of edit operations required to convert `str1` into `str2`.",
    "- Allowed operations are:",
    "  - Insertion",
    "  - Deletion",
    "  - Substitution",
    "",
    "---",
    "### How the Algorithm Works:",
    "- A 2D matrix `edits` is used where `edits[i][j]` stores the Levenshtein Distance between the first `i` characters of `str2` and the first `j` characters of `str1`.",
    "- The matrix is initialized such that the first row and first column represent the cost of converting an empty string to the respective prefix.",
    "",
    "**Initialization:**",
    "- `edits[0][j] = j` for all `j`: cost of inserting all characters of `str1`.",
    "- `edits[i][0] = i` for all `i`: cost of deleting all characters of `str2`.",
    "",
    "**Core Logic:**",
    "- For every character pair `(str2[i-1], str1[j-1])`, we compare and update the edit cost:",
    "  - If the characters match, no operation is needed: `edits[i][j] = edits[i-1][j-1]`.",
    "  - Otherwise, choose the operation with the lowest accumulated cost:",
    "    1. **Substitution:** `edits[i-1][j-1] + 1` — replace `str1[j-1]` with `str2[i-1]`.",
    "    2. **Insertion:** `edits[i][j-1] + 1` — insert `str2[i-1]` into `str1`.",
    "    3. **Deletion:** `edits[i-1][j] + 1` — delete `str1[j-1]`.",
    "- Hence, the update is: `edits[i][j] = 1 + min(substitution, insertion, deletion)`.",
    "",
    "**Why are these three operations valid?**",
    "- These reflect all the possible ways we can resolve a mismatch at position `(i, j)`: either change the character, add a character, or remove one.",
    "- Dynamic programming ensures that we always build on previously computed minimal costs to arrive at the most efficient solution.",
    "",
    "**Final Result:**",
    "- The bottom-right cell `edits[len(str2)][len(str1)]` contains the total minimum edit distance.",
    "",
    "**Time Complexity:** O(n * m), where `n` and `m` are the lengths of the two strings.",
    "**Space Complexity:** O(n * m) — due to the 2D matrix used.",
    "",
    "---",
    "**Why This Is Dynamic Programming:**",
    "This problem is solved by dividing it into smaller overlapping subproblems — computing the edit distance for prefixes of both strings. Each subproblem builds upon previously solved subproblems, stored in a table to avoid redundant computation. This reuse of results to construct a solution incrementally is a defining feature of dynamic programming."
  ],
  "date": "2025-07-03"
},
{
  "title": "Levenshtein Distance with Optimized Space in Python",
  "content": [
    "This implementation calculates the Levenshtein Distance (Edit Distance) between two strings while optimizing space complexity. It improves upon the standard dynamic programming approach by using only two 1D arrays instead of a full 2D matrix."
  ],
  "images": ["algorithms_pics/levenshtein_distance_optimized.png"],
  "description": [
    "### Problem Statement:",
    "- Given two strings `str1` and `str2`, determine the minimum number of edit operations (insertions, deletions, or substitutions) required to convert one string into the other.",
    "- The algorithm aims to reduce memory usage while maintaining accurate computation.",
    "",
    "---",
    "### Key Differences from the Classic DP Solution:",
    "In the classic approach, a 2D matrix of size `(len(str2) + 1) x (len(str1) + 1)` is created. This solution, however, uses only two 1D arrays, each of length `min(len(str1), len(str2)) + 1`, to alternate between current and previous rows.",
    "",
    "### Step-by-Step Explanation of the Optimized Version:",
    "1. **String Selection for Optimization:**",
    "- To minimize space, the shorter string is assigned to `small`, and the longer one to `big`.",
    "- This ensures the 1D arrays are as small as possible.",
    "",
    "2. **Array Initialization:**",
    "- `evenEdits` represents the current state of edit distances at even iterations.",
    "- `oddEdits` is used during odd iterations.",
    "- Both arrays hold only one row of the full DP matrix, with `evenEdits` initially filled with `[0, 1, 2, ..., len(small)]`, representing edit distances from an empty string to increasing prefixes.",
    "",
    "3. **Main Loop Over the Longer String (`big`):**",
    "- For each character in `big`, we calculate a new row of edit distances (`currentEdits`) based on the previous one (`previousEdits`).",
    "- The first element of `currentEdits` is set to `i`, which represents the cost of deleting all characters from `big[:i]` to match an empty string.",
    "- The `if i % 2 == 1` block determines whether to use `oddEdits` or `evenEdits` for writing and reading.",
    "",
    "4. **Nested Loop Over the Shorter String (`small`):**",
    "- If characters match (`big[i - 1] == small[j - 1]`), no operation is needed; reuse the diagonal value: `currentEdits[j] = previousEdits[j - 1]`.",
    "- If they differ, take the minimum cost of the three possible operations:",
    "   - **Substitution:** `previousEdits[j - 1] + 1`",
    "   - **Deletion:** `previousEdits[j] + 1`",
    "   - **Insertion:** `currentEdits[j - 1] + 1`",
    "",
    "5. **Result Selection:**",
    "- After all iterations, return the last element of either `evenEdits` or `oddEdits` depending on the parity of `len(big)`.",
    "",
    "---",
    "### Complexity Analysis:",
    "**Time Complexity:** O(n * m), where `n` and `m` are the lengths of the two input strings.",
    "**Space Complexity:** O(min(n, m)) — only two rows (arrays) of the matrix are maintained at any time.",
    "",
    "---",
    "**Why This Is Dynamic Programming:**",
    "This solution still solves overlapping subproblems by building up a table of minimal edits between substrings. It reuses previously computed solutions and uses memoization via a rolling array pattern. The key difference is that instead of storing the entire matrix, only the essential information from the previous step is kept, demonstrating space-efficient dynamic programming."
  ],
  "date": "2025-07-04"
},
{
  "title": "Number of Ways to Traverse a Grid",
  "content": [
    "This Python function computes the number of distinct paths from the top-left corner to the bottom-right corner of a 2D grid, where movement is only allowed to the right or downward."
  ],
  "images": ["algorithms_pics/grid_traversal.png"],
  "description": [
    "### Problem Statement:",
    "- Given a grid with `width` columns and `height` rows, calculate the total number of unique paths from the top-left corner (1,1) to the bottom-right corner (width,height).",
    "- You can only move either **right** or **down** at any step.",
    "",
    "---",
    "### How the Algorithm Works:",
    "- The function uses dynamic programming to fill a 2D table `numberOfWays`, where `numberOfWays[i][j]` represents the number of ways to reach cell `(i, j)`.",
    "",
    "1. **Initialization:**",
    "- A 2D array of size `(height + 1) x (width + 1)` is created and initialized with zeros.",
    "- The loop starts from index `1` to account for the base case more naturally.",
    "",
    "2. **Base Cases:**",
    "- If the current cell is in the **first row** or **first column**, there is only **one** way to reach it—either all right moves or all down moves.",
    "",
    "```python",
    "if widthIdx == 1 or heightIdx == 1:",
    "    numberOfWays[heightIdx][widthIdx] = 1",
    "```",
    "",
    "3. **DP Transition:**",
    "- For all other cells, the number of ways to reach cell `(i, j)` is the sum of:",
    "   - The number of ways to reach the cell **to the left** `(i, j-1)` (moving right), and",
    "   - The number of ways to reach the cell **above** `(i-1, j)` (moving down).",
    "",
    "```python",
    "waysLeft = numberOfWays[heightIdx][widthIdx - 1]",
    "waysUp = numberOfWays[heightIdx - 1][widthIdx]",
    "numberOfWays[heightIdx][widthIdx] = waysLeft + waysUp",
    "```",
    "",
    "4. **Final Result:**",
    "- After populating the entire table, the answer is found at `numberOfWays[height][width]`.",
    "",
    "---",
    "### Complexity Analysis:",
    "**Time Complexity:** O(width × height) — Every cell in the grid is visited once.",
    "**Space Complexity:** O(width × height) — The entire DP table is stored in memory.",
    "",
    "---",
    "**Why This Is Dynamic Programming:**",
    "This problem is broken down into smaller overlapping subproblems: how to reach each cell based on its neighbors. The results of subproblems are stored and reused to solve larger problems efficiently, which is the core principle of dynamic programming."
  ],
  "date": "2025-07-05"
}





]
  
