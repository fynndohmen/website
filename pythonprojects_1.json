[
    {
        "title": "Python Tic-Tac-Toe Game",
        "content": [
            "This Python script implements a simple yet functional Tic-Tac-Toe game. Two players can play the game alternately on a 3x3 board. The program handles user inputs, checks for a winner, and declares a draw when no more moves are possible."
        ],
        "images": ["python_projects_pics/tic_tac_toe.png"],
        "description": [
            "### Key Features of the Code:",
            "1. **Board Display:** The `display` function creates a formatted string to represent the Tic-Tac-Toe board and prints it for players after every move.",
            "2. **Winner Check:** The `check_winner` function checks rows, columns, and diagonals for a winning condition and ends the game if a player wins. It also declares a draw if no spaces are left.",
            "3. **Player Moves:** The `play` function ensures that players can only place their marks on empty spaces, prompting them to try again if the field is already occupied.",
            "4. **Game Loop:** The `while True` loop alternates between the two players, allowing them to make moves, updates the board, and checks for game-ending conditions.",
            "### How It Works:",
            "- The board is initialized as a 3x3 grid filled with `.` to indicate empty spaces.",
            "- Players take turns entering their moves as coordinates (e.g., `0 1` for row 0 and column 1).",
            "- After each move, the board is displayed, and the program checks if the move led to a win or a draw.",
            "- The game ends when one player wins or all spaces are occupied.",
            "### Example Use:",
            "1. Start the game, and the empty board is displayed:",
            "   ```",
            "   ...",
            "   ...",
            "   ...",
            "   ```",
            "2. Player `O` makes the first move: `0 0`",
            "   ```",
            "   O..",
            "   ...",
            "   ...",
            "   ```",
            "3. Players alternate turns until the game ends with a win or a draw."
        ],
        "date": "2024-12-09"
    },
    {
    "title": "Building a To-Do List Application with Python and Tkinter",
    "content": [
        "This blogpost walks you through the process of creating a simple To-Do List application using Python and the Tkinter library for the graphical user interface (GUI). The application allows users to add tasks, mark them as completed, and delete tasks. Tasks are saved persistently using a JSON file."
    ],
    "images": [
        "python_projects_pics/To-Do_List.png"
    ],
    "description": [
        "### Key Features of the To-Do List Application:",
        "1. **Graphical User Interface:** The application uses Tkinter to provide a simple, user-friendly GUI.",
        "2. **Task Management:** Users can add new tasks, view open tasks, mark tasks as completed, and delete tasks.",
        "3. **Separation of Logic:** The application is divided into multiple modules: `views.py` handles the GUI, `controllers.py` manages the control logic, and `models.py` handles the data and storage logic.",
        "4. **Persistent Storage:** Tasks are stored in a JSON file (`database.json`), ensuring that tasks persist across sessions.",
        "",
        "### How the Code Works:",
        "1. **Starting the Application:** The application begins by loading existing tasks from `database.json` using the `load_from_storage` function in `models.py`.",
        "2. **Adding a Task:** When the user enters a task and clicks the 'Add task' button, the `add_task` function in `views.py` calls `handle_add_task` from `controllers.py`, which updates the task list and saves it to the JSON file.",
        "3. **Marking a Task as Completed:** The user can select a task from the open tasks list and click 'Mark as completed'. This triggers the `mark_task_completed` function, which updates the task's status and moves it to the completed tasks list.",
        "4. **Deleting a Task:** The user can delete tasks from either the open or completed lists by selecting the task and clicking 'Delete task'. This action removes the task from the list and updates the JSON file.",
        "",
        "### Code Structure:",
        "- **main.py:** The entry point of the application, which initializes the GUI and starts the Tkinter event loop.",
        "- **app/views.py:** Manages the graphical user interface and handles user interactions.",
        "- **app/controllers.py:** Contains the control logic that connects the GUI with the data layer.",
        "- **app/models.py:** Manages task data, including adding, updating, deleting, and saving tasks.",
        "- **data/database.json:** Stores tasks persistently in JSON format.",
        "",
        "### GitHub Repository:",
        "You can find the complete source code for this project on [GitHub](https://github.com/fynndohmen/To-Do-List.git)."
    ],
    "date": "2025-01-04"
},
{
    "title": "Simple Calculator App",
    "content": [
        "This Python application demonstrates a functional calculator with a graphical user interface (GUI) built using the Tkinter library. The calculator supports basic arithmetic operations, advanced features like square root and squaring, and a toggleable dark mode for a customizable user experience."
    ],
    "images": [
        "python_projects_pics/calculator.png"
    ],
    "description": [
        "### Features of the Calculator Application:",
        "1. **Basic Arithmetic:**",
        "   - Perform operations such as addition, subtraction, multiplication, and division with ease.",
        "2. **Advanced Functions:**",
        "   - Includes support for square root and squaring calculations.",
        "3. **Clear Functionality:**",
        "   - Reset the calculator display and start fresh with a single click.",
        "4. **Dark Mode:**",
        "   - Toggle between a light and dark theme to suit user preference.",
        "### GitHub Repository:",
        "You can find the complete source code for this project on [GitHub](https://github.com/fynndohmen/Calculator.git)."
    ],
    "date": "2025-01-26"
},
{
  "title": "Building a Live FinTS-Powered Expense Tracker in Python",
  "content": [
    "In this post, we present a dynamic Python expense tracker that connects directly to your bank via FinTS, automatically categorizes transactions, lets you manage and order your spending categories with a GUI, and generates rich, color-coded visualizations of your income, expenses, and balance in real time."
  ],
  "images": [
    "python_projects_pics/visualizer_chart.png",
    "python_projects_pics/category_manager_ui.png"
  ],
  "description": [
    "### Key Features",
    "- **Live Bank Integration**: Uses `fints_connector.py` to fetch your SEPA transactions and balance directly from your bank with FinTS-Pin/TAN.",
    "- **Smart Categorization**: The `Categorizer` prompts just once per new description and saves mappings in `categories.json` for fully automated categorization thereafter.",
    "- **Category Management GUI**: A Tkinter-based Category Manager (`category_manager.py`) lets you sort and group categories into **Fixed**, **Variable** and **Unassigned**, storing your preferences in `category_order.json`.",
    "- **Automated Color Assignment**: `ColorManager` assigns distinct colors per category from a preset palette (falling back to random hex) and persists them in `category_colors.json`.",
    "- **Real-Time Interactive Visualization**: The `Visualizer` builds a Plotly figure with:",
    "  - A **stacked area chart** of monthly fixed and variable expenses,",
    "  - A **constant income line**,",
    "  - A **running account balance** pulled live,",
    "  - **Daily cumulative expense lines** with markers and hover tooltips showing transaction details.",
    "",
    "### How It Works",
    "1. **Startup & Live Fetch**",
    "   - `main.py` initializes the FinTS connection (`FinTSConnector`), prompts for TAN when required, fetches all new transactions since the last sync, and retrieves current balances.",
    "",
    "2. **Automatic Categorization**",
    "   - Any transaction without a stored `category` triggers `Categorizer.categorize_transaction`, which asks you once and writes the result to `categories.json`.",
    "",
    "3. **Category Management**",
    "   - If `category_order.json` is missing or needs updating, the Category Manager GUI opens automatically for you to define and reorder categories.",
    "",
    "4. **Visualization**",
    "   - `Visualizer.generate_chart` reads the live-fetched, categorized transactions and balance, computes monthly sums, and renders a multi-trace Plotly dashboard with consistent colors via `ColorManager`.",
    "",
    "### Why This Approach?",
    "- **Fully Dynamic**: No manual file imports—data flows directly from your bank each run.",
    "- **Modular Design**: Separates banking connector, categorization, GUI management, and plotting for easy maintenance and testing.",
    "- **Persistent Settings**: JSON files (`categories.json`, `category_order.json`, `category_colors.json`) preserve your customizations across sessions.",
    "- **Interactive Experience**: CLI TAN prompts, Tkinter UI, and Plotly tooltips give you control while automating the heavy lifting.",
    "",
    "### Getting Started",
    "1. Clone the repo and install dependencies: `git clone https://github.com/fynndohmen/expense-tracker.git && cd expense-tracker && pip install fints-client plotly pandas python-dotenv tkinter`",
    "2. Configure your `.env` with your FinTS credentials (BLZ, user ID, PIN, etc.).",
    "3. Run `python main.py` to sync, categorize, and visualize your expenses in real time!",
    "",
    "Experience instant insights into your spending right from your bank account with this Python-based, FinTS-powered expense tracker."
  ],
  "date": "2025-08-03"
},
    {
  "title": "Building a Flappy Bird–Style Game in Python with Pygame",
  "content": [
    "This project is a small Flappy Bird–style game built with Python and Pygame. It focuses on a clean game loop, simple state management (start vs. play), a parallax-scrolling background, and physics-based bird movement with procedural pipes.",
    "The game is intentionally compact but structured like a real project, making it a good reference for learning how to build 2D games with Pygame from scratch."
  ],
  "images": ["python_projects_pics/flappyclone.gif"],
  "description": [
    "### Goal & Overview",
    "- Create a minimal but polished arcade game inspired by Flappy Bird.",
    "- Use it as a playground to learn:",
    "  - How the main loop in a game works",
    "  - How to structure states (start screen vs. gameplay)",
    "  - How to work with sprites, physics and collision in Pygame",
    "  - How to layer backgrounds for a parallax effect",
    "",
    "---",
    "### Core Architecture",
    "- **Language & Library**: Python + Pygame.",
    "- **Window & Loop**:",
    "  - A single window (`WIDTH × HEIGHT`) created via `pygame.display.set_mode`.",
    "  - One main `while running:` loop that:",
    "    - Processes all events (quit, mouse, keyboard)",
    "    - Updates game objects depending on the current state",
    "    - Draws the scene and finally calls `pygame.display.flip()`.",
    "- **Game States**:",
    "  - `start` – shows a static start screen with a background and a \"Start Game\" button.",
    "  - `play` – runs the actual gameplay with parallax background, bird, and pipes.",
    "",
    "---",
    "### Start Screen",
    "- The start screen is intentionally simple:",
    "  - A background image stretched or scaled to fill the window.",
    "  - A centered \"Start Game\" button built from:",
    "    - A text surface rendered with `pygame.font.SysFont`",
    "    - A slightly larger `Rect` drawn as a black rounded rectangle behind the text.",
    "- Input handling:",
    "  - Mouse events are checked inside the event loop.",
    "  - A left-click (`MOUSEBUTTONDOWN` with `button == 1`) inside the button rect switches `state` from `\"start\"` to `\"play\"`.",
    "",
    "---",
    "### Parallax Background",
    "- The game uses **multiple background layers** to create depth:",
    "  - Each layer has:",
    "    - A texture (image) scaled to match the window height",
    "    - Its own horizontal offset `x`",
    "    - A scroll speed (`speed`) – distant layers move slowly, foreground layers faster.",
    "- Implementation details:",
    "  - Each frame, `x` is decreased by `speed` so the layer appears to move left.",
    "  - Once `x` is smaller than `-width`, it is reset to `0`.",
    "  - To avoid gaps, every layer is drawn **twice**:",
    "    - at `(x, 0)` and `(x + width, 0)`",
    "  - The screen is filled with a solid background color first, then the parallax layers are blitted back-to-front.",
    "",
    "---",
    "### Bird Sprite & Physics",
    "- The bird is implemented as a `pygame.sprite.Sprite` subclass:",
    "  ```python",
    "  class Bird(pygame.sprite.Sprite):",
    "      def __init__(self, x, y):",
    "          super().__init__()",
    "          self.image = ...  # bird.png, scaled down",
    "          self.rect = self.image.get_rect(center=(x, y))",
    "          self.vel_y = 0",
    "          self.gravity = 0.5",
    "          self.jump_strength = -10",
    "  ```",
    "- **Movement model**:",
    "  - Each frame in `update()`:",
    "    - `vel_y` is increased by `gravity` (simulating acceleration downwards).",
    "    - `rect.y` is increased by `vel_y` (position follows the velocity).",
    "  - Pressing **Space** calls `bird.jump()`, which sets `vel_y` to a negative value (`jump_strength`), making the bird move upward for a moment before gravity pulls it down again.",
    "- **Screen bounds**:",
    "  - If the bird falls below the bottom or flies above the top of the window, its rect is clamped and `vel_y` reset to `0`. This prevents it from permanently disappearing off-screen.",
    "",
    "---",
    "### Pipes & Procedural Generation",
    "- Pipes are also implemented as sprites:",
    "  - A single `pipe.png` texture is used for both top and bottom pipes.",
    "  - The top pipe image is vertically flipped with `pygame.transform.flip(image, False, True)`. ",
    "  - `Pipe` objects store a rect and a constant horizontal speed (`PIPE_SPEED`).",
    "- Spawning logic:",
    "  - A shared timer (`last_pipe_spawn_time`) and interval (`PIPE_SPAWN_INTERVAL` in ms) control when new pipe pairs appear.",
    "  - On each frame in the `play` state:",
    "    - The code checks `current_time - last_pipe_spawn_time`.",
    "    - If it exceeds the interval, a new **pipe pair** is spawned to the right of the screen.",
    "  - A random `gap_y` is chosen within safe vertical limits so the gap between top and bottom pipes always stays fully visible.",
    "  - Bottom pipe is positioned with `midtop=(spawn_x, gap_y + PIPE_GAP/2)`,",
    "    top pipe with `midbottom=(spawn_x, gap_y - PIPE_GAP/2)`.",
    "- Movement & cleanup:",
    "  - Each `Pipe.update()` moves `rect.x` to the left.",
    "  - If `rect.right < 0`, the pipe deletes itself using `self.kill()` so the sprite group does not grow unbounded.",
    "",
    "---",
    "### Collision & Reset Behavior",
    "- Collision detection uses simple **rectangle intersection**:",
    "  - For every pipe in `pipe_group`, the game checks `bird.rect.colliderect(pipe.rect)`. ",
    "  - On the first collision, the game does not quit; it **resets back to the start state**:",
    "    - `state` is set to `\"start\"`.",
    "    - All existing pipes are removed with `pipe_group.empty()`.",
    "    - The bird is repositioned to the starting location with vertical velocity zeroed.",
    "    - Parallax layer offsets are reset to `0`.",
    "    - The pipe spawn timer is reset so the next run starts cleanly.",
    "- This gives the game a simple loop:",
    "  1. Start screen → click **Start Game**.",
    "  2. Fly as far as you can without touching a pipe.",
    "  3. On collision → instantly back to the start screen, ready for another attempt.",
    "",
    "---",
    "### State Management & Event Handling",
    "- A single variable `state` controls what the main loop does:",
    "  - `\"start\"` → draw start background + button, listen for mouse click on the button.",
    "  - `\"play\"` → update physics, pipes, parallax, and handle keyboard input (spacebar).",
    "- Events are processed centrally:",
    "  - `QUIT` events always end the game (`running = False`).",
    "  - Mouse clicks are only interpreted as button presses in `start`.",
    "  - `KEYDOWN` events for space are only processed when `state == \"play\"`.",
    "- This keeps the control flow explicit and avoids multiple nested loops for different screens.",
    "",
    "---",
    "### Complexity & Performance Notes",
    "- The game runs at a fixed target framerate (e.g., 60 FPS) using `clock.tick(60)`. ",
    "- Parallax rendering and pipe updates are linear in the number of layers and active pipes:",
    "  - Typically only a handful of pipe pairs are on-screen at once, so performance is easily real-time.",
    "- Asset scaling happens **once at startup** (bird, pipes, layers), not every frame, minimizing CPU overhead.",
    "",
    "---",
    "### Learning Takeaways",
    "- How to structure a small Pygame project with:",
    "  - A single main loop and explicit game states",
    "  - Sprite classes (`Bird`, `Pipe`) that encapsulate their own `update()` logic",
    "  - Procedural obstacle generation using timers and randomness",
    "  - Parallax background rendering with looping textures",
    "- The code base is intentionally compact and readable, making it a good starting point for experimenting with:",
    "  - Scoring systems",
    "  - Game-over screens",
    "  - Sound effects",
    "  - Difficulty scaling and polish."
  ],
  "date": "2025-12-01"
}




]



