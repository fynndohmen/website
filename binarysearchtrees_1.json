[
  {
  "title": "Binary Search Trees – Fundamentals, Use Cases, Pros and Cons",
  "content": [
    "A Binary Search Tree (BST) is a binary tree that keeps its elements in sorted order, enabling efficient searches, insertions and deletions.",
    "This post explains what BSTs are, when to use them, their advantages and disadvantages, and the time and space complexity of key operations."
  ],
  "images": [],
  "description": [
    "## What is a Binary Search Tree?",
    "A Binary Search Tree (BST) is a binary tree where each node stores a key and satisfies the **BST property**: all keys in the left subtree are strictly smaller than the node's key, and all keys in the right subtree are strictly larger. This ordering allows efficient search operations by repeatedly deciding whether to go left or right.",
    "Figure: BST ordering rule (your diagram uses a common duplicate convention: left < node <= right).",
    { "type": "image", "src": "algorithms_pics/BSTProperties.png", "alt": "BST properties: left < node <= right" },
    "",
    "In many discussions, BSTs are assumed to be **balanced** (for example AVL trees or Red-Black trees), meaning the height of the tree is O(log n). A plain, unbalanced BST can degrade to a skewed, almost linear structure with height O(n) in the worst case, which directly affects performance.",
    "",
    "## Typical use cases",
    "- Storing a dynamic set of values that must remain **sorted**.",
    "- Implementing ordered collections like **sets** and **maps** with efficient insert/delete/search.",
    "- Quickly finding the **minimum, maximum, predecessor, successor** of elements.",
    "- Implementing operations like \"find the smallest element greater than x\" or \"iterate all keys in sorted order\".",
    "- Situations where you need **ordered iteration** and not just membership tests (where you might choose a hash table instead).",
    "",
    "## Advantages of Binary Search Trees",
    "- **Efficient search, insert and delete** (balanced BST): O(log n) time on average.",
    "- **Sorted order is built in:** inorder traversal visits keys from smallest to largest.",
    "- Supports powerful operations such as finding **min/max**, **predecessor/successor**, and range queries (e.g. \"all keys between a and b\").",
    "- Easy to traverse in different orders (inorder, preorder, postorder) for various algorithmic needs.",
    "",
    "## Disadvantages of Binary Search Trees",
    "- **Unbalanced BSTs can be slow:** in the worst case (already sorted inserts) the height becomes O(n), and search/insert/delete degrade to O(n).",
    "- Implementation of **balanced** BSTs (AVL, Red-Black, etc.) is more complex than arrays or linked lists.",
    "- Pointer-heavy structure: usually more memory overhead than arrays or compact hash tables.",
    "- Poorer cache locality than arrays, because nodes are often scattered in memory.",
    "",
    "## Comparison to arrays, linked lists and hash tables",
    "- **Arrays:** arrays offer O(1) random access by index but O(n) insert/delete in the middle; BSTs offer O(log n) search/insert/delete by key but do not support O(1) random access.",
    "- **Linked lists:** linked lists are good at insert/delete when you already have a pointer to a node, but searching is O(n); BSTs give you O(log n) search, insert and delete (when balanced) and maintain sorted order.",
    "- **Hash tables:** hash tables provide average O(1) search/insert/delete but do not maintain keys in sorted order; BSTs are slower per operation (O(log n)) but preserve ordering and support operations like predecessor/successor and sorted iteration.",
    "",
    "## Key operations and complexities (n = number of nodes)",
    "Let h be the height of the tree.",
    "- In a **balanced BST**, h = O(log n).",
    "- In the **worst case** (unbalanced), h = O(n).",
    "",
    "Cheat sheet: common BST operations (balanced vs worst-case) and extra space.",
    { "type": "image", "src": "algorithms_pics/bst_cheatsheet.png", "alt": "BST complexity cheat sheet" },
    "",
    "- **search(key)** – O(h) time, typically O(log n) for balanced trees and O(n) in the worst case; extra space O(1) for an iterative implementation or O(h) for a recursive one.",
    "- **insert(key)** – O(h) time: find the correct position with a search, then attach a new node. For balanced trees this is O(log n), worst case O(n); extra space O(1) per insert (plus O(1) for rotations in self-balancing trees).",
    "- **delete(key)** – O(h) time: locate the node, restructure the tree if needed (for example replacing with inorder successor), and possibly rebalance; extra space O(1) iterative or O(h) recursive.",
    "- **findMin() / findMax()** – O(h) time: follow left pointers down to the minimum, right pointers to the maximum; O(1) extra space if implemented iteratively.",
    "- **successor(key) / predecessor(key)** – O(h) time: typically follow parent pointers or walk down from the root again; extra space O(1) iterative or O(h) recursive.",
    "- **inorder / preorder / postorder traversal** – O(n) time to visit every node once; extra space O(h) due to recursion or O(h) for an explicit stack in an iterative version.",
    "",
    "## Summary",
    "Binary Search Trees provide a powerful way to maintain a dynamic, sorted set of keys with reasonably efficient operations. When balanced, they support search, insert and delete in O(log n) time and enable operations that arrays, linked lists and hash tables cannot provide as naturally, such as efficient predecessor/successor queries and ordered iteration. However, they require careful implementation to avoid becoming unbalanced and typically use more memory and have poorer cache locality than array-based structures."
  ],
  "date": "2025-12-10",
  "pinned": true
}

,
{
    "title": "Finding the Closest Value in a Binary Search Tree (BST)",
    "content": [
        "This Python function efficiently finds the value in a Binary Search Tree (BST) that is closest to a given target value."
    ],
    "images": ["algorithms_pics/find_closest_bst.png"],
    "description": [
        "### Key Features of the Closest Value in BST Function:",
        "1. **Binary Search Tree Properties:**",
        "   - Each node in a BST has a value and two child nodes: `left` and `right`.",
        "   - The left child node contains values smaller than the parent node.",
        "   - The right child node contains values greater than the parent node.",
        "",
        "2. **Logic for Finding the Closest Value:**",
        "   - The function starts at the root node and initializes the `closest` variable to infinity.",
        "   - It traverses the tree while updating the closest value if the current node's value is nearer to the target.",
        "   - Depending on whether the target is smaller or larger than the current node's value, it moves to the left or right subtree, respectively.",
        "",
        "3. **Output:**",
        "   - Returns the value in the BST that is closest to the target.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- In the average and best cases (balanced BST), the time complexity is **O(log n)**, as each step reduces the search space by half.",
        "- In the worst case (unbalanced BST, resembling a linked list), the time complexity is **O(n)** because the function may traverse the entire tree.",
        "",
        "**Space Complexity:**",
        "- The space complexity for this iterative solution is **O(1)** because only a few variables (e.g., `closest`, `currentNode`) are used.",
        "- In a recursive approach, the space complexity would be **O(h)**, where `h` is the height of the tree (up to **O(n)** in the worst case)."
    ],
    "date": "2024-12-13"
},
    {
"title": "Binary Search Tree in Python: Insert, Search, and Delete (Iterative with Successor Trick)",
"content": [
"This class implements a classic **Binary Search Tree (BST)** with iterative `insert`, `contains`, and `remove` operations plus a helper `getMinValue`. Deletion uses the in-order **successor** (leftmost node in the right subtree) to handle nodes with two children."
],
 "images": [
    "algorithms_pics/bst_construction1.png",
    "algorithms_pics/bst_construction2.png"
  ],
"description": [
"### What the Code Provides",
"- **Node structure:** each node stores `value`, `left`, and `right`.",
"- **Insert (iterative):** walks down from the root; values `< current` go left, otherwise right. Ties go to the **right**.",
"- **Contains (iterative):** standard BST lookup by branching left/right until found or `None`.",
"- **getMinValue:** follows `.left` pointers until the leftmost node and returns its value.",
"",
"---",
"### Remove: All Cases Covered",
"The method searches for the target while tracking `parentNode`.",
"1) **Two children:** replace the node’s value with the **in-order successor** (minimum in right subtree via `getMinValue()`), then delete that successor from the right subtree (`currentNode.right.remove(...)`). The successor cannot have a left child, so its own removal is simple.",
"2) **Deleting the root (no parent):** mutate the root **in place**:\n   - If only a left child exists, copy the left child’s value into root and rewire children (`right = left.right`, `left = left.left`).\n   - If only a right child exists, copy its value and rewire similarly.\n   - If the root is a **single leaf**, the code sets `currentNode.value = None` to represent an empty tree sentinel.",
"3) **One child (non-root):** link the parent directly to the existing child (left or right).",
"",
"---",
"### Why the Successor Approach Works",
"- Replacing a node with the smallest value in its right subtree preserves the BST ordering: all left values remain `< newValue` and all right values remain `≥ newValue`.",
"- The successor has no left child, making its own removal straightforward.",
"",
"---",
"### Complexity",
"- Let **h** be the tree height.\n  - **Insert / Contains / Remove:** average **O(h)** (→ **O(log n)** if balanced; **O(n)** in the worst case when skewed).\n  - **Space:** iterative traversal keeps auxiliary space **O(1)**. The code makes **one nested call** to `remove` when deleting the successor, which doesn’t grow with `n` beyond constant call depth.",
"",
"---",
"### Edge Notes",
"- **Duplicates:** `insert` routes equals to the **right**; `contains` will find them; `remove` will delete the first matching node encountered along the search path.",
"- **Emptying the tree:** when the root is a lone leaf, the node’s `value` is set to `None`.",
"",
"---",
"### Takeaways",
"- Iterative operations keep memory usage minimal.",
"- Using the in-order successor allows clean deletion for the two-children case without full subtree surgery.",
"- Performance depends on height—balance the tree (e.g., AVL/Red-Black) if you need guaranteed `O(log n)`."
],
"date": "2025-03-16"
},

    {
  "title": "Validating a Binary Search Tree (BST) in Python",
  "content": [
    "This Python function checks whether a given binary tree satisfies the properties of a Binary Search Tree (BST)."
  ],
  "images": [
    "algorithms_pics/bst_validation.png"
  ],
  "description": [
    "### How the Function Works:",
    "1. **What Makes a Tree a Valid BST?**",
    "- In a valid BST, every node must satisfy two conditions:",
    "  - All values in the left subtree are strictly less than the node’s value.",
    "  - All values in the right subtree are greater than or equal to the node’s value.",
    "- These rules must hold recursively for every node in the tree.",
    
    "2. **Recursive Validation with Min/Max Constraints:**",
    "- A helper function `validateBstHelper()` is used to traverse the tree recursively.",
    "- It ensures that each node’s value lies within a valid range defined by `minValue` and `maxValue`.",
    "- The left child is checked with an updated upper bound, and the right child with an updated lower bound.",
    
    "3. **Why This Approach is Reliable:**",
    "- Unlike an in-order traversal check, this method directly validates BST rules at each node.",
    "- It immediately detects violations deep in the tree structure, even if the overall order appears correct.",
    
    "### Complexity Analysis:",
    "**Time Complexity:** O(n) — Each node is visited once.",
    "**Space Complexity:**",
    "- O(log n) for a balanced tree due to recursion depth.",
    "- O(n) in the worst case (e.g., a skewed tree)."
  ],
  "date": "2025-03-17"
},
    {
  "title": "BST Traversals in Python: In-Order, Pre-Order, and Post-Order",
  "content": [
    "This Python code demonstrates the three fundamental depth-first traversal methods for Binary Search Trees (BSTs): in-order, pre-order, and post-order."
  ],
  "images": [
    "algorithms_pics/bst_traversal.png"
  ],
  "description": [
    "### In-Order Traversal (`inOrderTraverse`):",
    "- Traverses the left subtree, visits the current node, then traverses the right subtree.",
    "- For Binary Search Trees (BSTs), this traversal returns the node values in sorted order.",
    "- Useful when you need to extract values from a BST in ascending order.",

    "### Pre-Order Traversal (`preOrderTraverse`):",
    "- Visits the current node first, then traverses the left and right subtrees.",
    "- This is useful for tasks like copying a Binary Search Tree (BST) or serializing it.",
    "- Follows the pattern: **Root → Left → Right**.",

    "### Post-Order Traversal (`postOrderTraverse`):",
    "- Traverses the left and right subtrees first, then visits the current node.",
    "- Often used for deleting or freeing nodes in a Binary Search Tree (BST), or for evaluating expression trees.",
    "- Follows the pattern: **Left → Right → Root**.",

    "Each function accepts a BST and an array, recursively fills the array with node values in the correct order, and returns it.",

    "### Complexity Analysis:",
    "**Time Complexity:** O(n) — Each node in the BST is visited exactly once.",

    "**Space Complexity:**",
    "- O(n) for the array containing all node values.",
    "- O(h) auxiliary space for the recursion stack, where h is the height of the BST (O(log n) for balanced BSTs, O(n) for unbalanced ones)."
  ],
  "date": "2025-03-18"
},
{
  "title": "Creating a Minimal Height BST from a Sorted Array",
  "content": [
    "This Python function constructs a Binary Search Tree (BST) with minimal height from a sorted array. This technique ensures the tree is as balanced as possible, optimizing search efficiency."
  ],
  "images": [
    "algorithms_pics/min_height_bst.png"
  ],
  "description": [
    "### Core Idea Behind Minimal Height BST Construction:",
    "1. **Balanced BST Structure**",
    "- A BST with minimal height ensures that operations like search, insert, and delete can be performed efficiently.",
    "- By choosing the middle element of the array as the root and recursively applying the same logic to the subarrays, the BST remains balanced.",

    "2. **Recursive Construction Approach**",
    "- The function `constructMinHeightBst()` is used to build the tree recursively.",
    "- At each recursive step, it picks the middle element of the current subarray and inserts it into the BST.",
    "- This ensures a roughly balanced distribution of nodes across the left and right subtrees.",

    "3. **Tree Construction Process**",
    "- Start with the full sorted array and determine the middle index.",
    "- Insert the middle value into the BST using the `insert()` method.",
    "- Recursively construct the left and right subtrees using the left and right halves of the array.",
    "- The recursion stops when the subarray is exhausted.",

    "### Complexity Analysis:",
    "**Time Complexity:** O(n log n) — The function inserts `n` elements into the BST, and each insertion takes O(log n) time on average.",
    "**Space Complexity:** O(n) — Due to the recursive call stack and the storage of all `n` nodes in the BST."
  ],
  "date": "2025-06-17"
},
{
  "title": "Efficiently Building a Minimal Height BST from a Sorted Array (O(n) Time)",
  "content": [
    "This implementation constructs a Binary Search Tree (BST) with minimal height directly from a sorted array — in linear time, O(n), by avoiding the use of repeated insertions."
  ],
  "images": [
    "algorithms_pics/min_height_bst_optimized.png"
  ],
  "description": [
    "### Overview:",
    "This solution efficiently builds a minimal height Binary Search Tree (BST) from a sorted array by directly linking child nodes rather than inserting values one by one.",
    
    "### How It Works:",
    "1. The array is sorted, so the middle element at each step is chosen as the root of the current (sub)tree.",
    "2. The left and right halves of the array are then recursively used to build the left and right subtrees.",
    "3. Instead of inserting each value with the `.insert()` method, which traverses the tree and takes O(log n) time per insertion, the tree nodes are connected directly during recursion.",
    
    "### Key Advantages over Traditional Insert-Based Construction:",
    "**Insert-Based Approach:**",
    "- Uses `bst.insert(value)` repeatedly during recursion.",
    "- Each insertion takes O(log n) time (on average).",
    "- Total Time Complexity: **O(n log n)** for `n` insertions.",
    
    "**Direct Linkage Approach (this implementation):**",
    "- Avoids insertion logic by manually setting `.left` and `.right` pointers during recursion.",
    "- Each node is visited exactly once, and no tree traversal is needed.",
    "- Total Time Complexity: **O(n)**.",
    
    "### Complexity Analysis:",
    "**Time Complexity:** O(n) — Every node is created once, and linking is done in constant time per node.",
    "**Space Complexity:** O(n) — Due to the recursion stack and storage of all nodes in the BST.",
    
    "### Use Case:",
    "This approach is ideal when building a BST from a static, sorted dataset where balance and performance are key, such as for search-heavy applications or as a preprocessing step for efficient lookups."
  ],
  "date": "2025-06-18"
},
{
  "title": "Finding the K-th Largest Value in a BST (Binary Search Tree)",
  "content": [
    "This Python algorithm efficiently retrieves the k-th largest value in a Binary Search Tree (BST) using a reverse in-order traversal."
  ],
  "images": [
    "algorithms_pics/kth_largest_bst.png"
  ],
  "description": [
    "### Why Reverse In-Order Traversal?",
    "- A standard in-order traversal of a BST visits nodes in **ascending order**.",
    "- A **reverse in-order traversal** (Right → Node → Left) visits nodes in **descending order**.",
    "- This makes it ideal for finding the k-th largest element, as the traversal directly yields the largest values first.",

    "### How the Algorithm Works:",
    "1. **TreeInfo Class**",
    "- Holds two pieces of information during traversal:",
    "  - `numberOfNodesVisited`: Counts how many nodes have been visited.",
    "  - `latestVisitedNodeValue`: Stores the current candidate for the k-th largest value.",

    "2. **Reverse Traversal with Early Stopping**",
    "- The function recursively visits the right subtree first (largest values).",
    "- After each node visit, it increments the counter and updates the latest visited value.",
    "- Once `k` nodes have been visited, the traversal stops early for efficiency.",

    "3. **Function Entry Point**",
    "- The public function `findKthLargestValueInBst()` sets up the tracking object and initiates the traversal.",
    "- It returns the k-th largest node's value as stored in `latestVisitedNodeValue`.",

    "### Complexity Analysis:",
    "**Time Complexity:** O(h + k) — Where `h` is the height of the tree. In the worst case (unbalanced BST), this could be up to O(n), but for a balanced tree, it's roughly O(log n + k).",
    "**Space Complexity:** O(h) — Due to recursion stack from tree traversal."
  ],
  "date": "2025-06-19"
},
{
  "title": "Reconstructing a BST from Preorder Traversal",
  "content": [
    "This Python algorithm reconstructs a Binary Search Tree (BST) from its preorder traversal using recursion and value bounds."
  ],
  "images": [
    "algorithms_pics/bst_reconstruction.png", "algorithms_pics/bst_reconstruction2.png"
  ],
  "description": [
    "### Why Preorder Traversal Reconstruction?",
    "- A preorder traversal of a BST lists nodes in the order: **Root → Left → Right**.",
    "- Given only this list, it’s possible to reconstruct the original BST if the BST property is preserved (left < root < right).",

    "### How the Algorithm Works:",
    "1. **Tracking Index with `TreeInfo`**",
    "- A helper class `TreeInfo` holds the current index (`rootIdx`) in the preorder list.",
    "- This ensures that each recursive call knows which value to consider as the root of the current subtree.",

    "2. **Bounded Recursion**",
    "- The core idea is to use a range (`lowerBound`, `upperBound`) to determine whether a value fits in the current subtree.",
    "- If a value is out of range, it does not belong in that subtree, and recursion returns `None`.",
    "- The root value splits the range for left and right subtrees recursively.",

    "3. **Building the Tree**",
    "- Starting from index 0, the function builds the tree top-down:",
    "  - The first value is used as the root.",
    "  - It recursively builds the left subtree using values less than the root.",
    "  - Then it builds the right subtree using values greater than or equal to the root.",

    "### Complexity Analysis:",
    "**Time Complexity:** O(n) — Each node is processed once in a single pass.",
    
    "**Space Complexity:**",
    "- O(n) total space:",
    "  - O(h) auxiliary space for the recursion stack, where `h` is the height of the BST (O(log n) for balanced trees, O(n) in the worst case).",
    "  - O(n) for the space required to actually store the reconstructed BST with `n` nodes."
  ],
  "date": "2025-06-20"
}


]
