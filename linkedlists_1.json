[
    {
  "title": "Linked Lists – Fundamentals, Use Cases, Pros and Cons",
  "content": [
    "A linked list is a linear data structure made of nodes, where each node stores a value and a reference to the next node.",
    "This post explains what linked lists are, when to use them, how they compare to arrays, and the time and space complexity of key operations."
  ],
  "images": [],
  "description": [
    "## What is a linked list?",
    "A linked list is a sequence of nodes, where each node holds a value and a reference (pointer) to the next node in the sequence. The structure is accessed via a head pointer that points to the first node; the last node points to null.",
    "Figure: A linked list is accessed via a head pointer; nodes link to the next node and the last node points to null.",
    { "type": "image", "src": "algorithms_pics/whats_a_linked_list.png", "alt": "What is a linked list? head -> A -> B -> C -> null" },
    "",
    "The most common variant is the **singly linked list** (each node has a `next` pointer). There is also the **doubly linked list**, where each node has both `next` and `prev` pointers, making certain operations (like deletion at the end) simpler at the cost of extra memory.",
    "Figure: Singly vs doubly linked list (next vs next+prev pointers).",
    { "type": "image", "src": "algorithms_pics/singly_vs_doubly.png", "alt": "Singly vs doubly linked list" },
    "",
    "Unlike arrays, linked lists do **not** store elements contiguously in memory and do **not** support O(1) random access by index. Instead, you traverse the list node by node.",
    "",
    "## Typical use cases",
    "- When you need **frequent insertions and deletions** at the beginning of a sequence.",
    "- When you perform many insert/delete operations **in the middle** of a sequence and already have references to the affected nodes.",
    "- Implementing simple **stacks** and **queues**, especially in educational contexts.",
    "- When the total number of elements is not known in advance and you want a structure that can grow without resizing or relocating a large contiguous block.",
    "- As a building block in more complex data structures (for example adjacency lists in graphs, hash table buckets, free lists in memory allocators).",
    "",
    "## Advantages of linked lists",
    "- **O(1) insertion and deletion at the head**: adding or removing the first node is constant time.",
    "- **O(1) insertion and deletion given a node reference**: if you already have a pointer to the node before the insertion/deletion point, you can update links in constant time.",
    "- **Dynamic size**: the list grows and shrinks as needed without preallocating a large block of memory and without costly resizes.",
    "- Can be easier to rearrange nodes (for example splicing sublists, merging lists) because you only change pointers instead of moving elements in memory.",
    "",
    "Figure: push_front(X) is O(1) because only a constant number of pointers change (X.next = head, then head = X).",
    { "type": "image", "src": "algorithms_pics/push_front.png", "alt": "push_front(X): X.next = head; head = X" },
    "",
    "Figure: pop_front() is O(1) because head moves to head.next (old head becomes unreachable/removed).",
    { "type": "image", "src": "algorithms_pics/pop_front.png", "alt": "pop_front(): head = head.next" },
    "",
    "## Disadvantages of linked lists",
    "- **No random access**: to get the i-th element you must traverse from the head through i nodes, which is O(n) time.",
    "- **Linear-time search**: finding a value requires a full or partial traversal (O(n)), unlike balanced trees or hash tables.",
    "- **Memory overhead**: each node stores at least one pointer (two in a doubly linked list), which increases memory usage compared to arrays.",
    "- **Poor cache locality**: nodes are often scattered in memory, and pointer chasing is slower than accessing a contiguous array.",
    "- More complex to implement correctly (handling edge cases like empty list, single element, insert/delete at head or tail).",
    "",
    "## Comparison with arrays",
    "- **Index access:** arrays support O(1) access by index; linked lists require O(n) time to reach element i.",
    "- **Insert/delete in the middle:** arrays require shifting elements (O(n) time); linked lists can insert/delete in O(1) time if you already have a pointer to the preceding node.",
    "- **Memory layout:** arrays store elements in one contiguous block (good for cache); linked lists store nodes scattered across memory, which is slower in practice.",
    "- **Resizing:** dynamic arrays occasionally perform an O(n) resize when growing; linked lists never need to move existing elements, they just allocate or free nodes as needed.",
    "",
    "Figure: Arrays have O(1) random access and contiguous memory; linked lists require pointer chasing for random access (O(n)).",
    { "type": "image", "src": "algorithms_pics/array_vs_linkedlist.png", "alt": "Array vs linked list: random access and memory layout" },
    "",
    "In practice, arrays (or dynamic arrays) are often the default choice for sequences. Linked lists become attractive in situations where pointer-based insert/delete operations dominate and random access is less important.",
    "",
    "## Key operations and complexities (n = number of nodes)",
    "Assume a singly linked list with a head pointer, and optionally a tail pointer if mentioned.",
    "",
    "- **initialize()** – create an empty list: O(1) time / O(1) extra space.",
    "- **size() / isEmpty()** – O(1) time / O(1) extra space if you maintain a length counter; otherwise, computing size by traversal is O(n) time.",
    "- **access(i)** – O(n) time / O(1) extra space: you must follow the links from the head to the i-th node.",
    "- **search(value)** – O(n) time / O(1) extra space: linear scan through the list.",
    "- **insert at beginning (push_front)** – O(1) time / O(1) extra space: create a new node, point its next to the old head, update head.",
    "- **delete at beginning (pop_front)** – O(1) time / O(1) extra space: update head to head.next and free the old head.",
    "- **insert at end** – O(1) time if you maintain a tail pointer; O(n) if you must traverse from head to the last node; extra space O(1).",
    "- **delete at end** – O(n) time in a singly linked list without a prev pointer (you must find the node before the tail); in a doubly linked list with a tail pointer it can be O(1); extra space O(1).",
    "- **insert after a given node** – O(1) time / O(1) extra space: adjust pointers around the given node.",
    "- **delete after a given node** – O(1) time / O(1) extra space: bypass the node to be removed and free it.",
    "- **traverse / iterate all elements** – O(n) time / O(1) extra space when done iteratively.",
    "",
    "Cheat sheet (summary table of common operations):",
    { "type": "image", "src": "algorithms_pics/linkedlist_complexity_cheatsheet.png", "alt": "Linked list operations complexity cheat sheet" },
    "",
    "## Summary",
    "Linked lists trade away fast random access for flexibility in insertions and deletions. They shine when you frequently add or remove elements at known positions (especially at the beginning of the structure) and when you want a dynamically sized sequence without costly resizes. However, for workloads dominated by random reads and searches, or where memory locality is important, arrays or other data structures are usually a better fit."
  ],
  "date": "2025-12-10",
  "pinned": true
}

,

{
    "title": "Removing Duplicates from a Linked List in Python",
    "content": [
        "This Python script efficiently removes duplicate values from a sorted linked list."
    ],
    "images": [
        "algorithms_pics/remove_duplicates_linkedlist.png"
    ],
    "description": [
        "### Key Features of the Script:",
        "1. **Input Structure:**",
        "   - A `LinkedList` class is used to represent nodes in the linked list. Each node contains a `value` and a `next` pointer to the subsequent node.",
        "",
        "2. **Logic for Removing Duplicates:**",
        "   - The script iterates through the linked list, comparing the value of the current node with the next node.",
        "   - If duplicate nodes are found, the `next` pointer of the current node is updated to skip the duplicate nodes and point to the next distinct node.",
        "",
        "3. **Output:**",
        "   - The function returns the modified linked list with duplicates removed, preserving the sorted order.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- Each node in the linked list is visited once, and duplicate nodes are skipped efficiently.",
        "- Since we traverse the list only once, the total time complexity is **O(n)**, where `n` is the number of nodes in the linked list.",
        "",
        "**Space Complexity:**",
        "- The function modifies the linked list in-place without using any additional data structures.",
        "- Only a few pointers (`current`, `next_distinct`) are used, resulting in a constant space complexity of **O(1)**.",
        "- Therefore, the overall space complexity is **O(1)**."
    ],
    "date": "2025-01-06"
}
,
{
    "title": "Finding the Middle Node in a Linked List",
    "content": [
        "This Python script demonstrates how to efficiently find the middle node of a singly linked list using the two-pointer technique."
    ],
    "images": [
        "algorithms_pics/middle_node.png"
    ],
    "description": [
        "### Key Features of the Script:",
        "1. **Input Handling:**",
        "   - Accepts a singly linked list as input, represented by nodes connected via the `next` pointer.",
        "",
        "2. **Two-Pointer Technique:**",
        "   - Two pointers (`slow_pointer` and `fast_pointer`) are initialized at the head of the linked list.",
        "   - The `fast_pointer` moves two steps at a time, while the `slow_pointer` moves one step at a time.",
        "   - When the `fast_pointer` reaches the end of the list, the `slow_pointer` will be at the middle node.",
        "",
        "3. **Output:**",
        "   - Returns the middle node of the linked list. If the list has an even number of nodes, the second middle node is returned.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- The function iterates through the linked list using the `fast_pointer`, which moves twice as fast as `slow_pointer`.",
        "- Since each node is visited at most once, the overall time complexity is **O(n)**, where `n` is the number of nodes in the list.",
        "",
        "**Space Complexity:**",
        "- The function modifies no additional data structures and only uses two pointer variables (`slow_pointer` and `fast_pointer`).",
        "- Therefore, the overall space complexity is **O(1)**, as the function runs in constant space."
    ],
    "date": "2025-01-07"
},
    {
"title": "Doubly Linked List in Python: O(1) Inserts, Moves, and Deletes",
"content": [
"This implementation provides a classic doubly linked list with constant-time node moves and updates. It supports setting head/tail, inserting before/after any node, inserting at a position, removing nodes (by reference or by value), and linear search."
],
"images": ["algorithms_pics/doubly_linked_list1.png", "algorithms_pics/doubly_linked_list2.png"],
"description": [
"### What Is a Doubly Linked List?",
"- A sequence of nodes where each node has pointers to both its previous and next neighbor (prev, next).",
"- Unlike arrays, linked lists allow O(1) splices when you already hold a reference to the node you want to move or delete.",
"",
"---",
"### Data Structures:",
"- Node(value): holds value, prev, next.",
"- DoublyLinkedList: tracks head and tail and exposes list operations.",
"",
"---",
"### Core Operations & Why They’re Efficient:",
"- setHead(node) — O(1):",
" - Empty list → head = tail = node.",
" - Otherwise delegates to insertBefore(self.head, node) to make node the new head.",
"",
"- setTail(node) — O(1):",
" - Empty list → just setHead(node).",
" - Otherwise insertAfter(self.tail, node).",
"",
"- insertBefore(node, nodeToInsert) — O(1):",
" - If nodeToInsert is already in the list, first detach it via remove(nodeToInsert) to avoid duplicate links.",
" - Splice nodeToInsert right before node; update head if needed.",
"",
"- insertAfter(node, nodeToInsert) — O(1):",
" - Same detach-then-splice pattern; updates tail if we insert after the last node.",
"",
"- insertAtPosition(position, nodeToInsert) — O(p):",
" - Walks from head to the given 1-based position (p steps).",
" - If position exceeds length, node becomes the new tail.",
"",
"- removeNodesWithValue(value) — O(n):",
" - Single pass, keeps nodeToRemove before advancing the cursor to avoid losing the next pointer during detach.",
"",
"- remove(node) — O(1):",
" - Updates head/tail if needed, then clears the node’s bindings with removeNodeBindings.",
"",
"- containsNodeWithValue(value) — O(n):",
" - Linear scan from head.",
"",
"---",
"### Safety & Invariants:",
"- Detach before re-insert: insertBefore/After call remove(nodeToInsert) first. This guarantees a node can be moved anywhere in O(1) without creating cycles or duplicates.",
"- Head/Tail maintenance: remove and the insert helpers correctly update head/tail when the endpoints move.",
"- removeNodeBindings(node) centralizes pointer clearing so no stale links remain (prev/next = None).",
"",
"---",
"### Complexity Summary:",
"- Splice/Moves by node reference: setHead, setTail, insertBefore, insertAfter, remove → O(1) time, O(1) space.",
"- Positioned/Value operations: insertAtPosition → O(p); removeNodesWithValue, containsNodeWithValue → O(n).",
"- Space: O(1) auxiliary; nodes themselves store two pointers each.",
"",
"---",
"### When to Use This:",
"- You need frequent reordering (LRU caches, editors, schedulers) where you already hold references to nodes.",
"- You want stable O(1) inserts/deletes independent of list length.",
"- You don’t need random access by index (arrays are better for that)."
],
"date": "2025-11-08"
},
    {
"title": "Remove the K-th Node From the End (Two-Pointer Technique)",
"content": [
"This Python routine deletes the k-th node from the end of a singly linked list in one pass using a fast/slow pointer strategy and O(1) extra space."
],
"images": ["algorithms_pics/remove_kth_node_end.png"],
"description": [
"### Problem\n- Given the `head` of a singly linked list and an integer `k`, remove the **k-th node from the end**.\n- The function mutates the list **in place** (it doesn’t return a new head).",
"",
"---",
"### Core Idea: Two Pointers, One Pass\n1. **Advance `second` by `k` nodes** while `first` stays at `head`.\n2. If `second` becomes `None` after this advance, the node to delete is **the head**. The code deletes it by **copying** the value of `head.next` into `head` and skipping the next node: \n   - `head.value = head.next.value`, `head.next = head.next.next`.\n3. Otherwise, **walk both pointers** (`first` and `second`) in lockstep until `second.next` is `None`. Now `first` sits **just before** the target node.\n4. **Skip the target**: `first.next = first.next.next`.",
"",
"---",
"### Why It Works\n- After shifting `second` by `k` steps, the **gap** between `first` and `second` is exactly `k`. When `second` reaches the end, `first` must be right before the k-th node from the end.\n- Handling the head as a special case avoids needing a dummy node and keeps everything O(1).",
"",
"---",
"### Edge Cases & Assumptions\n- `k` is valid (1 ≤ k ≤ length of list).\n- If the node to remove is the head, the implementation **overwrites** the head with its successor. (If the list has a single node and `k=1`, you’d typically handle this by setting `head` to `None` or using a dummy node; this snippet assumes inputs where `head.next` exists when removing head.)",
"",
"---",
"### Complexity\n- **Time:** O(n) — single traversal.\n- **Space:** O(1) — only pointers are used.",
"",
"---",
"### Takeaways\n- Two-pointer (fast/slow) patterns are perfect for “k-th from end” problems.\n- Overwriting the head node is a common in-place trick to avoid returning a new head."
],
"date": "2025-11-09"
},
{
"title": "Summing Two Numbers Stored as Linked Lists (Carry-Friendly Iterative Approach)",
"content": [
"This Python function adds two non-negative integers represented as singly linked lists where each node stores a single digit and the **least significant digit comes first** (at the head). It returns a new linked list representing the sum."
],
"images": ["algorithms_pics/sum_of_linked_lists.png"],
"description": [
"### Problem Statement:",
"- Two numbers are given as linked lists `linkedListOne` and `linkedListTwo`.",
"- Each node holds one digit (0–9). The lists are in **reverse order**: head = ones place, then tens, hundreds, etc.",
"- Add the numbers and return the result as a new linked list (also reverse order).",
"",
"---",
"### How the Algorithm Works:",
"1. **Dummy Head & Cursor:**",
"   - Create a dummy node `newLinkedListHeadPointer` so appending nodes is simple.",
"   - Maintain `currentNode` to build the result.",
"",
"2. **Digit-by-Digit Addition:**",
"   - Walk both lists in lockstep while **either** list still has nodes **or** there’s a nonzero `carry`.",
"   - Read `valueOne` and `valueTwo` (use 0 if a list is exhausted).",
"   - Compute `sumOfValues = valueOne + valueTwo + carry`.",
"",
"3. **Create Result Node & Update Carry:**",
"   - The new digit is `sumOfValues % 10`.",
"   - Append a node with that digit to the result.",
"   - Update `carry = sumOfValues // 10` (0 or 1, occasionally higher if you generalize bases).",
"",
"4. **Advance Pointers:**",
"   - Move `nodeOne` and `nodeTwo` forward when possible and continue.",
"",
"---",
"### Example:",
"- `342` is stored as `2 → 4 → 3` and `465` as `5 → 6 → 4`.",
"- Sum proceeds per digit with carry: `(2+5)=7`, `(4+6)=10` (write 0, carry 1), `(3+4+1)=8`.",
"- Result `807` becomes list `7 → 0 → 8`.",
"",
"---",
"### Why the Dummy Head?",
"- It avoids special-casing the first node. You always attach to `currentNode.next` and finally return `dummy.next`.",
"",
"---",
"### Handles Different Lengths:",
"- If one list ends, its value is treated as 0, so numbers with different digit counts are supported.",
"- The loop condition includes `carry != 0`, ensuring a final carry creates an extra node when needed.",
"",
"---",
"### Complexity:",
"**Time:** O(n + m) — each node of both lists is visited once.  \n**Space:** O(max(n, m)) for the output list (auxiliary space O(1) aside from the result).",
"",
"---",
"### Takeaways:",
"- Store digits **least-significant-first** to enable a single forward pass with carry.",
"- The dummy head pattern keeps the code simple and bug-resistant."
],
"date": "2025-11-10"
},
    {
"title": "Finding the Merge Point of Two Singly Linked Lists (Pointer Switching)",
"content": [
"This Python function returns the first node where two singly linked lists intersect (by reference), using a neat two-pointer trick that runs in linear time and constant space."
],
"images": ["algorithms_pics/merging_linked_lists.png"],
"description": [
"### Problem Statement:",
"- You’re given two heads `linkedListOne` and `linkedListTwo`.",
"- The lists may form a **Y-shape** (share a common tail).",
"- Return the node where they first merge (same object in memory), or `None` if they never intersect.",
"",
"---",
"### How the Algorithm Works:",
"1. **Two runners:** Initialize `currentNodeOne` at `linkedListOne` and `currentNodeTwo` at `linkedListTwo`.",
"2. **Advance with switching:**",
"   - Move each pointer one step at a time.",
"   - When a pointer reaches the end (`None`), **switch it to the head of the other list**.",
"3. **Meet or end:** Continue until the two pointers are the **same node** (merge point) or both become `None` (no intersection).",
"",
"---",
"### Why Switching Works (Intuition):",
"- Let the unique prefixes be lengths `a` and `b`, and the shared tail be length `c`.",
"- By switching heads at the end, each pointer travels `a + c + b` and `b + c + a` steps respectively—**the same total distance**.",
"- Therefore they align at the first common node after at most `a + b + c` moves. If no tail is shared, both land on `None` simultaneously.",
"",
"---",
"### Code Highlights:",
"- Uses identity comparison (`is`) to detect the exact same node object.",
"- Requires **no** length calculations, extra storage, or list modification.",
"- Handles different list lengths naturally.",
"",
"---",
"### Edge Cases & Notes:",
"- If either head is `None`, the function returns `None`.",
"- If lists don’t intersect, both pointers cycle once and finish at `None`.",
"- This approach assumes acyclic lists. (If cycles exist, use a cycle-aware method first.)",
"",
"---",
"### Complexity:",
"**Time Complexity:** O(n + m) — each pointer traverses each list at most once.  \n**Space Complexity:** O(1) — only two pointers are used.",
"",
"---",
"### Takeaways:",
"- Pointer switching equalizes path lengths without precomputing them.",
"- Clean, elegant solution for intersection detection with minimal code."
],
"date": "2025-11-11"
}




]
