[
{
    "title": "Removing Duplicates from a Linked List in Python",
    "content": [
        "This Python script efficiently removes duplicate values from a sorted linked list."
    ],
    "images": [
        "algorithms_pics/remove_duplicates_linkedlist.png"
    ],
    "description": [
        "### Key Features of the Script:",
        "1. **Input Structure:**",
        "   - A `LinkedList` class is used to represent nodes in the linked list. Each node contains a `value` and a `next` pointer to the subsequent node.",
        "",
        "2. **Logic for Removing Duplicates:**",
        "   - The script iterates through the linked list, comparing the value of the current node with the next node.",
        "   - If duplicate nodes are found, the `next` pointer of the current node is updated to skip the duplicate nodes and point to the next distinct node.",
        "",
        "3. **Output:**",
        "   - The function returns the modified linked list with duplicates removed, preserving the sorted order.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- Each node in the linked list is visited once, and duplicate nodes are skipped efficiently.",
        "- Since we traverse the list only once, the total time complexity is **O(n)**, where `n` is the number of nodes in the linked list.",
        "",
        "**Space Complexity:**",
        "- The function modifies the linked list in-place without using any additional data structures.",
        "- Only a few pointers (`current`, `next_distinct`) are used, resulting in a constant space complexity of **O(1)**.",
        "- Therefore, the overall space complexity is **O(1)**."
    ],
    "date": "2025-01-06"
}
,
{
    "title": "Finding the Middle Node in a Linked List",
    "content": [
        "This Python script demonstrates how to efficiently find the middle node of a singly linked list using the two-pointer technique."
    ],
    "images": [
        "algorithms_pics/middle_node.png"
    ],
    "description": [
        "### Key Features of the Script:",
        "1. **Input Handling:**",
        "   - Accepts a singly linked list as input, represented by nodes connected via the `next` pointer.",
        "",
        "2. **Two-Pointer Technique:**",
        "   - Two pointers (`slow_pointer` and `fast_pointer`) are initialized at the head of the linked list.",
        "   - The `fast_pointer` moves two steps at a time, while the `slow_pointer` moves one step at a time.",
        "   - When the `fast_pointer` reaches the end of the list, the `slow_pointer` will be at the middle node.",
        "",
        "3. **Output:**",
        "   - Returns the middle node of the linked list. If the list has an even number of nodes, the second middle node is returned.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- The function iterates through the linked list using the `fast_pointer`, which moves twice as fast as `slow_pointer`.",
        "- Since each node is visited at most once, the overall time complexity is **O(n)**, where `n` is the number of nodes in the list.",
        "",
        "**Space Complexity:**",
        "- The function modifies no additional data structures and only uses two pointer variables (`slow_pointer` and `fast_pointer`).",
        "- Therefore, the overall space complexity is **O(1)**, as the function runs in constant space."
    ],
    "date": "2025-01-07"
},
    {
"title": "Doubly Linked List in Python: O(1) Inserts, Moves, and Deletes",
"content": [
"This implementation provides a classic doubly linked list with constant-time node moves and updates. It supports setting head/tail, inserting before/after any node, inserting at a position, removing nodes (by reference or by value), and linear search."
],
"images": ["algorithms_pics/doubly_linked_list1.png", "algorithms_pics/doubly_linked_list2.png"],
"description": [
"### What Is a Doubly Linked List?",
"- A sequence of nodes where each node has pointers to both its previous and next neighbor (prev, next).",
"- Unlike arrays, linked lists allow O(1) splices when you already hold a reference to the node you want to move or delete.",
"",
"---",
"### Data Structures:",
"- Node(value): holds value, prev, next.",
"- DoublyLinkedList: tracks head and tail and exposes list operations.",
"",
"---",
"### Core Operations & Why They’re Efficient:",
"- setHead(node) — O(1):",
" - Empty list → head = tail = node.",
" - Otherwise delegates to insertBefore(self.head, node) to make node the new head.",
"",
"- setTail(node) — O(1):",
" - Empty list → just setHead(node).",
" - Otherwise insertAfter(self.tail, node).",
"",
"- insertBefore(node, nodeToInsert) — O(1):",
" - If nodeToInsert is already in the list, first detach it via remove(nodeToInsert) to avoid duplicate links.",
" - Splice nodeToInsert right before node; update head if needed.",
"",
"- insertAfter(node, nodeToInsert) — O(1):",
" - Same detach-then-splice pattern; updates tail if we insert after the last node.",
"",
"- insertAtPosition(position, nodeToInsert) — O(p):",
" - Walks from head to the given 1-based position (p steps).",
" - If position exceeds length, node becomes the new tail.",
"",
"- removeNodesWithValue(value) — O(n):",
" - Single pass, keeps nodeToRemove before advancing the cursor to avoid losing the next pointer during detach.",
"",
"- remove(node) — O(1):",
" - Updates head/tail if needed, then clears the node’s bindings with removeNodeBindings.",
"",
"- containsNodeWithValue(value) — O(n):",
" - Linear scan from head.",
"",
"---",
"### Safety & Invariants:",
"- Detach before re-insert: insertBefore/After call remove(nodeToInsert) first. This guarantees a node can be moved anywhere in O(1) without creating cycles or duplicates.",
"- Head/Tail maintenance: remove and the insert helpers correctly update head/tail when the endpoints move.",
"- removeNodeBindings(node) centralizes pointer clearing so no stale links remain (prev/next = None).",
"",
"---",
"### Complexity Summary:",
"- Splice/Moves by node reference: setHead, setTail, insertBefore, insertAfter, remove → O(1) time, O(1) space.",
"- Positioned/Value operations: insertAtPosition → O(p); removeNodesWithValue, containsNodeWithValue → O(n).",
"- Space: O(1) auxiliary; nodes themselves store two pointers each.",
"",
"---",
"### When to Use This:",
"- You need frequent reordering (LRU caches, editors, schedulers) where you already hold references to nodes.",
"- You want stable O(1) inserts/deletes independent of list length.",
"- You don’t need random access by index (arrays are better for that)."
],
"date": "2025-11-08"
},
    {
"title": "Remove the K-th Node From the End (Two-Pointer Technique)",
"content": [
"This Python routine deletes the k-th node from the end of a singly linked list in one pass using a fast/slow pointer strategy and O(1) extra space."
],
"images": ["algorithms_pics/remove_kth_node_end.png"],
"description": [
"### Problem\n- Given the `head` of a singly linked list and an integer `k`, remove the **k-th node from the end**.\n- The function mutates the list **in place** (it doesn’t return a new head).",
"",
"---",
"### Core Idea: Two Pointers, One Pass\n1. **Advance `second` by `k` nodes** while `first` stays at `head`.\n2. If `second` becomes `None` after this advance, the node to delete is **the head**. The code deletes it by **copying** the value of `head.next` into `head` and skipping the next node: \n   - `head.value = head.next.value`, `head.next = head.next.next`.\n3. Otherwise, **walk both pointers** (`first` and `second`) in lockstep until `second.next` is `None`. Now `first` sits **just before** the target node.\n4. **Skip the target**: `first.next = first.next.next`.",
"",
"---",
"### Why It Works\n- After shifting `second` by `k` steps, the **gap** between `first` and `second` is exactly `k`. When `second` reaches the end, `first` must be right before the k-th node from the end.\n- Handling the head as a special case avoids needing a dummy node and keeps everything O(1).",
"",
"---",
"### Edge Cases & Assumptions\n- `k` is valid (1 ≤ k ≤ length of list).\n- If the node to remove is the head, the implementation **overwrites** the head with its successor. (If the list has a single node and `k=1`, you’d typically handle this by setting `head` to `None` or using a dummy node; this snippet assumes inputs where `head.next` exists when removing head.)",
"",
"---",
"### Complexity\n- **Time:** O(n) — single traversal.\n- **Space:** O(1) — only pointers are used.",
"",
"---",
"### Takeaways\n- Two-pointer (fast/slow) patterns are perfect for “k-th from end” problems.\n- Overwriting the head node is a common in-place trick to avoid returning a new head."
],
"date": "2025-11-09"
},
{
"title": "Summing Two Numbers Stored as Linked Lists (Carry-Friendly Iterative Approach)",
"content": [
"This Python function adds two non-negative integers represented as singly linked lists where each node stores a single digit and the **least significant digit comes first** (at the head). It returns a new linked list representing the sum."
],
"images": ["algorithms_pics/sum_of_linked_lists.png"],
"description": [
"### Problem Statement:",
"- Two numbers are given as linked lists `linkedListOne` and `linkedListTwo`.",
"- Each node holds one digit (0–9). The lists are in **reverse order**: head = ones place, then tens, hundreds, etc.",
"- Add the numbers and return the result as a new linked list (also reverse order).",
"",
"---",
"### How the Algorithm Works:",
"1. **Dummy Head & Cursor:**",
"   - Create a dummy node `newLinkedListHeadPointer` so appending nodes is simple.",
"   - Maintain `currentNode` to build the result.",
"",
"2. **Digit-by-Digit Addition:**",
"   - Walk both lists in lockstep while **either** list still has nodes **or** there’s a nonzero `carry`.",
"   - Read `valueOne` and `valueTwo` (use 0 if a list is exhausted).",
"   - Compute `sumOfValues = valueOne + valueTwo + carry`.",
"",
"3. **Create Result Node & Update Carry:**",
"   - The new digit is `sumOfValues % 10`.",
"   - Append a node with that digit to the result.",
"   - Update `carry = sumOfValues // 10` (0 or 1, occasionally higher if you generalize bases).",
"",
"4. **Advance Pointers:**",
"   - Move `nodeOne` and `nodeTwo` forward when possible and continue.",
"",
"---",
"### Example:",
"- `342` is stored as `2 → 4 → 3` and `465` as `5 → 6 → 4`.",
"- Sum proceeds per digit with carry: `(2+5)=7`, `(4+6)=10` (write 0, carry 1), `(3+4+1)=8`.",
"- Result `807` becomes list `7 → 0 → 8`.",
"",
"---",
"### Why the Dummy Head?",
"- It avoids special-casing the first node. You always attach to `currentNode.next` and finally return `dummy.next`.",
"",
"---",
"### Handles Different Lengths:",
"- If one list ends, its value is treated as 0, so numbers with different digit counts are supported.",
"- The loop condition includes `carry != 0`, ensuring a final carry creates an extra node when needed.",
"",
"---",
"### Complexity:",
"**Time:** O(n + m) — each node of both lists is visited once.  \n**Space:** O(max(n, m)) for the output list (auxiliary space O(1) aside from the result).",
"",
"---",
"### Takeaways:",
"- Store digits **least-significant-first** to enable a single forward pass with carry.",
"- The dummy head pattern keeps the code simple and bug-resistant."
],
"date": "2025-11-10"
}



]
