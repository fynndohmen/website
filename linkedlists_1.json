[
{
    "title": "Removing Duplicates from a Linked List in Python",
    "content": [
        "This Python script efficiently removes duplicate values from a sorted linked list."
    ],
    "images": [
        "algorithms_pics/remove_duplicates_linkedlist.png"
    ],
    "description": [
        "### Key Features of the Script:",
        "1. **Input Structure:**",
        "   - A `LinkedList` class is used to represent nodes in the linked list. Each node contains a `value` and a `next` pointer to the subsequent node.",
        "",
        "2. **Logic for Removing Duplicates:**",
        "   - The script iterates through the linked list, comparing the value of the current node with the next node.",
        "   - If duplicate nodes are found, the `next` pointer of the current node is updated to skip the duplicate nodes and point to the next distinct node.",
        "",
        "3. **Output:**",
        "   - The function returns the modified linked list with duplicates removed, preserving the sorted order.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- Each node in the linked list is visited once, and duplicate nodes are skipped efficiently.",
        "- Since we traverse the list only once, the total time complexity is **O(n)**, where `n` is the number of nodes in the linked list.",
        "",
        "**Space Complexity:**",
        "- The function modifies the linked list in-place without using any additional data structures.",
        "- Only a few pointers (`current`, `next_distinct`) are used, resulting in a constant space complexity of **O(1)**.",
        "- Therefore, the overall space complexity is **O(1)**."
    ],
    "date": "2025-01-06"
}
,
{
    "title": "Finding the Middle Node in a Linked List",
    "content": [
        "This Python script demonstrates how to efficiently find the middle node of a singly linked list using the two-pointer technique."
    ],
    "images": [
        "algorithms_pics/middle_node.png"
    ],
    "description": [
        "### Key Features of the Script:",
        "1. **Input Handling:**",
        "   - Accepts a singly linked list as input, represented by nodes connected via the `next` pointer.",
        "",
        "2. **Two-Pointer Technique:**",
        "   - Two pointers (`slow_pointer` and `fast_pointer`) are initialized at the head of the linked list.",
        "   - The `fast_pointer` moves two steps at a time, while the `slow_pointer` moves one step at a time.",
        "   - When the `fast_pointer` reaches the end of the list, the `slow_pointer` will be at the middle node.",
        "",
        "3. **Output:**",
        "   - Returns the middle node of the linked list. If the list has an even number of nodes, the second middle node is returned.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- The function iterates through the linked list using the `fast_pointer`, which moves twice as fast as `slow_pointer`.",
        "- Since each node is visited at most once, the overall time complexity is **O(n)**, where `n` is the number of nodes in the list.",
        "",
        "**Space Complexity:**",
        "- The function modifies no additional data structures and only uses two pointer variables (`slow_pointer` and `fast_pointer`).",
        "- Therefore, the overall space complexity is **O(1)**, as the function runs in constant space."
    ],
    "date": "2025-01-07"
},
    {
"title": "Doubly Linked List in Python: O(1) Inserts, Moves, and Deletes",
"content": [
"This implementation provides a classic doubly linked list with constant-time node moves and updates. It supports setting head/tail, inserting before/after any node, inserting at a position, removing nodes (by reference or by value), and linear search."
],
"images": ["algorithms_pics/doubly_linked_list1.png", "algorithms_pics/doubly_linked_list2.png"],
"description": [
"### What Is a Doubly Linked List?",
"- A sequence of nodes where each node has pointers to both its previous and next neighbor (prev, next).",
"- Unlike arrays, linked lists allow O(1) splices when you already hold a reference to the node you want to move or delete.",
"",
"---",
"### Data Structures:",
"- Node(value): holds value, prev, next.",
"- DoublyLinkedList: tracks head and tail and exposes list operations.",
"",
"---",
"### Core Operations & Why They’re Efficient:",
"- setHead(node) — O(1):",
" - Empty list → head = tail = node.",
" - Otherwise delegates to insertBefore(self.head, node) to make node the new head.",
"",
"- setTail(node) — O(1):",
" - Empty list → just setHead(node).",
" - Otherwise insertAfter(self.tail, node).",
"",
"- insertBefore(node, nodeToInsert) — O(1):",
" - If nodeToInsert is already in the list, first detach it via remove(nodeToInsert) to avoid duplicate links.",
" - Splice nodeToInsert right before node; update head if needed.",
"",
"- insertAfter(node, nodeToInsert) — O(1):",
" - Same detach-then-splice pattern; updates tail if we insert after the last node.",
"",
"- insertAtPosition(position, nodeToInsert) — O(p):",
" - Walks from head to the given 1-based position (p steps).",
" - If position exceeds length, node becomes the new tail.",
"",
"- removeNodesWithValue(value) — O(n):",
" - Single pass, keeps nodeToRemove before advancing the cursor to avoid losing the next pointer during detach.",
"",
"- remove(node) — O(1):",
" - Updates head/tail if needed, then clears the node’s bindings with removeNodeBindings.",
"",
"- containsNodeWithValue(value) — O(n):",
" - Linear scan from head.",
"",
"---",
"### Safety & Invariants:",
"- Detach before re-insert: insertBefore/After call remove(nodeToInsert) first. This guarantees a node can be moved anywhere in O(1) without creating cycles or duplicates.",
"- Head/Tail maintenance: remove and the insert helpers correctly update head/tail when the endpoints move.",
"- removeNodeBindings(node) centralizes pointer clearing so no stale links remain (prev/next = None).",
"",
"---",
"### Complexity Summary:",
"- Splice/Moves by node reference: setHead, setTail, insertBefore, insertAfter, remove → O(1) time, O(1) space.",
"- Positioned/Value operations: insertAtPosition → O(p); removeNodesWithValue, containsNodeWithValue → O(n).",
"- Space: O(1) auxiliary; nodes themselves store two pointers each.",
"",
"---",
"### When to Use This:",
"- You need frequent reordering (LRU caches, editors, schedulers) where you already hold references to nodes.",
"- You want stable O(1) inserts/deletes independent of list length.",
"- You don’t need random access by index (arrays are better for that)."
],
"date": "2025-11-08"
}

]
