[
{
    "title": "Removing Duplicates from a Linked List in Python",
    "content": [
        "This Python script efficiently removes duplicate values from a sorted linked list."
    ],
    "images": [
        "algorithms_pics/remove_duplicates_linkedlist.png"
    ],
    "description": [
        "### Key Features of the Script:",
        "1. **Input Structure:**",
        "   - A `LinkedList` class is used to represent nodes in the linked list. Each node contains a `value` and a `next` pointer to the subsequent node.",
        "",
        "2. **Logic for Removing Duplicates:**",
        "   - The script iterates through the linked list, comparing the value of the current node with the next node.",
        "   - If duplicate nodes are found, the `next` pointer of the current node is updated to skip the duplicate nodes and point to the next distinct node.",
        "",
        "3. **Output:**",
        "   - The function returns the modified linked list with duplicates removed, preserving the sorted order.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- Each node in the linked list is visited once, and duplicate nodes are skipped efficiently.",
        "- Since we traverse the list only once, the total time complexity is **O(n)**, where `n` is the number of nodes in the linked list.",
        "",
        "**Space Complexity:**",
        "- The function modifies the linked list in-place without using any additional data structures.",
        "- Only a few pointers (`current`, `next_distinct`) are used, resulting in a constant space complexity of **O(1)**.",
        "- Therefore, the overall space complexity is **O(1)**."
    ],
    "date": "2025-01-06"
}
,
{
    "title": "Finding the Middle Node in a Linked List",
    "content": [
        "This Python script demonstrates how to efficiently find the middle node of a singly linked list using the two-pointer technique."
    ],
    "images": [
        "algorithms_pics/middle_node.png"
    ],
    "description": [
        "### Key Features of the Script:",
        "1. **Input Handling:**",
        "   - Accepts a singly linked list as input, represented by nodes connected via the `next` pointer.",
        "",
        "2. **Two-Pointer Technique:**",
        "   - Two pointers (`slow_pointer` and `fast_pointer`) are initialized at the head of the linked list.",
        "   - The `fast_pointer` moves two steps at a time, while the `slow_pointer` moves one step at a time.",
        "   - When the `fast_pointer` reaches the end of the list, the `slow_pointer` will be at the middle node.",
        "",
        "3. **Output:**",
        "   - Returns the middle node of the linked list. If the list has an even number of nodes, the second middle node is returned.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- The function iterates through the linked list using the `fast_pointer`, which moves twice as fast as `slow_pointer`.",
        "- Since each node is visited at most once, the overall time complexity is **O(n)**, where `n` is the number of nodes in the list.",
        "",
        "**Space Complexity:**",
        "- The function modifies no additional data structures and only uses two pointer variables (`slow_pointer` and `fast_pointer`).",
        "- Therefore, the overall space complexity is **O(1)**, as the function runs in constant space."
    ],
    "date": "2025-01-07"
},
    {
"title": "Doubly Linked List in Python: O(1) Inserts, Moves, and Deletes",
"content": [
"This implementation provides a classic doubly linked list with constant-time node moves and updates. It supports setting head/tail, inserting before/after any node, inserting at a position, removing nodes (by reference or by value), and linear search."
],
"images": ["algorithms_pics/doubly_linked_list1.png", "algorithms_pics/doubly_linked_list2.png"],
"description": [
"### What Is a Doubly Linked List?",
"- A sequence of nodes where each node has pointers to both its previous and next neighbor (prev, next).",
"- Unlike arrays, linked lists allow O(1) splices when you already hold a reference to the node you want to move or delete.",
"",
"---",
"### Data Structures:",
"- Node(value): holds value, prev, next.",
"- DoublyLinkedList: tracks head and tail and exposes list operations.",
"",
"---",
"### Core Operations & Why They’re Efficient:",
"- setHead(node) — O(1):",
" - Empty list → head = tail = node.",
" - Otherwise delegates to insertBefore(self.head, node) to make node the new head.",
"",
"- setTail(node) — O(1):",
" - Empty list → just setHead(node).",
" - Otherwise insertAfter(self.tail, node).",
"",
"- insertBefore(node, nodeToInsert) — O(1):",
" - If nodeToInsert is already in the list, first detach it via remove(nodeToInsert) to avoid duplicate links.",
" - Splice nodeToInsert right before node; update head if needed.",
"",
"- insertAfter(node, nodeToInsert) — O(1):",
" - Same detach-then-splice pattern; updates tail if we insert after the last node.",
"",
"- insertAtPosition(position, nodeToInsert) — O(p):",
" - Walks from head to the given 1-based position (p steps).",
" - If position exceeds length, node becomes the new tail.",
"",
"- removeNodesWithValue(value) — O(n):",
" - Single pass, keeps nodeToRemove before advancing the cursor to avoid losing the next pointer during detach.",
"",
"- remove(node) — O(1):",
" - Updates head/tail if needed, then clears the node’s bindings with removeNodeBindings.",
"",
"- containsNodeWithValue(value) — O(n):",
" - Linear scan from head.",
"",
"---",
"### Safety & Invariants:",
"- Detach before re-insert: insertBefore/After call remove(nodeToInsert) first. This guarantees a node can be moved anywhere in O(1) without creating cycles or duplicates.",
"- Head/Tail maintenance: remove and the insert helpers correctly update head/tail when the endpoints move.",
"- removeNodeBindings(node) centralizes pointer clearing so no stale links remain (prev/next = None).",
"",
"---",
"### Complexity Summary:",
"- Splice/Moves by node reference: setHead, setTail, insertBefore, insertAfter, remove → O(1) time, O(1) space.",
"- Positioned/Value operations: insertAtPosition → O(p); removeNodesWithValue, containsNodeWithValue → O(n).",
"- Space: O(1) auxiliary; nodes themselves store two pointers each.",
"",
"---",
"### When to Use This:",
"- You need frequent reordering (LRU caches, editors, schedulers) where you already hold references to nodes.",
"- You want stable O(1) inserts/deletes independent of list length.",
"- You don’t need random access by index (arrays are better for that)."
],
"date": "2025-11-08"
},
    {
"title": "Remove the K-th Node From the End (Two-Pointer Technique)",
"content": [
"This Python routine deletes the k-th node from the end of a singly linked list in one pass using a fast/slow pointer strategy and O(1) extra space."
],
"images": ["algorithms_pics/remove_kth_node_end.png"],
"description": [
"### Problem\n- Given the `head` of a singly linked list and an integer `k`, remove the **k-th node from the end**.\n- The function mutates the list **in place** (it doesn’t return a new head).",
"",
"---",
"### Core Idea: Two Pointers, One Pass\n1. **Advance `second` by `k` nodes** while `first` stays at `head`.\n2. If `second` becomes `None` after this advance, the node to delete is **the head**. The code deletes it by **copying** the value of `head.next` into `head` and skipping the next node: \n   - `head.value = head.next.value`, `head.next = head.next.next`.\n3. Otherwise, **walk both pointers** (`first` and `second`) in lockstep until `second.next` is `None`. Now `first` sits **just before** the target node.\n4. **Skip the target**: `first.next = first.next.next`.",
"",
"---",
"### Why It Works\n- After shifting `second` by `k` steps, the **gap** between `first` and `second` is exactly `k`. When `second` reaches the end, `first` must be right before the k-th node from the end.\n- Handling the head as a special case avoids needing a dummy node and keeps everything O(1).",
"",
"---",
"### Edge Cases & Assumptions\n- `k` is valid (1 ≤ k ≤ length of list).\n- If the node to remove is the head, the implementation **overwrites** the head with its successor. (If the list has a single node and `k=1`, you’d typically handle this by setting `head` to `None` or using a dummy node; this snippet assumes inputs where `head.next` exists when removing head.)",
"",
"---",
"### Complexity\n- **Time:** O(n) — single traversal.\n- **Space:** O(1) — only pointers are used.",
"",
"---",
"### Takeaways\n- Two-pointer (fast/slow) patterns are perfect for “k-th from end” problems.\n- Overwriting the head node is a common in-place trick to avoid returning a new head."
],
"date": "2025-11-09"
}


]
