[
{
    "title": "Calculating Branch Sums in a Binary Tree",
    "content": [
        "This Python script computes the sum of values along each branch from the root to the leaf nodes in a binary tree."
    ],
    "images": [
        "algorithms_pics/branch_sums1.png",
        "algorithms_pics/branch_sums2.png"
    ],
    "description": [
        "### Key Features of the Branch Sums Script:",
        "1. **Binary Tree Structure:**",
        "   - Each node in the binary tree contains a `value` and two child nodes: `left` and `right`.",
        "",
        "2. **Logic for Calculating Branch Sums:**",
        "   - The function `branchSums()` initializes an empty list `result` to store the sums of all branches.",
        "   - A helper function `calculateBranchSums()` is used to recursively traverse the tree and calculate the sum for each branch.",
        "   - For each node, the current sum is updated by adding the node's value.",
        "   - When a leaf node (node with no children) is reached, the current branch sum is added to the `result` list.",
        "",
        "3. **Output:**",
        "   - The function returns a list of integers representing the sums of all branches from the root to each leaf.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- Each node is visited exactly once during the recursion, resulting in a time complexity of **O(n)**, where *n* is the number of nodes in the binary tree.",
        "",
        "**Space Complexity:**",
        "- The space complexity consists of two parts:",
        "  1. **Result List (`result`):** In the worst case, there can be up to `n/2` leaves, leading to **O(n)** space.",
        "  2. **Call Stack (Recursion):** The recursion depth corresponds to the tree height:",
        "     - **Best/Average Case (Balanced Tree):** Height is O(log n), space is **O(log n)**.",
        "     - **Worst Case (Unbalanced Tree):** Height is O(n), space is **O(n)**.",
        "",
        "### Overall Space Complexity:",
        "- Balanced Tree: O(n + log n) = **O(n)**",
        "- Unbalanced Tree: O(n + n) = **O(n)**"
    ],
    "date": "2024-12-14"
}
,{
    "title": "Calculating Node Depths in a Binary Search Tree (BST)",
    "content": [
        "This Python script calculates the sum of the depths of all nodes in a binary search tree (BST) using recursion."
    ],
    "images": [
        "algorithms_pics/node_depths.png"
    ],
    "description": [
        "### Key Features of the Node Depth Calculation Script:",
        "1. **Binary Search Tree Structure:**",
        "   - Each node in the BST contains a `value` and two child nodes: `left` and `right`.",
        "",
        "2. **Recursive Logic for Depth Calculation:**",
        "   - The function `nodeDepths()` takes two arguments: the root node and the current depth (initially set to 0).",
        "   - At each step, the function adds the current depth to the sum and calls itself recursively for the left and right subtrees with an incremented depth.",
        "   - The base case is reached when a `None` node is encountered, returning 0.",
        "",
        "3. **Output:**",
        "   - Returns the total sum of depths of all nodes in the BST.",
        "",
        "### How the Code Works:",
        "1. A binary search tree is created by initializing the `BST` class and linking nodes to form the tree.",
        "2. The `nodeDepths()` function is called with the root node.",
        "3. The function recursively computes the sum of depths by traversing all nodes in the tree.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- The function visits each node exactly once, performing constant-time operations at each node.",
        "- Since there are `n` nodes in the tree, the total time complexity is **O(n)**.",
        "",
        "**Space Complexity:**",
        "- The space complexity is determined by the recursion depth, which corresponds to the height of the tree.",
        "- **Best/Average Case (Balanced Tree):** The height is **O(log n)**, so the space complexity is **O(log n)**.",
        "- **Worst Case (Unbalanced Tree):** The height is **O(n)**, so the space complexity is **O(n)**."
    ],
    "date": "2024-12-15"
}
,{
    "title": "Evaluating an Expression Tree in Python",
    "content": [
        "This Python script evaluates an expression tree where each internal node represents an operator, and each leaf node represents an operand."
    ],
    "images": [
        "algorithms_pics/expression_tree.png"
    ],
    "description": [
        "### Key Features of the Expression Tree Evaluation Script:",
        "1. **Binary Tree Structure:**",
        "   - Each node in the binary tree contains a `value`, `left`, and `right` pointers.",
        "   - Leaf nodes (nodes without children) contain positive integers representing operands.",
        "   - Internal nodes contain negative integers representing operators:",
        "     - `-1`: Addition (`+`)",
        "     - `-2`: Subtraction (`-`)",
        "     - `-3`: Division (`/`)",
        "     - `-4`: Multiplication (`*`)",
        "",
        "2. **Recursive Evaluation Logic:**",
        "   - The function `evaluateExpressionTree()` recursively traverses the tree.",
        "   - If a leaf node is reached (value >= 0), it directly returns the node's value.",
        "   - If an internal node is reached (value < 0), it evaluates the left and right subtrees recursively.",
        "   - Based on the operator at the current node, it performs the corresponding arithmetic operation on the values returned by the left and right subtrees.",
        "",
        "3. **Output:**",
        "   - The function returns the result of evaluating the expression represented by the tree.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- Each node in the tree is visited exactly once, performing a constant-time operation at each node.",
        "- Given that there are `n` nodes in the tree, the overall time complexity is **O(n)**.",
        "",
        "**Space Complexity:**",
        "- The space complexity is determined by the recursion depth, which depends on the height of the tree.",
        "- **Best/Average Case (Balanced Tree):** The height is **O(log n)**, so the space complexity is **O(log n)**.",
        "- **Worst Case (Unbalanced Tree):** The height is **O(n)**, so the space complexity is **O(n)**."
    ],
    "date": "2024-12-16"
},
    {
  "title": "Inverting a Binary Tree in Python (Breadth-First Approach)",
  "content": [
    "This Python function performs an inversion (mirror operation) on a binary tree using a breadth-first traversal approach. The result is a mirrored version of the original binary tree structure."
  ],
  "images": [
    "algorithms_pics/invert_binary_tree.png"
  ],
  "description": [
    "### What Does Inverting a Binary Tree Mean?",
    "- Inverting (or mirroring) a binary tree means swapping the left and right children of all nodes in the tree.",
    "- The structure of the tree is flipped horizontally.",
    
    "### How the Function Works:",
    "1. **Breadth-First Traversal:**",
    "   - The function uses a queue to traverse the tree level by level.",
    "   - It starts at the root and proceeds to its children and so on.",
    
    "2. **Swapping Logic:**",
    "   - For each node visited, it calls `swapLeftAndRight`, a helper function that swaps the `left` and `right` pointers of that node.",
    "   - This is done for all nodes, ensuring the entire tree is mirrored.",
    
    "3. **Edge Cases:**",
    "   - If a node is `None`, it’s simply skipped to avoid errors.",
    
    "### Why Use Breadth-First Traversal?",
    "- It avoids the risk of deep recursion stack overflow (as seen in depth-first recursion).",
    "- It's efficient and intuitive when modifying nodes in-place level by level.",
    
    "### Complexity Analysis:",
    "**Time Complexity:** O(n) — Every node in the binary tree is visited and processed once.",
    
    "**Space Complexity:**",
    "- O(n) in the worst case for the queue, when the tree is a full binary tree and the queue stores all nodes at the last level.",
    
    "### Use Case:",
    "Inverting a binary tree is a common interview question and has practical applications in graphics, mirrored data structures, and testing symmetry in algorithms."
  ],
  "date": "2025-06-21"
},
{
  "title": "Inverting a Binary Tree Recursively in Python",
  "content": [
    "This Python function demonstrates how to invert a binary tree using a recursive approach, flipping its structure horizontally by swapping left and right child nodes."
  ],
  "images": [
    "algorithms_pics/invert_bst_recursive.png"
  ],
  "description": [
    "### What Does Inverting a Binary Tree Mean?",
    "- Inverting (or mirroring) a binary tree involves swapping the left and right children of every node in the tree.",
    "- The resulting structure is a horizontal mirror image of the original tree.",

    "### How the Recursive Inversion Works:",
    "1. The function checks whether the current node is `None`. If so, it returns immediately (base case).",
    "2. It swaps the left and right child nodes of the current node.",
    "3. Then it recursively applies the same process to the left and right subtrees.",

    "### Code Behavior:",
    "- This recursive function does **not** use any additional data structures like queues or stacks explicitly.",
    "- Instead, it relies on the **call stack** of the recursion to traverse the tree.",

    "### Advantage Over Iterative Approach:",
    "- Compared to the iterative solution that uses a queue, this recursive approach is cleaner and often easier to read.",
    "- Most importantly, it has a better **space complexity** in many cases.",

    "### Complexity Analysis:",
    "**Time Complexity:**",
    "- O(n), where n is the number of nodes in the tree — every node is visited once.",

    "**Space Complexity:**",
    "- O(h), where h is the height of the tree (due to the recursion stack).",
    "- In a balanced binary tree, this results in O(log n) space.",
    "- In the worst case (e.g., a skewed tree), space complexity becomes O(n).",

    "### Summary:",
    "- This recursive solution is an elegant and efficient way to horizontally flip a binary tree using minimal additional memory."
  ],
  "date": "2025-06-22"
}

]
