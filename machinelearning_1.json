[
  {
  "title": "Timing & Logging with Python Decorators: A Tiny Tool That Scales to Machine Learning",
  "content": [
    "This small script is a practical example of why Python decorators are so powerful: you can wrap existing functions without changing their internal code, and automatically add timing and logging behavior to every call.",
    "Here I built two reusable decorators (`timeit` and `log_calls`). Theyâ€™re simple, but they mirror exactly the kind of instrumentation you want in real ML workflows: measuring slow preprocessing steps, tracking training iterations, and keeping debugging output consistent across a codebase."
  ],
  "images": [],
  "description": [
    "### What this script is",
    "The code defines two decorators and uses them to wrap arbitrary functions:",
    "- `timeit`: measures and prints execution time using `time.perf_counter()`",
    "- `log_calls`: prints a small call trace like `"[CALL] train_model()"`",
    "",
    "Both decorators return a new function called `wrapper` that calls the original function (`func`) and adds extra behavior around it.",
    "",
    {
      "type": "image",
      "src": "machinelearning_pics/decorators_timeit_logcalls.png",
      "alt": "Python code showing two decorators: timeit and log_calls, using TypeVar T, Callable[..., T], and functools.wraps"
    },
    "",
    "---",
    "### How the decorators work (step by step)",
    "A decorator is just a function that takes another function and returns a new function.",
    "In this script, `timeit` looks roughly like this:",
    "- It receives `func` (the original function).",
    "- It defines `wrapper(*args, **kwargs)` so it can accept any arguments.",
    "- It records `start` and `end` timestamps around the call.",
    "- It prints the elapsed time.",
    "- It returns the result so the decorated function behaves the same as before.",
    "",
    "That last point is important: `result = func(*args, **kwargs)` and `return result` ensure that decorating does not break the original API. If the original function returns a value (for example a model, a loss number, or a dataframe), the wrapper passes it through unchanged.",
    "",
    "The `log_calls` decorator is similar, but instead of timing it prints a small trace message before calling the function.",
    "",
    "---",
    "### Why `@wraps(func)` matters",
    "Both decorators use `@wraps(func)` from `functools`. Without it, the decorated function would lose helpful metadata and appear as `wrapper` everywhere.",
    "With `@wraps`, Python copies key metadata from the original function to the wrapper, including:",
    "- function name (`__name__`)",
    "- docstring (`__doc__`)",
    "- annotations (`__annotations__`)",
    "- and a `__wrapped__` link used by inspection tools",
    "",
    "This matters in practice because tools like debuggers, documentation generators, and even ML frameworks that inspect functions behave much more predictably when metadata is preserved.",
    "",
    "---",
    "### Why decorators are useful in Machine Learning",
    "Machine learning code quickly becomes a pipeline: data loading, cleaning, feature engineering, batching, training, evaluation, saving, serving. Decorators are a clean way to add cross-cutting functionality to these steps without cluttering each function.",
    "",
    "**Common ML uses where decorators shine:**",
    "- **Profiling preprocessing**: find slow steps in data cleaning or feature computation.",
    "- **Training instrumentation**: time epochs/steps and print structured logs.",
    "- **Caching expensive work**: memoize feature extraction or embedding computation.",
    "- **Retry + robustness**: wrap flaky IO (downloads, remote storage reads) with retry logic.",
    "- **Tracking experiments**: automatically log parameters/metrics to a file or tool (MLflow/W&B style).",
    "- **Guardrails**: validate shapes/dtypes before a model forward pass, raise early errors.",
    "",
    "The big advantage is consistency: once you have a good decorator, you can apply it to many functions and keep your pipeline clean and readable.",
    "",
    "---",
    "### Key takeaway",
    "This script is small, but it demonstrates a pattern that scales: decorators let you add reusable \"infrastructure\" around your ML code (timing, logging, caching, validation) while keeping the actual model and data logic focused and uncluttered."
  ],
  "date": "2026-02-15"
}

]
