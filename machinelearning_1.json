[
{
  "title": "Timing & Logging with Python Decorators: A Tiny Tool That Scales to Machine Learning",
  "content": [
    "This small script is a practical example of why Python decorators are so powerful: you can wrap existing functions without changing their internal code, and automatically add timing and logging behavior to every call.",
    "I built two reusable decorators (timeit and log_calls). They are simple, but they mirror exactly the kind of instrumentation you want in real ML workflows: measuring slow preprocessing steps, tracking training iterations, and keeping debugging output consistent across a codebase."
  ],
  "images": [],
  "description": [
    "### What this script is",
    "The code defines two decorators and uses them to wrap arbitrary functions:",
    "- `timeit`: measures and prints execution time using `time.perf_counter()`",
    "- `log_calls`: prints a small call trace like `[CALL] train_model()`",
    "",
    "Both decorators return a new function called `wrapper` that calls the original function (`func`) and adds extra behavior around it.",
    "",
    {
      "type": "image",
      "src": "machinelearning_pics/decorators_timeit_logcalls.png",
      "alt": "Python code showing two decorators: timeit and log_calls, using TypeVar T, Callable[..., T], and functools.wraps"
    },
    "",
    "---",
    "### How the decorators work (step by step)",
    "A decorator is just a function that takes another function and returns a new function.",
    "In this script, `timeit` works like this:",
    "- It receives `func` (the original function).",
    "- It defines `wrapper(*args, **kwargs)` so it can accept any arguments.",
    "- It records timestamps around the call.",
    "- It prints the elapsed time.",
    "- It returns the original result so the decorated function behaves the same as before.",
    "",
    "That last point matters: `result = func(*args, **kwargs)` and `return result` ensure that decorating does not break the functionâ€™s API. If the original function returns something useful (a model, a loss value, a DataFrame, etc.), the wrapper passes it through unchanged.",
    "",
    "`log_calls` is similar, but instead of timing it prints a message right before the function runs.",
    "",
    "---",
    "### Why `@wraps(func)` matters",
    "Both decorators use `@wraps(func)` from `functools`. Without it, the decorated function would lose helpful metadata and appear as `wrapper` everywhere.",
    "`@wraps` preserves important attributes such as:",
    "- function name (`__name__`)",
    "- docstring (`__doc__`)",
    "- annotations (`__annotations__`)",
    "- and a `__wrapped__` link used by inspection tools",
    "",
    "This is useful because debuggers, documentation generators, and tooling that inspects functions behave much more predictably when metadata is preserved.",
    "",
    "---",
    "### Why decorators are useful in Machine Learning",
    "Machine learning code quickly turns into a pipeline: data loading, cleaning, feature engineering, batching, training, evaluation, saving, and serving. Decorators are a clean way to add cross-cutting functionality to these steps without cluttering each function.",
    "",
    "**Common ML uses where decorators shine:**",
    "- **Profiling preprocessing**: identify slow steps in data cleaning or feature computation.",
    "- **Training instrumentation**: time epochs/steps and print structured logs.",
    "- **Caching expensive work**: reuse results for feature extraction or embedding generation.",
    "- **Retry and robustness**: wrap flaky IO (downloads, remote storage reads) with retry logic.",
    "- **Experiment tracking hooks**: automatically log parameters and metrics (MLflow/W&B style).",
    "- **Guardrails**: validate shapes and dtypes before a model forward pass to fail early.",
    "",
    "The big advantage is consistency: once you have a good decorator, you can apply it everywhere and keep your pipeline readable and maintainable.",
    "",
    "---",
    "### Key takeaway",
    "This script is small, but it demonstrates a pattern that scales: decorators let you add reusable infrastructure around ML code (timing, logging, caching, validation) while keeping the model and data logic focused and uncluttered."
  ],
  "date": "2026-02-15"
}
]
