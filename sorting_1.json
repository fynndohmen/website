[
 {
    "title": "Bubble Sort Algorithm in Python",
    
    "content": [
        "This Python function implements the Bubble Sort algorithm, a simple sorting technique that repeatedly swaps adjacent elements if they are in the wrong order."
    ],
    
    "images": [
        "algorithms_pics/bubble_sort.png"
    ],
    
    "description": [
        "### Key Features of the Bubble Sort Algorithm:",
        
        "1. **Iterative Sorting Approach:** The algorithm iterates over the list multiple times, gradually placing larger elements towards the end.",
        
        "2. **Swapping Mechanism:** If two adjacent elements are out of order, they are swapped to ensure the correct sequence.",
        
        "3. **Pass-by-Pass Sorting:** After each full pass, the largest unsorted element moves to its correct position.",
        
        "4. **Stable Sorting Algorithm:** Bubble Sort maintains the relative order of equal elements, making it a stable sorting method.",
        
        "",
        "### How It Works:",
        
        "1. The algorithm runs two nested loops: an outer loop for multiple passes and an inner loop for comparing adjacent elements.",
        
        "2. Each iteration moves the largest unsorted element to its correct position at the end of the array.",
        
        "3. The process continues until no more swaps are needed, ensuring the array is fully sorted.",
        
        "4. The sorted array is returned at the end of the function execution.",
        
        "",
        "### Complexity Analysis:",
        
        "**Time Complexity:**",
        "- Bubble Sort consists of two nested loops, leading to **O(n²)** comparisons in the worst and average cases.",
        "- If the array is already sorted, an optimized version of Bubble Sort would detect this in **O(n)** time, but this implementation runs in **O(n²)**.",
        
        "**Space Complexity:**",
        "- The algorithm sorts the array in-place, requiring only a few extra variables for swapping.",
        "- As no additional data structures are used, the space complexity remains **O(1)**."
    ],
    
    "date": "2025-01-12"
}
,
  {
    "title": "Sorting an Array Using Insertion Sort",
    
    "content": [
        "This Python function implements the Insertion Sort algorithm, a simple and intuitive sorting technique."
    ],
    
    "images": [
        "algorithms_pics/insertion_sort.png"
    ],
    
    "description": [
        "### How the Insertion Sort Algorithm Works:",
        
        "1. **Iterating Through the Array:**",
        "   - The function loops through the array, treating the first element as a sorted sublist.",
        
        "2. **Comparing Elements:**",
        "   - Each new element is compared to the elements in the sorted sublist.",
        "   - If an element in the sorted part is larger than the current element, it is shifted one position to the right.",
        
        "3. **Placing the Key in the Correct Position:**",
        "   - The current element (key) is inserted in its correct position within the sorted sublist.",
        
        "4. **Repeating Until Sorted:**",
        "   - This process continues until all elements are sorted.",
        
        "",
        "### Complexity Analysis:",
        
        "**Time Complexity:**",
        "- In the worst and average cases, each element must be compared and shifted up to `O(n)` times.",
        "- Since this happens for `n` elements, the total time complexity is **O(n²)**.",
        "- In the best case (already sorted array), each element is only compared once, leading to **O(n)**.",
        
        "**Space Complexity:**",
        "- Insertion Sort is an in-place sorting algorithm, meaning it does not use extra memory for another data structure.",
        "- Only a few additional variables are used (`key`, `i`, `j`), making the space complexity **O(1)**."
    ],
    
    "date": "2025-01-13"
}
,
{
    "title": "Sorting an Array Using Selection Sort",
    "content": [
        "Selection Sort is a simple comparison-based sorting algorithm that repeatedly selects the smallest element from an unsorted section and moves it to its correct position."
    ],
    "images": ["algorithms_pics/selection_sort.png"],
    "description": [
        "### How Selection Sort Works:",
        "1. **Finding the Minimum:** The algorithm iterates through the array and finds the smallest element.",
        "2. **Swapping Elements:** It swaps the smallest element found with the first unsorted element.",
        "3. **Repeating the Process:** The process continues for the remaining unsorted section until the entire array is sorted.",
        "### Steps in the Code:",
        "1. The algorithm loops through each element in the array.",
        "2. For each element, it searches for the smallest element in the remaining unsorted part of the array.",
        "3. Once found, it swaps the smallest element with the current element at the correct position.",
        "4. The process repeats until the array is sorted.",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- The algorithm consists of two nested loops: one for iterating through the array and one for finding the minimum element.",
        "- This results in a total of **O(n²) comparisons** in all cases (worst, average, and best case).",
        "- Selection Sort always performs the same number of comparisons, even if the array is already sorted, making it inefficient for large datasets.",
        "**Space Complexity:**",
        "- Selection Sort is an **in-place sorting algorithm**, meaning it does not use extra memory apart from a few temporary variables.",
        "- Since no additional data structures are required, the space complexity is **O(1)**."
    ],
    "date": "2025-01-14"
},
 {
  "title": "Three Number Sort: 3 Approaches (Counting, Two-Pass Swaps, One-Pass DNF)",
  "content": [
    "Three Number Sort is a small problem with a big payoff: it shows how the same task can be solved with different trade-offs in simplicity, passes over the array, and extra memory.",
    "In this post we cover three common strategies: counting + overwrite, two-pass partitioning, and the one-pass Dutch National Flag approach."
  ],
  "images": [
    "algorithms_pics/three_number_sort_counting_and_two_pass.png",
    "algorithms_pics/three_number_sort_one_pass.png"
  ],
  "description": [
    "## Problem Statement",
    "You are given an array that contains **only three distinct values**.",
    "You are also given an `order` array of length 3 that defines the desired ordering of those values.",
    "Your task is to reorder the array **in-place** so that:",
    "- all occurrences of `order[0]` come first,",
    "- then all occurrences of `order[1]`,",
    "- then all occurrences of `order[2]`.",
    "",
    "Example interpretation (without a concrete input): the array is a multiset of three values, and `order` defines the grouping order.",
    "",
    "---",
    "## Approach 1: Counting + Overwrite",
    "**Idea:** count how many times each of the three values appears, then overwrite the array in three blocks.",
    "",
    "### How it works",
    "1. Create a `valueCounts` array of length 3.",
    "2. For each element, find its index in `order` and increment that bucket.",
    "3. Write back into the original array:",
    "- first `valueCounts[0]` copies of `order[0]`",
    "- then `valueCounts[1]` copies of `order[1]`",
    "- then `valueCounts[2]` copies of `order[2]`",
    "",
    "### Trade-offs",
    "- Very straightforward and easy to reason about.",
    "- Requires small extra storage (`valueCounts`).",
    "- If implemented with `order.index(element)` inside the loop, that lookup is constant here (since `order` has length 3), but it is still extra overhead compared to pointer-based approaches.",
    "",
    "### Complexity",
    "- **Time:** `O(n)`",
    "- **Space:** `O(1)` (only a few counters; constant-sized)",
    "",
    "---",
    "## Approach 2: Two-Pass Partitioning (Swaps)",
    "**Idea:** do two linear scans:",
    "1) push all `order[0]` values to the front,",
    "2) push all `order[2]` values to the end.",
    "Whatever remains in the middle must be `order[1]`.",
    "",
    "### How it works",
    "Pass 1 (left → right):",
    "- keep `firstIdx` as the next position for `order[0]`",
    "- whenever you see `order[0]`, swap it into `firstIdx` and increment `firstIdx`",
    "",
    "Pass 2 (right → left):",
    "- keep `thirdIdx` as the next position for `order[2]` from the end",
    "- whenever you see `order[2]`, swap it into `thirdIdx` and decrement `thirdIdx`",
    "",
    "### Why it works",
    "- After pass 1, the prefix is all `order[0]`.",
    "- After pass 2, the suffix is all `order[2]`.",
    "- Only the middle section remains, and since there are only three values, the middle must be `order[1]`.",
    "",
    "### Complexity",
    "- **Time:** `O(n)` (two passes, still linear)",
    "- **Space:** `O(1)`",
    "",
    "---",
    "## Approach 3: One-Pass (Dutch National Flag / 3-Pointer)",
    "**Idea:** maintain three regions using pointers and sort in a single pass.",
    "",
    "### Regions and pointers",
    "- `[0 .. firstIdx-1]` → confirmed `order[0]` region",
    "- `[firstIdx .. secondIdx-1]` → confirmed `order[1]` region",
    "- `[secondIdx .. thirdIdx]` → unknown region (to be processed)",
    "- `[thirdIdx+1 .. end]` → confirmed `order[2]` region",
    "",
    "### How it works",
    "While `secondIdx <= thirdIdx`, look at `array[secondIdx]`:",
    "",
    "1) If it is `order[0]`:",
    "- swap it with `array[firstIdx]`",
    "- increment `firstIdx` and `secondIdx`",
    "",
    "2) If it is `order[1]`:",
    "- it’s already in the correct middle region → increment `secondIdx`",
    "",
    "3) Otherwise it must be `order[2]`:",
    "- swap it with `array[thirdIdx]`",
    "- decrement `thirdIdx`",
    "- do **not** increment `secondIdx` here, because the swapped-in value from the end is unprocessed",
    "",
    "### Complexity",
    "- **Time:** `O(n)` (single pass)",
    "- **Space:** `O(1)`",
    "",
    "---",
    "## Which One Should You Use?",
    "- **Counting + overwrite:** best if you want the simplest mental model and don’t care about doing extra writes.",
    "- **Two-pass swaps:** a nice middle ground—still simple, fully in-place, linear time.",
    "- **One-pass DNF:** the most elegant and efficient in terms of passes; the standard interview “optimal” solution.",
    "",
    "---",
    "## Summary",
    "All three algorithms achieve the same end result (grouping three values in a specified order) in linear time:",
    "- counting rebuilds the array deterministically from frequencies",
    "- two-pass partitioning moves extremes to the correct ends",
    "- one-pass DNF maintains three regions and finishes in a single traversal",
    "",
    "Understanding these variants is great practice for broader partitioning problems (like quicksort-style partitioning and multi-key grouping)."
  ],
  "date": "2026-02-02"
}


]

