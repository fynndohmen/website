[
 {
    "title": "Calculating Minimum Waiting Time for Queries",
    "content": [
        "This Python script calculates the minimum total waiting time for a series of tasks or queries when they are executed in sequence."
    ],
    "images": ["algorithms_pics/minimum_waiting_time.png"],
    "description": [
        "### Key Features of the Minimum Waiting Time Script:",
        "1. **Sorting for Optimization:**",
        "   - The function begins by sorting the query durations in ascending order. This ensures that shorter queries are processed first, minimizing the waiting time for longer queries.",
        "",
        "2. **Logic for Calculating Waiting Time:**",
        "   - A cumulative sum (`cumulative_duration`) is maintained to keep track of the total duration of queries that have been processed so far.",
        "   - For each query, the cumulative duration is added to the total waiting time before being updated with the current query's duration.",
        "",
        "3. **Output:**",
        "   - The function returns the minimum total waiting time for all queries.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- The function sorts the query list, which takes **O(n log n)** time due to Timsort.",
        "- After sorting, the function iterates through the list once, requiring **O(n)** time.",
        "- Since sorting dominates, the overall time complexity is **O(n log n)**.",
        "",
        "**Space Complexity:**",
        "- The sorting is done in-place, requiring no additional space beyond the input list.",
        "- Only a few integer variables (`total_waiting_time`, `cumulative_duration`) are used, resulting in constant **O(1)** space usage.",
        "- Therefore, the overall space complexity is **O(1)**.",
        "",
        "### Why This is a Greedy Algorithm:",
        "- The algorithm makes **locally optimal choices** at each step by always processing the shortest query first.",
        "- Sorting the queries in ascending order ensures that each task contributes the least possible waiting time to subsequent tasks.",
        "- Since each decision (processing the shortest query first) leads to the **globally optimal solution** (minimum total waiting time), this follows the greedy algorithm paradigm.",
        "- Greedy algorithms work well for this problem because **once a shorter task is processed, it cannot be rearranged to achieve a better result**."
    ],
    "date": "2025-01-04"
},
{
    "title": "Maximizing Speed with the Tandem Bicycle Problem",
    "content": [
        "This Python script calculates the maximum or minimum possible total speed of pairs of cyclists on a tandem bicycle."
    ],
    "images": ["algorithms_pics/tandem_bicycle.png"],
    "description": [
        "### Key Features of the Tandem Bicycle Script:",
        "1. **Input and Sorting:**",
        "   - The function takes two lists of cyclist speeds, `redShirtSpeeds` and `blueShirtSpeeds`, and a boolean `fastest` to determine whether the goal is to maximize or minimize total speed.",
        "   - Both speed lists are sorted in ascending order. If `fastest` is `True`, the `blueShirtSpeeds` list is reversed into descending order to pair the fastest cyclist with the slowest one for maximum speed.",
        "",
        "2. **Pairing Cyclists:**",
        "   - The script iterates through the sorted lists, pairing cyclists from `redShirtSpeeds` and `blueShirtSpeeds`.",
        "   - For each pair, the higher speed is selected to maximize the total speed of the tandem bicycle.",
        "",
        "3. **Output:**",
        "   - The function returns the total speed of the paired cyclists based on the pairing strategy determined by the `fastest` parameter.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- The function sorts both `redShirtSpeeds` and `blueShirtSpeeds`, each requiring **O(n log n)** time due to Timsort.",
        "- If `fastest` is `True`, reversing `blueShirtSpeeds` requires **O(n)** time.",
        "- The iteration through both lists to compute the total speed requires **O(n)** time.",
        "- Since sorting dominates, the overall time complexity is **O(n log n)**.",
        "",
        "**Space Complexity:**",
        "- Sorting is done in-place, requiring no additional memory beyond the input lists.",
        "- Only a few integer variables (`totalSpeed`, loop indices) are used, leading to a constant **O(1)** space usage.",
        "- Therefore, the overall space complexity is **O(1)**.",
        "",
        "### Why This is a Greedy Algorithm:",
        "- The algorithm makes **locally optimal choices** at each step by always selecting the fastest available cyclist for the tandem.",
        "- By sorting and optionally reversing `blueShirtSpeeds`, it ensures that each pair contributes the maximum possible speed.",
        "- Greedy algorithms work well here because **once a pairing decision is made, it cannot be improved by reordering**.",
        "- This guarantees that the final solution is the globally optimal one for maximizing or minimizing the total tandem speed."
    ],
    "date": "2025-01-05"
},
    {
"title": "Optimal Task Pairing to Minimize Total Time (Greedy with Index Buckets)",
"content": [
"This Python solution pairs tasks for k workers so that the total time per worker is balanced. It sorts task durations and always pairs the shortest with the longest, returning the original indices of the paired tasks."
],
"images": ["algorithms_pics/task_assignment.png"],
"description": [
"### Problem Statement:",
"- You’re given a list tasks of positive integers (durations) and an integer k where len(tasks) = 2k.",
"- Assign exactly two tasks to each of the k workers.",
"- Goal: pair tasks so that the maximum total time assigned to any worker is as small as possible.",
"",
"---",
"### Key Idea (Greedy Optimality):",
"- Sort the durations.",
"- Pair the smallest remaining task with the largest remaining task.",
"- Repeat from the outside in. This classic greedy pairing minimizes the worst (maximum) pair sum.",
"",
"---",
"### How the Code Works:",
"1. Index Buckets for Duplicates:",
" - getTaskDurationsToIndices(tasks) builds a dictionary from duration → list of all indices where it occurs.",
" - This lets us sort by duration but still recover the original indices (required by many interview specs).",
"",
"2. Sort Durations Once:",
" - sortedTasks = sorted(tasks) gives the ascending order of durations.",
"",
"3. Two-Pointer Style Pairing:",
" - For idx in 0..k-1:",
" - Take task1Duration = sortedTasks[idx] (current smallest) and pop one original index for it.",
" - Take task2Duration = sortedTasks[len(tasks)-1-idx] (current largest) and pop one original index for it.",
" - Append the pair [task1Index, task2Index] to the result.",
"",
"---",
"### Why Popping from Buckets?",
"- Multiple tasks can have the same duration.",
"- Storing lists of indices for each duration ensures we return valid, unique original positions even with duplicates.",
"",
"---",
"### Complexity:",
"Time Complexity: O(n log n) due to sorting, where n = 2k.",
"Space Complexity: O(n) for the duration→indices buckets and the output.",
"",
"---",
"### Takeaways:",
"- Greedy pairing (smallest with largest) is optimal for minimizing the maximum pair sum.",
"- Mapping durations to original indices cleanly handles duplicates and preserves required outputs."
],
"date": "2025-11-02"
}

]
