[
  {
  "title": "Turning an Old PC into a Go + PostgreSQL Cloud Lab",
  "content": [
    "This project is my first real step into the world of backend development, cloud-like setups, and databases using Go. I took an old i3 PC with 4GB RAM, installed Ubuntu Server on it, and turned it into a small home lab that exposes a JSON API built with Go and backed by a PostgreSQL database.",
    "The main goal was not just to get something working, but to really understand what each piece does: Linux as a server, PostgreSQL as a database server, Go as the HTTP backend, and how they all talk to each other over TCP, HTTP, and SQL."
  ],
  "images": [],
  "description": [
    "### Goal & Overview",
    "- **Goal:** Turn an old PC into a small backend \"cloud lab\" with Go and PostgreSQL, and use it to learn how HTTP servers, databases, and contexts work together.",
    "- **Tech stack:**",
    "  - Ubuntu LTS on a repurposed i3 desktop as a headless server",
    "  - PostgreSQL as the database server",
    "  - Go (`net/http` + `database/sql` + `pgx` driver) as the HTTP API backend",
    "",
    "---",
    "### 1. Hardware & Linux Setup",
    {
      "type": "image",
      "src": "go_pics/server-ssh-setup.png",
      "alt": "SSH connection to the Ubuntu Go server"
    },
    "- I reused an old i3 PC with ~4GB RAM and installed **Ubuntu Server LTS** instead of a desktop environment.",
    "- The idea: keep it headless and manage everything over **SSH** from my main machine.",
    "- Steps:",
    "  - Create a bootable USB stick with the Ubuntu LTS ISO.",
    "  - Install Ubuntu with no GUI, only OpenSSH server enabled.",
    "  - Give the server a static IP or make sure I can consistently reach it via `ssh user@server-ip`.",
    "- Result: I can now power on the \"server PC\", and from my main computer connect only via SSH â€“ no screen, no keyboard needed on the server itself.",
    "",
    "---",
    "### 2. PostgreSQL as the Database Server",
    {
      "type": "image",
      "src": "go_pics/psql-todos-table.png",
      "alt": "psql view of the todos table in the cloudlab database"
    },
    "- On the Ubuntu server, I installed PostgreSQL and created:",
    "  - a **user** (role) for my Go app,",
    "  - a **database** called `cloudlab`,",
    "  - and a **table** called `todos`.",
    "- The `todos` table structure:",
    "  ```sql",
    "  CREATE TABLE todos (",
    "      id SERIAL PRIMARY KEY,",
    "      title TEXT NOT NULL,",
    "      done BOOLEAN NOT NULL DEFAULT FALSE,",
    "      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()",
    "  );",
    "  ```",
    "- I tested everything directly in `psql`:",
    "  - Inserted some rows like `('Cloud lernen')` and `('Go + PostgreSQL verbinden')`.",
    "  - Ran `SELECT * FROM todos;` to confirm the data model works.",
    "",
    "---",
    "### 3. Go Project Structure & Database Connection",
    {
      "type": "image",
      "src": "go_pics/go-code-part1.png",
      "alt": "First part of the Go code: imports, Todo struct, main and database setup"
    },
    {
      "type": "image",
      "src": "go_pics/go-code-part2.png",
      "alt": "Second part of the Go code: getTodosHandler with context, query, loop and JSON response"
    },
    "- On the Go side, I created a small `main.go` with:",
    "  - `package main` as the entry point.",
    "  - Imports for `net/http`, `database/sql`, `encoding/json`, `context`, `time`, and the `pgx` PostgreSQL driver:",
    "    ```go",
    "    import (",
    "        \"context\"",
    "        \"database/sql\"",
    "        \"encoding/json\"",
    "        \"log\"",
    "        \"net/http\"",
    "        \"time\"",
    "",
    "        _ \"github.com/jackc/pgx/v5/stdlib\"",
    "    )",
    "    ```",
    "- I defined a `Todo` struct that mirrors the database columns and controls the JSON field names:",
    "  ```go",
    "  type Todo struct {",
    "      ID        int       `json:\"id\"`",
    "      Title     string    `json:\"title\"`",
    "      Done      bool      `json:\"done\"`",
    "      CreatedAt time.Time `json:\"created_at\"`",
    "  }",
    "  ```",
    "- The database handle is a global `var db *sql.DB` representing a **connection pool**, not just one socket.",
    "",
    "---",
    "### 4. DSN, `sql.Open` and `db.Ping()`",
    "- To connect Go to PostgreSQL, I used a DSN (data source name) URL:",
    "  ```go",
    "  dsn := \"postgres://fynn:YOUR_PASSWORD@localhost:5432/cloudlab?sslmode=disable\"",
    "  ```",
    "- Then:",
    "  ```go",
    "  db, err = sql.Open(\"pgx\", dsn)",
    "  if err != nil {",
    "      log.Fatal(\"Error in sql.Open:\", err)",
    "  }",
    "",
    "  if err = db.Ping(); err != nil {",
    "      log.Fatal(\"Could not connect to database:\", err)",
    "  }",
    "  ```",
    "- `sql.Open` sets up the DB handle using the `pgx` driver, and `db.Ping()` actively checks that the PostgreSQL server is reachable and the credentials/DSN are correct.",
    "",
    "---",
    "### 5. HTTP Server, Routing and Handlers",
    "- For the HTTP side I used the standard library's `net/http` package.",
    "- I registered a handler for `/todos` like this:",
    "  ```go",
    "  http.HandleFunc(\"/todos\", getTodosHandler)",
    "  log.Println(\"Server running on :8080\")",
    "  log.Fatal(http.ListenAndServe(\":8080\", nil))",
    "  ```",
    "- `HandleFunc` registers `getTodosHandler` as the callback for incoming HTTP requests on the `/todos` path.",
    "- `ListenAndServe(\":8080\", nil)` starts the HTTP server and blocks, accepting connections and dispatching them to handlers.",
    "",
    "---",
    "### 6. Request Handling, Context and Database Query",
    "- The core of the API is the `getTodosHandler` function:",
    "  ```go",
    "  func getTodosHandler(w http.ResponseWriter, r *http.Request) {",
    "      ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)",
    "      defer cancel()",
    "",
    "      rows, err := db.QueryContext(ctx,",
    "          \"SELECT id, title, done, created_at FROM todos ORDER BY id\")",
    "      if err != nil {",
    "          http.Error(w, \"Database error\", http.StatusInternalServerError)",
    "          log.Println(\"Query error:\", err)",
    "          return",
    "      }",
    "      defer rows.Close()",
    "",
    "      var todos []Todo",
    "      for rows.Next() {",
    "          var t Todo",
    "          if err := rows.Scan(&t.ID, &t.Title, &t.Done, &t.CreatedAt); err != nil {",
    "              http.Error(w, \"Error reading data\", http.StatusInternalServerError)",
    "              log.Println(\"Scan error:\", err)",
    "              return",
    "          }",
    "          todos = append(todos, t)",
    "      }",
    "      if err := rows.Err(); err != nil {",
    "          http.Error(w, \"Error iterating over rows\", http.StatusInternalServerError)",
    "          log.Println(\"Rows error:\", err)",
    "          return",
    "      }",
    "",
    "      w.Header().Set(\"Content-Type\", \"application/json\")",
    "      if err := json.NewEncoder(w).Encode(todos); err != nil {",
    "          log.Println(\"JSON error:\", err)",
    "      }",
    "  }",
    "  ```",
    "- Things I understood better while building this:",
    "  - `w http.ResponseWriter` is how the server sends an HTTP response back to the client (status, headers, body).",
    "  - `r *http.Request` represents the incoming HTTP request from the browser (method, URL, headers, context, body).",
    "  - `context.WithTimeout` lets me limit how long the DB query is allowed to run (here: 5 seconds).",
    "  - `QueryContext` respects the context and will abort if the timeout is reached or the client disconnects.",
    "",
    "---",
    "### 7. JSON API Endpoint",
    {
      "type": "image",
      "src": "go_pics/todos-endpoint-browser.png",
      "alt": "Browser showing the JSON response from the /todos endpoint"
    },
    "- At the end of the handler, I:",
    "  - set the `Content-Type` header to `application/json`,",
    "  - use `json.NewEncoder(w).Encode(todos)` to serialize the slice of `Todo` structs into JSON and stream it directly into the HTTP response.",
    "- A request to `GET /todos` now returns a JSON array of todos that can be consumed by a browser, `curl`, or any frontend framework.",
    "",
    "---",
    "### 8. Learning Takeaways",
    "- From this small project I learned:",
    "  - How to turn an old PC into a headless Ubuntu server and manage it via SSH.",
    "  - The difference between PostgreSQL as a **database server**, a **database** (e.g. `cloudlab`) and a **table** (e.g. `todos`).",
    "  - How Go's `database/sql` package uses a driver (`pgx`) and a DSN to connect to PostgreSQL.",
    "  - How HTTP handlers work in Go (`http.HandleFunc`, `ResponseWriter`, `*Request`).",
    "  - What a `context.Context` is, and how timeouts and cancellation signals flow through to database queries.",
    "  - How to stream query results into Go structs and return them as clean JSON to a browser or API client.",
    "",
    "- This is just the starting point. From here I can extend the API with `POST /todos`, authentication, more tables, or even deploy a similar Go + PostgreSQL setup on a real cloud provider later."
  ],
  "date": "2025-12-06"
},
{
  "title": "Adding Login, bcrypt and Sessions to My Go + PostgreSQL Cloud Lab",
  "content": [
    "This post builds on top of my first Go + PostgreSQL cloud lab, where I exposed a /todos endpoint backed by a Postgres database.",
    "Here I turn that open endpoint into a simple authenticated mini-app: I add a users table, hash passwords with bcrypt, create sessions with secure random IDs and cookies, protect /todos so it only works after login, and add a basic logout route."
  ],
  "images": [
    "go_pics/go_login_overview.png"
  ],
  "description": [
    "### Context: From Open `/todos` to a Real Login",
    "In the first version of my Go cloud lab, `/todos` was completely open: if you knew the server IP and port, you could just call `/todos` and get the JSON list of todos.",
    "That was okay for a private learning setup, but not for anything that even remotely looks like a real app.",
    "In this iteration I added:",
    "- A `users` table in PostgreSQL",
    "- Password hashing using bcrypt (no more plaintext passwords in the DB)",
    "- A `/login` handler in Go that checks username + password",
    "- A tiny in-memory session store using a map",
    "- A `session_id` cookie that the browser sends with every request",
    "- A `/logout` route that kills the session and clears the cookie.",
    "The hero screenshot at the top of the post (`go_login_overview.png`) shows my setup: VS Code with `main.go` on the left and the login page running in the browser on the right.",

    "---",
    "### 1. Users Table and Password Hashes",
    "First, I added a `users` table to my existing `cloudlab` database. The important part is that I store a password hash, not the raw password.",
    "The screenshot below shows the users table in `psql`: the table definition with `id`, `username`, `password_hash`, `created_at`, plus one row for the user `fynn` with a long bcrypt hash in the `password_hash` column.",

    {
      "type": "image",
      "src": "go_pics/users_table_psql.png",
      "alt": "psql screenshot showing the users table with id, username and password_hash columns and one row for user fynn"
    },

    "To generate these hashes I wrote a tiny helper program in Go. It takes a string password, calls bcrypt to hash it and prints the result. I run this once, copy the output and paste it into the `password_hash` column in PostgreSQL.",
    "The next screenshot shows this helper file in VS Code:",

    {
      "type": "image",
      "src": "go_pics/bcrypt_helper_code.png",
      "alt": "VS Code screenshot of a small Go program that imports bcrypt, defines a password, calls GenerateFromPassword and prints the resulting hash"
    },

    "Inside my main Go server, I had to pull in bcrypt as a new dependency. In the import block of `main.go` I added one extra line for the bcrypt package, which is highlighted in the following screenshot:",

    {
      "type": "image",
      "src": "go_pics/bcrypt0.png",
      "alt": "VS Code screenshot of the import block in main.go with the golang.org/x/crypto/bcrypt import highlighted"
    },

    "In the login handler I then use bcrypt to compare the password the user typed with the stored hash from the database. Instead of comparing plain strings, the handler now calls `bcrypt.CompareHashAndPassword`. If that returns an error, the login fails.",
    "The bcrypt comparison is visible in this snippet from the POST branch of the login handler (highlighted in red in the screenshot):",

    {
      "type": "image",
      "src": "go_pics/bcrypt1.png",
      "alt": "VS Code screenshot of the login handler section where bcrypt.CompareHashAndPassword is called to verify the password"
    },

    "---",
    "### 2. Login Page: HTML, CSS and Routing",
    "For the UI I kept things minimal: a simple HTML form served from `static/login.html` plus a small CSS file for styling.",
    "The HTML file defines a basic page with a title, a link to `static/login.css` and a form that posts to `/login` using the POST method. The form has two fields (`username` and `password`) and a submit button.",
    "The next screenshot shows the relevant part of `login.html` in VS Code:",

    {
      "type": "image",
      "src": "go_pics/login_html_code.png",
      "alt": "VS Code screenshot of login.html showing the Cloud Login title and the POST form with username and password inputs"
    },

    "When I point my browser at `/login`, I see the styled login box with two input fields and a login button, as shown here:",

    {
      "type": "image",
      "src": "go_pics/login_page_browser.png",
      "alt": "Browser screenshot of the Cloud Login page with username and password fields and a blue login button"
    },

    "On the Go side, I needed to wire the static files and the new `/login` route into `main()`. I use `http.FileServer` to serve everything under `./static` and then register three handlers: `/login`, `/todos` and `/logout`.",
    "The screenshot below shows the part of `main()` where the file server and the three routes are registered. The new lines are highlighted:",

    {
      "type": "image",
      "src": "go_pics/login0.png",
      "alt": "VS Code screenshot of main.go showing the http.FileServer for ./static and the HandleFunc registrations for /login, /todos and /logout, with this block highlighted"
    },

    "The core logic for handling logins lives in `loginPageHandler`. It acts as both a GET and a POST handler:",
    "- `GET /login` serves the HTML file.",
    "- `POST /login` reads the form fields, queries the `users` table and then runs the bcrypt check.",
    "The next screenshot shows the upper part of `loginPageHandler`: the method switch, the GET branch that serves `static/login.html` and the POST branch that parses the form, reads `username` and `password` and performs the database query. This is all highlighted so you can see how the handler is structured:",

    {
      "type": "image",
      "src": "go_pics/login1.png",
      "alt": "VS Code screenshot of the upper part of loginPageHandler showing the method switch, the GET branch and the POST branch that parses the form and queries the users table"
    },

    "At the end of the POST branch, once the password has been verified, the handler creates a session and sets a cookie before redirecting to `/todos`. That session and cookie logic is part of the next section, but you can already see it in context here:",

    {
      "type": "image",
      "src": "go_pics/login2.png",
      "alt": "VS Code screenshot of the lower part of loginPageHandler showing the code that generates a session ID, stores it in the map, sets the session_id cookie and redirects to /todos"
    },

    "---",
    "### 3. Sessions and Cookies in Go",
    "To remember that a client is logged in, I added a very small in-memory session store and a helper to generate secure random session IDs.",
    "First, I pulled in two extra packages in the import block of `main.go`: `crypto/rand` for secure random bytes and `encoding/hex` to turn them into a human-readable string. These imports are highlighted in the following screenshot:",

    {
      "type": "image",
      "src": "go_pics/cookies&sessions0.png",
      "alt": "VS Code screenshot of the imports in main.go with crypto/rand and encoding/hex highlighted"
    },

    "Then I declared a global map `sessions` and added a function `generateSessionID()` which uses `rand.Read` to fill a 32-byte slice with random data and encodes it as a hex string. This gives me a random session ID that is hard to guess.",
    "The next screenshot shows the new global `sessions` map and the `generateSessionID` helper directly under the `Todo` struct. The new code is outlined in red:",

    {
      "type": "image",
      "src": "go_pics/cookies&sessions1.png",
      "alt": "VS Code screenshot showing the global sessions map and the generateSessionID function highlighted under the Todo struct"
    },

    "The final step is to create a session after a successful login and send it back to the browser in a cookie. In the POST branch of `loginPageHandler`, after bcrypt has accepted the password, I:",
    "- call `generateSessionID()` to get a new ID,",
    "- store `sessionID -> userID` in the `sessions` map,",
    "- and send a `session_id` cookie with `HttpOnly` set to true.",
    "The screenshot below shows this block of code inside the login handler, with the new session-related lines highlighted:",

    {
      "type": "image",
      "src": "go_pics/cookies&sessions2.png",
      "alt": "VS Code screenshot of loginPageHandler where the session ID is generated, stored in the sessions map, and written into an HttpOnly session_id cookie, all highlighted"
    },

    "From this point on, every request from that browser will carry the `session_id` cookie. The next step is to protect `/todos` using that information.",

    "---",
    "### 4. Protecting `/todos` with a Session Check",
    "Originally, `/todos` was wide open: anyone who knew the URL could hit it and see the JSON response. Now I want it to only work for logged-in users who have a valid session.",
    "To achieve that, I added a session check at the very top of `getTodosHandler`:",
    "- It tries to read the `session_id` cookie from the request.",
    "- If there is no cookie, it redirects to `/login`.",
    "- If there is a cookie, it looks up the session ID in the `sessions` map.",
    "- If the session ID is unknown, it also redirects to `/login`.",
    "Only if both checks pass does the handler continue with the existing database query and JSON response.",
    "The next screenshot shows the top of `getTodosHandler`: the new cookie and session checks are highlighted in red, with the existing database and JSON code visible underneath for context:",

    {
      "type": "image",
      "src": "go_pics/protecttodos.png",
      "alt": "VS Code screenshot of getTodosHandler showing the new session_id cookie lookup and sessions map check highlighted above the existing database query and JSON response code"
    },

    "In practice this means: if I open a fresh browser (no cookies) and try to access `/todos` directly, the server responds with a redirect to `/login`. Only after logging in and receiving a valid `session_id` cookie can I successfully call `/todos`.",

    "---",
    "### 5. Logout: Killing the Session and Clearing the Cookie",
    "To avoid staying logged in forever in one browser session, I added a simple `/logout` route that cleans up both the server-side session and the client-side cookie.",
    "First, I registered the new route in `main()` alongside the existing `/login` and `/todos` handlers. The highlighted line in the next screenshot shows the `HandleFunc` call for `/logout`:",

    {
      "type": "image",
      "src": "go_pics/logout0.png",
      "alt": "VS Code screenshot of main.go with the http.HandleFunc call that registers the /logout route highlighted"
    },

    "The actual logic lives in `logoutHandler`. It does three things:",
    "- Tries to read the `session_id` cookie from the request.",
    "- If it exists, removes the corresponding entry from the `sessions` map.",
    "- Sends a new `session_id` cookie with an empty value and `MaxAge: -1` so that the browser deletes it.",
    "The screenshot below shows the whole `logoutHandler` function, with its core logic clearly visible:",

    {
      "type": "image",
      "src": "go_pics/logout1.png",
      "alt": "VS Code screenshot of logoutHandler showing how the session_id cookie is read, the sessions entry deleted, a new empty cookie with MaxAge -1 set, and a redirect to /login performed"
    },

    "After visiting `/logout` in the browser, I am redirected back to `/login`. Any further request to `/todos` behaves as if I had never logged in: the handler checks the cookie and the sessions map, finds nothing valid and responds with another redirect to `/login`.",

    "---",
    "### 6. Limitations & Next Steps",
    "This is still a learning project, so there are a few things I am aware of:",
    "- Sessions are stored in memory. When I restart the Go server, all sessions are gone and existing cookies become invalid.",
    "- I don't use HTTPS yet. For something exposed to the public internet I would put a reverse proxy (like Caddy or Nginx) with TLS in front and set the `Secure` flag on the cookie.",
    "- There is no rate limiting, CSRF protection or per-user todos yet.",
    "",
    "But for a personal cloud lab running on an old Linux box, this setup already feels much more like a real app compared to the original open `/todos` endpoint:",
    "- passwords are hashed with bcrypt,",
    "- `/todos` is only reachable after a successful login,",
    "- and I can explicitly log out to drop the session.",
    "",
    "In the next iteration I might:",
    "- build a small HTML dashboard that consumes the `/todos` JSON and shows it nicely,",
    "- add per-user todos by linking the `todos` table to `users`,",
    "- and move sessions from the in-memory map into the database."
  ],
  "date": "2025-12-09"
}

]
