[
  {
  "title": "Turning an Old PC into a Go + PostgreSQL Cloud Lab",
  "content": [
    "This project is my first real step into the world of backend development, cloud-like setups, and databases using Go. I took an old i3 PC with 4GB RAM, installed Ubuntu Server on it, and turned it into a small home lab that exposes a JSON API built with Go and backed by a PostgreSQL database.",
    "The main goal was not just to get something working, but to really understand what each piece does: Linux as a server, PostgreSQL as a database server, Go as the HTTP backend, and how they all talk to each other over TCP, HTTP, and SQL."
  ],
  "images": [],
  "description": [
    "### Goal & Overview",
    "- **Goal:** Turn an old PC into a small backend \"cloud lab\" with Go and PostgreSQL, and use it to learn how HTTP servers, databases, and contexts work together.",
    "- **Tech stack:**",
    "  - Ubuntu LTS on a repurposed i3 desktop as a headless server",
    "  - PostgreSQL as the database server",
    "  - Go (`net/http` + `database/sql` + `pgx` driver) as the HTTP API backend",
    "",
    "---",
    "### 1. Hardware & Linux Setup",
    {
      "type": "image",
      "src": "go_pics/server-ssh-setup.png",
      "alt": "SSH connection to the Ubuntu Go server"
    },
    "- I reused an old i3 PC with ~4GB RAM and installed **Ubuntu Server LTS** instead of a desktop environment.",
    "- The idea: keep it headless and manage everything over **SSH** from my main machine.",
    "- Steps:",
    "  - Create a bootable USB stick with the Ubuntu LTS ISO.",
    "  - Install Ubuntu with no GUI, only OpenSSH server enabled.",
    "  - Give the server a static IP or make sure I can consistently reach it via `ssh user@server-ip`.",
    "- Result: I can now power on the \"server PC\", and from my main computer connect only via SSH â€“ no screen, no keyboard needed on the server itself.",
    "",
    "---",
    "### 2. PostgreSQL as the Database Server",
    {
      "type": "image",
      "src": "go_pics/psql-todos-table.png",
      "alt": "psql view of the todos table in the cloudlab database"
    },
    "- On the Ubuntu server, I installed PostgreSQL and created:",
    "  - a **user** (role) for my Go app,",
    "  - a **database** called `cloudlab`,",
    "  - and a **table** called `todos`.",
    "- The `todos` table structure:",
    "  ```sql",
    "  CREATE TABLE todos (",
    "      id SERIAL PRIMARY KEY,",
    "      title TEXT NOT NULL,",
    "      done BOOLEAN NOT NULL DEFAULT FALSE,",
    "      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()",
    "  );",
    "  ```",
    "- I tested everything directly in `psql`:",
    "  - Inserted some rows like `('Cloud lernen')` and `('Go + PostgreSQL verbinden')`.",
    "  - Ran `SELECT * FROM todos;` to confirm the data model works.",
    "",
    "---",
    "### 3. Go Project Structure & Database Connection",
    {
      "type": "image",
      "src": "go_pics/go-code-part1.png",
      "alt": "First part of the Go code: imports, Todo struct, main and database setup"
    },
    {
      "type": "image",
      "src": "go_pics/go-code-part2.png",
      "alt": "Second part of the Go code: getTodosHandler with context, query, loop and JSON response"
    },
    "- On the Go side, I created a small `main.go` with:",
    "  - `package main` as the entry point.",
    "  - Imports for `net/http`, `database/sql`, `encoding/json`, `context`, `time`, and the `pgx` PostgreSQL driver:",
    "    ```go",
    "    import (",
    "        \"context\"",
    "        \"database/sql\"",
    "        \"encoding/json\"",
    "        \"log\"",
    "        \"net/http\"",
    "        \"time\"",
    "",
    "        _ \"github.com/jackc/pgx/v5/stdlib\"",
    "    )",
    "    ```",
    "- I defined a `Todo` struct that mirrors the database columns and controls the JSON field names:",
    "  ```go",
    "  type Todo struct {",
    "      ID        int       `json:\"id\"`",
    "      Title     string    `json:\"title\"`",
    "      Done      bool      `json:\"done\"`",
    "      CreatedAt time.Time `json:\"created_at\"`",
    "  }",
    "  ```",
    "- The database handle is a global `var db *sql.DB` representing a **connection pool**, not just one socket.",
    "",
    "---",
    "### 4. DSN, `sql.Open` and `db.Ping()`",
    "- To connect Go to PostgreSQL, I used a DSN (data source name) URL:",
    "  ```go",
    "  dsn := \"postgres://fynn:YOUR_PASSWORD@localhost:5432/cloudlab?sslmode=disable\"",
    "  ```",
    "- Then:",
    "  ```go",
    "  db, err = sql.Open(\"pgx\", dsn)",
    "  if err != nil {",
    "      log.Fatal(\"Error in sql.Open:\", err)",
    "  }",
    "",
    "  if err = db.Ping(); err != nil {",
    "      log.Fatal(\"Could not connect to database:\", err)",
    "  }",
    "  ```",
    "- `sql.Open` sets up the DB handle using the `pgx` driver, and `db.Ping()` actively checks that the PostgreSQL server is reachable and the credentials/DSN are correct.",
    "",
    "---",
    "### 5. HTTP Server, Routing and Handlers",
    "- For the HTTP side I used the standard library's `net/http` package.",
    "- I registered a handler for `/todos` like this:",
    "  ```go",
    "  http.HandleFunc(\"/todos\", getTodosHandler)",
    "  log.Println(\"Server running on :8080\")",
    "  log.Fatal(http.ListenAndServe(\":8080\", nil))",
    "  ```",
    "- `HandleFunc` registers `getTodosHandler` as the callback for incoming HTTP requests on the `/todos` path.",
    "- `ListenAndServe(\":8080\", nil)` starts the HTTP server and blocks, accepting connections and dispatching them to handlers.",
    "",
    "---",
    "### 6. Request Handling, Context and Database Query",
    "- The core of the API is the `getTodosHandler` function:",
    "  ```go",
    "  func getTodosHandler(w http.ResponseWriter, r *http.Request) {",
    "      ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)",
    "      defer cancel()",
    "",
    "      rows, err := db.QueryContext(ctx,",
    "          \"SELECT id, title, done, created_at FROM todos ORDER BY id\")",
    "      if err != nil {",
    "          http.Error(w, \"Database error\", http.StatusInternalServerError)",
    "          log.Println(\"Query error:\", err)",
    "          return",
    "      }",
    "      defer rows.Close()",
    "",
    "      var todos []Todo",
    "      for rows.Next() {",
    "          var t Todo",
    "          if err := rows.Scan(&t.ID, &t.Title, &t.Done, &t.CreatedAt); err != nil {",
    "              http.Error(w, \"Error reading data\", http.StatusInternalServerError)",
    "              log.Println(\"Scan error:\", err)",
    "              return",
    "          }",
    "          todos = append(todos, t)",
    "      }",
    "      if err := rows.Err(); err != nil {",
    "          http.Error(w, \"Error iterating over rows\", http.StatusInternalServerError)",
    "          log.Println(\"Rows error:\", err)",
    "          return",
    "      }",
    "",
    "      w.Header().Set(\"Content-Type\", \"application/json\")",
    "      if err := json.NewEncoder(w).Encode(todos); err != nil {",
    "          log.Println(\"JSON error:\", err)",
    "      }",
    "  }",
    "  ```",
    "- Things I understood better while building this:",
    "  - `w http.ResponseWriter` is how the server sends an HTTP response back to the client (status, headers, body).",
    "  - `r *http.Request` represents the incoming HTTP request from the browser (method, URL, headers, context, body).",
    "  - `context.WithTimeout` lets me limit how long the DB query is allowed to run (here: 5 seconds).",
    "  - `QueryContext` respects the context and will abort if the timeout is reached or the client disconnects.",
    "",
    "---",
    "### 7. JSON API Endpoint",
    {
      "type": "image",
      "src": "go_pics/todos-endpoint-browser.png",
      "alt": "Browser showing the JSON response from the /todos endpoint"
    },
    "- At the end of the handler, I:",
    "  - set the `Content-Type` header to `application/json`,",
    "  - use `json.NewEncoder(w).Encode(todos)` to serialize the slice of `Todo` structs into JSON and stream it directly into the HTTP response.",
    "- A request to `GET /todos` now returns a JSON array of todos that can be consumed by a browser, `curl`, or any frontend framework.",
    "",
    "---",
    "### 8. Learning Takeaways",
    "- From this small project I learned:",
    "  - How to turn an old PC into a headless Ubuntu server and manage it via SSH.",
    "  - The difference between PostgreSQL as a **database server**, a **database** (e.g. `cloudlab`) and a **table** (e.g. `todos`).",
    "  - How Go's `database/sql` package uses a driver (`pgx`) and a DSN to connect to PostgreSQL.",
    "  - How HTTP handlers work in Go (`http.HandleFunc`, `ResponseWriter`, `*Request`).",
    "  - What a `context.Context` is, and how timeouts and cancellation signals flow through to database queries.",
    "  - How to stream query results into Go structs and return them as clean JSON to a browser or API client.",
    "",
    "- This is just the starting point. From here I can extend the API with `POST /todos`, authentication, more tables, or even deploy a similar Go + PostgreSQL setup on a real cloud provider later."
  ],
  "date": "2025-12-06"
},
{
  "title": "Adding Login, bcrypt and Sessions to My Go + PostgreSQL Cloud Lab",
  "content": [
    "This post builds on top of my first Go + PostgreSQL cloud lab, where I exposed a /todos endpoint backed by a Postgres database.",
    "Here I turn that open endpoint into a simple authenticated mini-app: I add a users table, hash passwords with bcrypt, create sessions with secure random IDs and cookies, protect /todos so it only works after login, and add a basic logout route."
  ],
  "images": [
    "go_pics/go_login_overview.png"
  ],
  "description": [
    "### Context: From Open `/todos` to a Real Login",
    "In the first version of my Go cloud lab, `/todos` was completely open: if you knew the server IP and port, you could just call `/todos` and get the JSON list of todos.",
    "That was okay for a private learning setup, but not for anything that even remotely looks like a real app.",
    "In this iteration I added:",
    "- A `users` table in PostgreSQL",
    "- Password hashing using bcrypt (no more plaintext passwords in the DB)",
    "- A `/login` handler in Go that checks username + password",
    "- A tiny in-memory session store using a map",
    "- A `session_id` cookie that the browser sends with every request",
    "- A `/logout` route that kills the session and clears the cookie.",

    {
      "type": "image",
      "src": "go_pics/login_flow_overview.png",
      "alt": "Diagram of the login flow: browser -> /login -> DB lookup -> session + cookie -> protected /todos"
    },

    "This post walks through those pieces step by step, focusing on the backend logic rather than UI polish.",

    "---",
    "### 1. Users Table in PostgreSQL",
    "First, I added a `users` table to my existing `cloudlab` database. The important part is that I store a password hash, not the raw password.",
    "The DDL for the `users` table (columns like id, username, password_hash, created_at) can be seen in the screenshot below. I highlighted the new table definition compared to my previous setup.",

    {
      "type": "image",
      "src": "go_pics/users_table_psql.png",
      "alt": "psql screenshot showing the users table with id, username and password_hash columns"
    },

    "On the screenshot you can see one user in the `users` table, with a long bcrypt hash string in the `password_hash` column instead of a plaintext password.",

    "---",
    "### 2. Hashing Passwords with bcrypt",
    "To avoid storing plaintext passwords I use `golang.org/x/crypto/bcrypt`.",
    "I wrote a tiny helper program in Go that takes a hard-coded password, hashes it with bcrypt and prints the result to the terminal. That printed hash is what I then copy into the `password_hash` column in PostgreSQL.",
    "The screenshot below shows the small helper file in VS Code: it imports the bcrypt package, defines a password string, calls the bcrypt hash function and prints the resulting hash. The core bcrypt-related lines are highlighted.",

    {
      "type": "image",
      "src": "go_pics/bcrypt_helper_code.png",
      "alt": "VS Code screenshot of the small Go helper that generates a bcrypt hash from a password"
    },

    "Key idea:",
    "- I never store the raw password in the database.",
    "- I only store the bcrypt hash string that the helper program prints.",
    "- During login, I use bcrypt's comparison function in the Go code to check whether the entered password matches the stored hash.",

    "---",
    "### 3. The Login HTML Form",
    "For the UI I kept things minimal: a simple HTML form served from `static/login.html`.",
    "It contains inputs for username and password and posts to `/login` using the POST method. There is also a separate CSS file to style the page a bit.",
    "The screenshot below shows the relevant part of the HTML file in my editor: the `<form>` element with `method=\"POST\"` and `action=\"/login\"`, the labels and input fields for `username` and `password`, and the login button. The form section is highlighted so you can see exactly what the browser submits.",

    {
      "type": "image",
      "src": "go_pics/login_html_code.png",
      "alt": "VS Code screenshot showing the HTML code of the login page with a username and password form"
    },

    "When I open `/login` in the browser, I see the styled form with two fields and a login button as seen here:",

    {
      "type": "image",
      "src": "go_pics/login_page_browser.png",
      "alt": "Browser screenshot of the simple login form with username and password input"
    },

    "---",
    "### 4. The Login Handler in Go (GET + POST)",
    "On the Go side I added a `loginPageHandler` that handles both the GET and the POST method.",
    "- For GET it simply serves the `static/login.html` file.",
    "- For POST it parses the form, reads `username` and `password`, looks up the user in the database by username and then compares the entered password with the stored bcrypt hash.",
    "The screenshot below shows the core part of `loginPageHandler` in `main.go`: the `switch` on `r.Method`, the GET branch that serves the HTML, and the POST branch that calls `ParseForm`, queries the `users` table and calls the bcrypt comparison. The new login-related lines are highlighted so you can distinguish them from existing code.",

    {
      "type": "image",
      "src": "go_pics/login_handler_code.png",
      "alt": "VS Code screenshot of the loginPageHandler showing GET and POST branches and bcrypt comparison"
    },

    "If the login fails, the handler returns an HTTP 401. If it succeeds, the next step is to create a session and set a cookie, which you will see in the next section.",

    "---",
    "### 5. Sessions: Map + Random Session IDs + Cookies",
    "To remember that a client is logged in, I added a very small in-memory session store and a helper to generate secure session IDs.",
    "At the top of `main.go` I introduced a global map from session IDs to user IDs, and a function that uses a crypto-safe random source to generate a random byte slice and convert it to a hex string.",
    "The screenshot below shows the new global `sessions` map and the `generateSessionID` helper function in VS Code. The new declarations are highlighted so you can clearly see what was added compared to the initial version of the project.",

    {
      "type": "image",
      "src": "go_pics/session_map_and_generator.png",
      "alt": "VS Code screenshot showing the global sessions map and the generateSessionID function"
    },

    "After a successful login in the POST branch of the login handler, I:",
    "- generate a new random session ID,",
    "- store `sessionID -> userID` in the `sessions` map,",
    "- and send a `session_id` cookie back to the browser.",
    "The screenshot below shows the small block of code inside the login handler where the session ID is generated, stored in the map and written into an `HttpOnly` cookie via `http.SetCookie`. The session-related lines are highlighted and the surrounding context is shown for orientation.",

    {
      "type": "image",
      "src": "go_pics/session_creation_and_setcookie.png",
      "alt": "VS Code screenshot showing the session creation code and the call to http.SetCookie with session_id"
    },

    "In the browser devtools you can see the resulting `session_id` cookie after a successful login:",

    {
      "type": "image",
      "src": "go_pics/session_cookie_devtools.png",
      "alt": "Browser devtools screenshot showing the session_id cookie set after a successful login"
    },

    "---",
    "### 6. Protecting `/todos` with a Session Check",
    "Originally, `/todos` was wide open. Now I want it to only work for logged-in users who have a valid session.",
    "To achieve that, I added a session check at the very top of `getTodosHandler`:",
    "- It first tries to read the `session_id` cookie from the request.",
    "- If there is no cookie, it redirects to `/login`.",
    "- If there is a cookie, it looks up the session ID in the `sessions` map.",
    "- If the session ID is unknown, it also redirects to `/login`.",
    "Only if both checks pass does the handler continue with the existing database query and JSON response.",
    "The screenshot below shows the top part of `getTodosHandler` in VS Code: the newly added session cookie check (highlighted) and a bit of the existing DB + JSON logic underneath so you can see where the new code is inserted in the flow.",

    {
      "type": "image",
      "src": "go_pics/gettodos_handler_with_session_check.png",
      "alt": "VS Code screenshot of getTodosHandler showing the session cookie check before querying the database"
    },

    "When I now try to open `/todos` directly in a fresh browser (without logging in first), I get redirected to the login page instead of seeing the JSON:",

    {
      "type": "image",
      "src": "go_pics/todos_redirect_to_login.png",
      "alt": "Browser screenshot of trying to open /todos directly and being redirected to the login page"
    },

    "---",
    "### 7. Logout: Killing the Session and the Cookie",
    "To avoid staying logged in forever in one browser session, I also added a simple `/logout` route.",
    "The logout handler does three things:",
    "- Tries to read the `session_id` cookie.",
    "- If it exists, removes the corresponding entry from the `sessions` map.",
    "- Sends a new `session_id` cookie with an empty value and a negative MaxAge so that the browser deletes it.",
    "The screenshot below shows the `logoutHandler` in `main.go`, including the lines that delete the session from the map and clear the cookie. The new logout-related code is highlighted, with a small amount of context around it.",

    {
      "type": "image",
      "src": "go_pics/logout_handler_code.png",
      "alt": "VS Code screenshot showing the Go logoutHandler that deletes the session and clears the cookie"
    },

    "In `main()` I also register the `/logout` route so that visiting that path triggers the handler. After calling `/logout` in the browser, a request to `/todos` again results in a redirect to `/login`, because the session and cookie are gone.",
    "The screenshot below shows this flow in the browser: first hitting `/logout`, then being redirected back to the login page.",

    {
      "type": "image",
      "src": "go_pics/logout_flow.png",
      "alt": "Browser screenshots showing visiting /logout and then being redirected back to the login page"
    },

    "---",
    "### 8. Limitations & Next Steps",
    "This is still a learning project, so there are a few things I am aware of:",
    "- Sessions are stored in memory. When I restart the Go server, all sessions are gone and existing cookies become invalid.",
    "- I don't use HTTPS yet. For something exposed to the public internet I would put a reverse proxy (like Caddy or Nginx) with TLS in front and set the `Secure` flag on the cookie.",
    "- There is no rate limiting, CSRF protection or per-user todos yet.",
    "",
    "But for a personal cloud lab running on an old Linux box, this setup already feels much more like a real app compared to the original open `/todos` endpoint:",
    "- passwords are hashed with bcrypt,",
    "- `/todos` is only reachable after a successful login,",
    "- and I can explicitly log out to drop the session.",
    "",
    "In the next iteration I might:",
    "- build a small HTML dashboard that consumes the `/todos` JSON and shows it nicely,",
    "- add per-user todos by linking the `todos` table to `users`,",
    "- and move sessions from the in-memory map into the database."
  ],
  "date": "2025-12-09"
}


]
