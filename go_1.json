[
{
  "title": "Turning an Old PC into a Go + PostgreSQL Cloud Lab",
  "content": [
    "This project is my first real step into the world of backend development, cloud-like setups, and databases using Go. I took an old i3 PC with 4GB RAM, installed Ubuntu Server on it, and turned it into a small home lab that exposes a JSON API built with Go and backed by a PostgreSQL database.",
    "The main goal was not just to get something working, but to really understand what each piece does: Linux as a server, PostgreSQL as a database server, Go as the HTTP backend, and how they all talk to each other over TCP, HTTP, and SQL."
  ],
  "images": [],
  "description": [
    "### Goal & Overview",
    "- **Goal:** Turn an old PC into a small backend \"cloud lab\" with Go and PostgreSQL, and use it to learn how HTTP servers, databases, and contexts work together.",
    "- **Tech stack:**",
    "  - Ubuntu LTS on a repurposed i3 desktop as a headless server",
    "  - PostgreSQL as the database server",
    "  - Go (`net/http` + `database/sql` + `pgx` driver) as the HTTP API backend",
    "",
    "---",
    "### 1. Hardware & Linux Setup",
    {
      "type": "image",
      "src": "go_pics/server-ssh-setup.png",
      "alt": "SSH connection to the Ubuntu Go server"
    },
    "- I reused an old i3 PC with ~4GB RAM and installed **Ubuntu Server LTS** instead of a desktop environment.",
    "- The idea: keep it headless and manage everything over **SSH** from my main machine.",
    "- Steps:",
    "  - Create a bootable USB stick with the Ubuntu LTS ISO.",
    "  - Install Ubuntu with no GUI, only OpenSSH server enabled.",
    "  - Give the server a static IP or make sure I can consistently reach it via `ssh user@server-ip`.",
    "- Result: I can now power on the \"server PC\", and from my main computer connect only via SSH – no screen, no keyboard needed on the server itself.",
    "",
    "---",
    "### 2. PostgreSQL as the Database Server",
    {
      "type": "image",
      "src": "go_pics/psql-todos-table.png",
      "alt": "psql view of the todos table in the cloudlab database"
    },
    "- On the Ubuntu server, I installed PostgreSQL and created:",
    "  - a **user** (role) for my Go app,",
    "  - a **database** called `cloudlab`,",
    "  - and a **table** called `todos`.",
    "- The `todos` table has four columns:",
    "  - `id` (integer primary key),",
    "  - `title` (text),",
    "  - `done` (boolean, default `false`),",
    "  - `created_at` (timestamp with timezone, default `NOW()`).",
    "- I tested everything directly in `psql` by inserting a couple of rows and running `SELECT * FROM todos;` to see the result.",
    "",
    "---",
    "### 3. Go Project Structure & Database Connection",
    {
      "type": "image",
      "src": "go_pics/go-code-part1.png",
      "alt": "First part of the Go code: imports, Todo struct, main and database setup"
    },
    {
      "type": "image",
      "src": "go_pics/go-code-part2.png",
      "alt": "Second part of the Go code: getTodosHandler with context, query, loop and JSON response"
    },
    "- On the Go side, I created a small project with a single `main.go` file.",
    "- At the top there is the usual `package main` and an import block that pulls in:",
    "  - `net/http` for the web server,",
    "  - `database/sql` for database access,",
    "  - `encoding/json` to send JSON responses,",
    "  - `context` and `time` for timeouts,",
    "  - and the `pgx` driver via `_ \"github.com/jackc/pgx/v5/stdlib\"`.",
    "- I defined a `Todo` struct that mirrors the database columns (`id`, `title`, `done`, `created_at`) and added JSON tags so that the JSON field names match what I want to expose in the API.",
    "- The database handle is a global `var db *sql.DB`, which in Go represents a connection **pool** that `database/sql` manages for me (not just a single connection).",
    "",
    "---",
    "### 4. DSN, `sql.Open` and `db.Ping()`",
    "- To connect Go to PostgreSQL, I use a DSN (data source name) URL that looks like:",
    "  - `postgres://user:password@host:5432/cloudlab?sslmode=disable`",
    "- In `main()` I call `sql.Open(\"pgx\", dsn)` to initialize the DB handle using the `pgx` driver.",
    "- I immediately follow that with `db.Ping()` to actively check that the connection really works (credentials, host, port, database name).",
    "- If either step fails, the program logs the error and exits, so I know early that something is wrong with the setup.",
    "",
    "---",
    "### 5. HTTP Server, Routing and Handlers",
    "- For the HTTP side I use the standard library's `net/http` package.",
    "- In `main()` I register the `/todos` route using `http.HandleFunc(\"/todos\", getTodosHandler)`. This tells Go:",
    "  - \"Whenever a request comes in on `/todos`, call `getTodosHandler` and pass it a `ResponseWriter` plus the `*Request`.\"",
    "- Finally, `http.ListenAndServe(\":8080\", nil)` starts the HTTP server on port 8080 and blocks:",
    "  - It listens for incoming TCP connections,",
    "  - parses HTTP requests,",
    "  - and forwards them to the correct handler based on the path.",
    "",
    "---",
    "### 6. Request Handling, Context and Database Query",
    "- The core of the API is the `getTodosHandler` function (shown in the second Go screenshot above). The rough flow is:",
    "  1. Create a context with a timeout using `context.WithTimeout(r.Context(), 5*time.Second)`. That way, the database query will be cancelled if it takes too long or the client disconnects.",
    "  2. Call `db.QueryContext(ctx, \"SELECT id, title, done, created_at FROM todos ORDER BY id\")` to fetch all todos from the database using that context.",
    "  3. Loop over the returned rows with `rows.Next()` and use `rows.Scan(&t.ID, &t.Title, &t.Done, &t.CreatedAt)` to fill a `Todo` struct for each row.",
    "  4. Append each `Todo` to a slice until there are no more rows and also check `rows.Err()` for any errors that happened during iteration.",
    "  5. Set the response header `Content-Type` to `application/json`.",
    "  6. Use `json.NewEncoder(w).Encode(todos)` to encode the slice of todos as JSON and stream it directly into the HTTP response body.",
    "- The handler does its own error handling at each step and returns appropriate HTTP status codes if something goes wrong (e.g. `500 Internal Server Error` for DB or JSON issues).",
    "",
    "---",
    "### 7. JSON API Endpoint in the Browser",
    {
      "type": "image",
      "src": "go_pics/todos-endpoint-browser.png",
      "alt": "Browser showing the JSON response from the /todos endpoint"
    },
    "- With the Go server running, a simple GET request to `/todos` returns a JSON array of todo objects.",
    "- The screenshot above shows the JSON response in the browser: each object has `id`, `title`, `done` and `created_at` fields coming directly from the database via the Go handler.",
    "- This output can be consumed by anything: a frontend app, `curl`, Postman, or even another service.",
    "",
    "---",
    "### 8. Learning Takeaways",
    "- From this small project I learned:",
    "  - How to turn an old PC into a headless Ubuntu server and manage it via SSH.",
    "  - The difference between PostgreSQL as a **database server**, a **database** (e.g. `cloudlab`) and a **table** (e.g. `todos`).",
    "  - How Go's `database/sql` package uses a driver (`pgx`) and a DSN to connect to PostgreSQL.",
    "  - How HTTP handlers work in Go (`http.HandleFunc`, `ResponseWriter`, `*Request`).",
    "  - What a `context.Context` is, and how timeouts and cancellation signals flow through to database queries.",
    "  - How to stream query results into Go structs and return them as clean JSON to a browser or API client.",
    "",
    "- This is just the starting point. From here I can extend the API with `POST /todos`, authentication, more tables, or even deploy a similar Go + PostgreSQL setup on a real cloud provider later."
  ],
  "date": "2025-12-06"
}
,
{
  "title": "Adding Login, bcrypt and Sessions to My Go + PostgreSQL Cloud Lab",
  "content": [
    "This post builds on top of my first Go + PostgreSQL cloud lab, where I exposed a /todos endpoint backed by a Postgres database.",
    "Here I turn that open endpoint into a simple authenticated mini-app: I add a users table, hash passwords with bcrypt, create sessions with secure random IDs and cookies, protect /todos so it only works after login, and add a basic logout route."
  ],
  "images": [
    "go_pics/go_login_overview.png"
  ],
  "description": [
    "### Context: From Open `/todos` to a Real Login",
    "In the first version of my Go cloud lab, `/todos` was completely open: if you knew the server IP and port, you could just call `/todos` and get the JSON list of todos.",
    "That was okay for a private learning setup, but not for anything that even remotely looks like a real app.",
    "In this iteration I added:",
    "- A `users` table in PostgreSQL",
    "- Password hashing using bcrypt (no more plaintext passwords in the DB)",
    "- A `/login` handler in Go that checks username + password",
    "- A tiny in-memory session store using a map",
    "- A `session_id` cookie that the browser sends with every request",
    "- A `/logout` route that kills the session and clears the cookie.",
    "The hero screenshot at the top of the post (`go_login_overview.png`) shows my setup: VS Code with `main.go` on the left and the login page running in the browser on the right.",

    "---",
    "### 1. Users Table and Password Hashes",
    "First, I added a `users` table to my existing `cloudlab` database. The important part is that I store a password hash, not the raw password.",
    "The screenshot below shows the users table in `psql`: the table definition with `id`, `username`, `password_hash`, `created_at`, plus one row for the user `fynn` with a long bcrypt hash in the `password_hash` column.",

    {
      "type": "image",
      "src": "go_pics/users_table_psql.png",
      "alt": "psql screenshot showing the users table with id, username and password_hash columns and one row for user fynn"
    },

    "To generate these hashes I wrote a tiny helper program in Go. It takes a string password, calls bcrypt to hash it and prints the result. I run this once, copy the output and paste it into the `password_hash` column in PostgreSQL.",
    "The next screenshot shows this helper file in VS Code:",

    {
      "type": "image",
      "src": "go_pics/bcrypt_helper_code.png",
      "alt": "VS Code screenshot of a small Go program that imports bcrypt, defines a password, calls GenerateFromPassword and prints the resulting hash"
    },

    "Inside my main Go server, I had to pull in bcrypt as a new dependency. In the import block of `main.go` I added one extra line for the bcrypt package, which is highlighted in the following screenshot:",

    {
      "type": "image",
      "src": "go_pics/bcrypt0.png",
      "alt": "VS Code screenshot of the import block in main.go with the golang.org/x/crypto/bcrypt import highlighted"
    },

    "In the login handler I then use bcrypt to compare the password the user typed with the stored hash from the database. Instead of comparing plain strings, the handler now calls `bcrypt.CompareHashAndPassword`. If that returns an error, the login fails.",
    "The bcrypt comparison is visible in this snippet from the POST branch of the login handler (highlighted in red in the screenshot):",

    {
      "type": "image",
      "src": "go_pics/bcrypt1.png",
      "alt": "VS Code screenshot of the login handler section where bcrypt.CompareHashAndPassword is called to verify the password"
    },

    "---",
    "### 2. Login Page: HTML, CSS and Routing",
    "For the UI I kept things minimal: a simple HTML form served from `static/login.html` plus a small CSS file for styling.",
    "The HTML file defines a basic page with a title, a link to `static/login.css` and a form that posts to `/login` using the POST method. The form has two fields (`username` and `password`) and a submit button.",
    "The next screenshot shows the relevant part of `login.html` in VS Code:",

    {
      "type": "image",
      "src": "go_pics/login_html_code.png",
      "alt": "VS Code screenshot of login.html showing the Cloud Login title and the POST form with username and password inputs"
    },

    "When I point my browser at `/login`, I see the styled login box with two input fields and a login button, as shown here:",

    {
      "type": "image",
      "src": "go_pics/login_page_browser.png",
      "alt": "Browser screenshot of the Cloud Login page with username and password fields and a blue login button"
    },

    "On the Go side, I needed to wire the static files and the new `/login` route into `main()`. I use `http.FileServer` to serve everything under `./static` and then register three handlers: `/login`, `/todos` and `/logout`.",
    "The screenshot below shows the part of `main()` where the file server and the three routes are registered. The new lines are highlighted:",

    {
      "type": "image",
      "src": "go_pics/login0.png",
      "alt": "VS Code screenshot of main.go showing the http.FileServer for ./static and the HandleFunc registrations for /login, /todos and /logout, with this block highlighted"
    },

    "The core logic for handling logins lives in `loginPageHandler`. It acts as both a GET and a POST handler:",
    "- `GET /login` serves the HTML file.",
    "- `POST /login` reads the form fields, queries the `users` table and then runs the bcrypt check.",
    "The next screenshot shows the upper part of `loginPageHandler`: the method switch, the GET branch that serves `static/login.html` and the POST branch that parses the form, reads `username` and `password` and performs the database query. This is all highlighted so you can see how the handler is structured:",

    {
      "type": "image",
      "src": "go_pics/login1.png",
      "alt": "VS Code screenshot of the upper part of loginPageHandler showing the method switch, the GET branch and the POST branch that parses the form and queries the users table"
    },

    "At the end of the POST branch, once the password has been verified, the handler creates a session and sets a cookie before redirecting to `/todos`. That session and cookie logic is part of the next section, but you can already see it in context here:",

    {
      "type": "image",
      "src": "go_pics/login2.png",
      "alt": "VS Code screenshot of the lower part of loginPageHandler showing the code that generates a session ID, stores it in the map, sets the session_id cookie and redirects to /todos"
    },

    "---",
    "### 3. Sessions and Cookies in Go",
    "To remember that a client is logged in, I added a very small in-memory session store and a helper to generate secure random session IDs.",
    "First, I pulled in two extra packages in the import block of `main.go`: `crypto/rand` for secure random bytes and `encoding/hex` to turn them into a human-readable string. These imports are highlighted in the following screenshot:",

    {
      "type": "image",
      "src": "go_pics/cookies&sessions0.png",
      "alt": "VS Code screenshot of the imports in main.go with crypto/rand and encoding/hex highlighted"
    },

    "Then I declared a global map `sessions` and added a function `generateSessionID()` which uses `rand.Read` to fill a 32-byte slice with random data and encodes it as a hex string. This gives me a random session ID that is hard to guess.",
    "The next screenshot shows the new global `sessions` map and the `generateSessionID` helper directly under the `Todo` struct. The new code is outlined in red:",

    {
      "type": "image",
      "src": "go_pics/cookies&sessions1.png",
      "alt": "VS Code screenshot showing the global sessions map and the generateSessionID function highlighted under the Todo struct"
    },

    "The final step is to create a session after a successful login and send it back to the browser in a cookie. In the POST branch of `loginPageHandler`, after bcrypt has accepted the password, I:",
    "- call `generateSessionID()` to get a new ID,",
    "- store `sessionID -> userID` in the `sessions` map,",
    "- and send a `session_id` cookie with `HttpOnly` set to true.",
    "The screenshot below shows this block of code inside the login handler, with the new session-related lines highlighted:",

    {
      "type": "image",
      "src": "go_pics/cookies&sessions2.png",
      "alt": "VS Code screenshot of loginPageHandler where the session ID is generated, stored in the sessions map, and written into an HttpOnly session_id cookie, all highlighted"
    },

    "From this point on, every request from that browser will carry the `session_id` cookie. The next step is to protect `/todos` using that information.",

    "---",
    "### 4. Protecting `/todos` with a Session Check",
    "Originally, `/todos` was wide open: anyone who knew the URL could hit it and see the JSON response. Now I want it to only work for logged-in users who have a valid session.",
    "To achieve that, I added a session check at the very top of `getTodosHandler`:",
    "- It tries to read the `session_id` cookie from the request.",
    "- If there is no cookie, it redirects to `/login`.",
    "- If there is a cookie, it looks up the session ID in the `sessions` map.",
    "- If the session ID is unknown, it also redirects to `/login`.",
    "Only if both checks pass does the handler continue with the existing database query and JSON response.",
    "The next screenshot shows the top of `getTodosHandler`: the new cookie and session checks are highlighted in red, with the existing database and JSON code visible underneath for context:",

    {
      "type": "image",
      "src": "go_pics/protecttodos.png",
      "alt": "VS Code screenshot of getTodosHandler showing the new session_id cookie lookup and sessions map check highlighted above the existing database query and JSON response code"
    },

    "In practice this means: if I open a fresh browser (no cookies) and try to access `/todos` directly, the server responds with a redirect to `/login`. Only after logging in and receiving a valid `session_id` cookie can I successfully call `/todos`.",

    "---",
    "### 5. Logout: Killing the Session and Clearing the Cookie",
    "To avoid staying logged in forever in one browser session, I added a simple `/logout` route that cleans up both the server-side session and the client-side cookie.",
    "First, I registered the new route in `main()` alongside the existing `/login` and `/todos` handlers. The highlighted line in the next screenshot shows the `HandleFunc` call for `/logout`:",

    {
      "type": "image",
      "src": "go_pics/logout0.png",
      "alt": "VS Code screenshot of main.go with the http.HandleFunc call that registers the /logout route highlighted"
    },

    "The actual logic lives in `logoutHandler`. It does three things:",
    "- Tries to read the `session_id` cookie from the request.",
    "- If it exists, removes the corresponding entry from the `sessions` map.",
    "- Sends a new `session_id` cookie with an empty value and `MaxAge: -1` so that the browser deletes it.",
    "The screenshot below shows the whole `logoutHandler` function, with its core logic clearly visible:",

    {
      "type": "image",
      "src": "go_pics/logout1.png",
      "alt": "VS Code screenshot of logoutHandler showing how the session_id cookie is read, the sessions entry deleted, a new empty cookie with MaxAge -1 set, and a redirect to /login performed"
    },

    "After visiting `/logout` in the browser, I am redirected back to `/login`. Any further request to `/todos` behaves as if I had never logged in: the handler checks the cookie and the sessions map, finds nothing valid and responds with another redirect to `/login`.",

    "---",
    "### 6. Limitations & Next Steps",
    "This is still a learning project, so there are a few things I am aware of:",
    "- Sessions are stored in memory. When I restart the Go server, all sessions are gone and existing cookies become invalid.",
    "- I don't use HTTPS yet. For something exposed to the public internet I would put a reverse proxy (like Caddy or Nginx) with TLS in front and set the `Secure` flag on the cookie.",
    "- There is no rate limiting, CSRF protection or per-user todos yet.",
    "",
    "But for a personal cloud lab running on an old Linux box, this setup already feels much more like a real app compared to the original open `/todos` endpoint:",
    "- passwords are hashed with bcrypt,",
    "- `/todos` is only reachable after a successful login,",
    "- and I can explicitly log out to drop the session.",
    "",
    "In the next iteration I might:",
    "- build a small HTML dashboard that consumes the `/todos` JSON and shows it nicely,",
    "- add per-user todos by linking the `todos` table to `users`,",
    "- and move sessions from the in-memory map into the database."
  ],
  "date": "2025-12-09"
},
  {
  "title": "Running my Go Cloudlab as a systemd Service",
  "content": [
    "After building my first Go + PostgreSQL cloud lab, I still had to start the server manually with `go run .` or by running the binary. In this mini step I turned my Go program into a proper systemd service so it starts automatically when the server boots.",
    "Now I can just press the power button on my old Ubuntu box and my Go backend comes up on port 8080 without any manual login."
  ],
  "images": [
    "go_pics/cloudlab_service_status.png"
  ],
  "description": [
    "### Goal",
    "- Make the Go HTTP server start automatically on boot, just like PostgreSQL.",
    "- Run it as a normal Linux service managed by **systemd**, not as a random process started in an SSH session.",
    "",
    "---",
    "### 1. Build the Go binary",
    "On the server I went into my Go project folder and built a binary called `cloudlab`:",
    "- `cd ~/go-playground`",
    "- `go build -o cloudlab`",
    "- Quick test with `./cloudlab` to make sure it still runs on `:8080`.",
    "",
    "---",
    "### 2. Create the systemd unit file",
    {
      "type": "image",
      "src": "go_pics/cloudlab_service_unit.png",
      "alt": "nano showing the cloudlab.service systemd unit file"
    },
    "Then I created `/etc/systemd/system/cloudlab.service` with the following structure:",
    "- `[Unit]` section: description and dependencies, e.g. `After=network-online.target postgresql.service` so the database and network are ready.",
    "- `[Service]` section:",
    "  - `User=fynn` – run the service as my normal user.",
    "  - `WorkingDirectory=/home/fynn/go-playground` – where the binary lives.",
    "  - `ExecStart=/home/fynn/go-playground/cloudlab` – the actual Go server binary.",
    "  - `Restart=on-failure` – systemd restarts it if it crashes.",
    "- `[Install]` section: `WantedBy=multi-user.target` so it participates in the normal multi-user boot target.",
    "",
    "---",
    "### 3. Tell systemd about it and start it",
    "After saving the unit file, I ran:",
    "- `sudo systemctl daemon-reload` – let systemd re-read unit files.",
    "- `sudo systemctl start cloudlab.service` – start the service once.",
    "- `sudo systemctl status cloudlab.service` – check that it's `active (running)`.",
    "",
    {
      "type": "image",
      "src": "go_pics/cloudlab_service_status.png",
      "alt": "terminal output showing cloudlab.service active (running) and listening on :8080"
    },
    "Seeing it green and running feels much more like a \"real\" backend than just a `go run` process in a shell.",
    "",
    "---",
    "### 4. Enable autostart on boot",
    "To make the service come up after every reboot I enabled it:",
    "- `sudo systemctl enable cloudlab.service`",
    "",
    "This creates a symlink so that when the system reaches the `multi-user` target during boot, systemd automatically starts `cloudlab.service`.",
    "",
    "---",
    "### 5. Result",
    "- Now the flow is:",
    "  1. Press the power button on my old server PC.",
    "  2. Ubuntu boots, PostgreSQL starts, then `cloudlab.service` starts.",
    "  3. From my main machine I can go straight to `http://SERVER_IP:8080/login` without logging into the server first.",
    "- When I want to update the backend, I rebuild the binary and restart the service:",
    "  - `go build -o cloudlab`",
    "  - `sudo systemctl restart cloudlab.service`",
    "",
    "It’s a small change, but it makes the whole project feel much closer to how real services are run on servers."
  ],
  "date": "2025-12-11"
}


]
