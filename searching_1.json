[
{
    "title": "Implementing Binary Search in Python",
    
    "content": [
        "This Python script demonstrates an efficient implementation of the binary search algorithm, which is used to find the position of a target element in a sorted array."
    ],
    
    "images": [
        "algorithms_pics/binary_search.png"
    ],
    
    "description": [
        "### Key Features of the Binary Search Script:",
        
        "1. **Divide-and-Conquer Approach:**",
        "   - The algorithm divides the array into halves repeatedly, narrowing down the search space until the target is found or the search space is empty.",
        
        "2. **Input Parameters:**",
        "   - The function takes a sorted array and a target value as input. The array must be sorted for the binary search to work correctly.",
        
        "3. **Output:**",
        "   - The function returns the index of the target element if it exists in the array.",
        "   - If the target element is not found, the function returns `-1`.",
        
        "### How It Works:",
        
        "1. Initialize two pointers: `left` at the start of the array and `right` at the end of the array.",
        "2. Calculate the middle index of the current search range and retrieve the middle element.",
        "3. Compare the middle element with the target:",
        "   - If the middle element equals the target, return its index.",
        "   - If the middle element is less than the target, move the `left` pointer to `mid + 1` to search the right half.",
        "   - If the middle element is greater than the target, move the `right` pointer to `mid - 1` to search the left half.",
        "4. Repeat steps 2-3 until the `left` pointer exceeds the `right` pointer, indicating that the target is not in the array.",
        
        "### Complexity Analysis:",
        
        "**Time Complexity:**",
        "- In each iteration, the search space is halved, reducing the problem size from `n` to `n/2`, `n/4`, ..., down to `1`.",
        "- Since the maximum number of iterations is `log₂(n)`, the time complexity is **O(log n)**.",
        
        "**Space Complexity:**",
        "- The function uses a fixed number of variables (`left`, `right`, `mid`), leading to a space complexity of **O(1)**.",
        "- No additional data structures are used, as the search operates directly on the input array."
    ],
    
    "date": "2025-01-10"
}
,
{
    "title": "Finding the Three Largest Numbers in an Array",
    
    "content": [
        "This Python function efficiently identifies the three largest numbers in an array while maintaining their order."
    ],
    
    "images": [
        "algorithms_pics/three_largest_numbers.png"
    ],
    
    "description": [
        "### Key Features of the Three Largest Numbers Algorithm:",
        
        "1. **Tracking the Three Largest Numbers:**",
        "   - A list of three values is initialized with negative infinity to store the three largest numbers.",
        
        "2. **Iterating Through the Array:**",
        "   - The function goes through each number in the array and updates the list of three largest numbers accordingly.",
        
        "3. **Shifting and Updating Values:**",
        "   - If a new number is larger than any of the stored values, it is placed in the correct position while shifting the others to maintain order.",
        
        "4. **Efficiently Maintaining Order:**",
        "   - The function ensures that the three largest numbers are always sorted correctly by using a helper function to shift elements when necessary.",
        
        "### Complexity Analysis:",
        
        "**Time Complexity:**",
        "- The function iterates through the array **once**, making **O(n)** comparisons, where `n` is the length of the array.",
        "- Each number is checked and possibly inserted into the three largest numbers list in **constant time O(1)**.",
        "- Thus, the overall time complexity is **O(n)**.",
        
        "**Space Complexity:**",
        "- The function maintains a fixed-size list of three elements, requiring **O(1)** additional space.",
        "- Since no extra data structures that grow with `n` are used, the overall space complexity is **O(1)**."
    ],
    
    "date": "2025-01-11"
},
    {
  "title": "Search in a Sorted Matrix (Top-Right Staircase Walk)",
  "content": [
    "This post explains an efficient way to search for a value in a 2D matrix where each row and each column is sorted in ascending order.",
    "Instead of binary-searching every row, we start in the top-right corner and eliminate an entire row or column on every step."
  ],
  "images": [
    "algorithms_pics/search_in_sorted_matrix.png"
  ],
  "description": [
    "## Problem Statement",
    "Given a 2D matrix where:",
    "- each row is sorted left → right",
    "- each column is sorted top → bottom",
    "",
    "find the coordinates `[row, col]` of a `target` value.",
    "If the target does not exist, return `[-1, -1]`.",
    "",
    "---",
    "## Key Insight: One Comparison Eliminates a Whole Row or Column",
    "The trick is to start at a position where you can move in two directions that strictly reduce the search space.",
    "The **top-right** corner is perfect:",
    "- moving **left** makes values smaller",
    "- moving **down** makes values larger",
    "",
    "So at any position `(row, col)`:",
    "- if `matrix[row][col]` is too big → go left",
    "- if it’s too small → go down",
    "- if it matches → done",
    "",
    "---",
    "## Why Start in the Top-Right Corner?",
    "At the top-right cell:",
    "- everything below is **greater or equal** (same column, sorted downward)",
    "- everything left is **smaller or equal** (same row, sorted leftward)",
    "",
    "That means:",
    "- if the current value is greater than the target, the target cannot be anywhere **below** in this column (those values are even bigger). We safely discard the entire column by moving left.",
    "- if the current value is less than the target, the target cannot be anywhere **left** in this row (those values are even smaller). We safely discard the entire row by moving down.",
    "",
    "Each move removes a full row or a full column from consideration.",
    "",
    "---",
    "## Algorithm Walkthrough",
    "1. Initialize:",
    "- `row = 0` (first row)",
    "- `col = len(matrix[0]) - 1` (last column → top-right corner)",
    "",
    "2. While we are still inside the matrix:",
    "- Compare `matrix[row][col]` with `target`",
    "  - If current > target: `col -= 1` (move left)",
    "  - If current < target: `row += 1` (move down)",
    "  - Else: return `[row, col]`",
    "",
    "3. If we exit the bounds, the target does not exist → return `[-1, -1]`.",
    "",
    "---",
    "## Example",
    "Suppose the matrix is:",
    "",
    "```\n",
    "[ [ 1,  4,  7, 12],\n",
    "  [ 2,  5,  8, 13],\n",
    "  [ 3,  6,  9, 14] ]\n",
    "```",
    "",
    "Target: `8`",
    "",
    "Start at top-right: `12`",
    "- `12 > 8` → move left → `7`",
    "- `7 < 8` → move down → `8`",
    "- match → return `[1, 2]`",
    "",
    "---",
    "## Complexity Analysis",
    "Let:",
    "- `r` = number of rows",
    "- `c` = number of columns",
    "",
    "### Time Complexity: `O(r + c)`",
    "Each step moves either:",
    "- one column left (decreases `col`), or",
    "- one row down (increases `row`).",
    "",
    "You can move left at most `c` times and down at most `r` times, so total comparisons are bounded by:",
    "- **`O(r + c)`**",
    "",
    "### Space Complexity: `O(1)`",
    "Only a few variables are used (`row`, `col`), so extra space is constant.",
    "",
    "---",
    "## Common Pitfalls",
    "- Starting in the wrong corner: top-left does not give you a clean eliminate-left/eliminate-down property.",
    "- Forgetting bounds in the loop condition (`row < len(matrix)` and `col >= 0`).",
    "- Not handling empty matrices (in real code you’d typically add a guard for that).",
    "",
    "---",
    "## Summary",
    "The top-right “staircase” search is a simple but powerful technique:",
    "- one comparison removes an entire row or column",
    "- runs in `O(r + c)` time",
    "- uses constant extra space",
    "",
    "It’s one of the standard patterns for problems involving matrices sorted by rows and columns."
  ],
  "date": "2026-02-01"
}


]
