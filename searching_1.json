[
{
    "title": "Implementing Binary Search in Python",
    
    "content": [
        "This Python script demonstrates an efficient implementation of the binary search algorithm, which is used to find the position of a target element in a sorted array."
    ],
    
    "images": [
        "algorithms_pics/binary_search.png"
    ],
    
    "description": [
        "### Key Features of the Binary Search Script:",
        
        "1. **Divide-and-Conquer Approach:**",
        "   - The algorithm divides the array into halves repeatedly, narrowing down the search space until the target is found or the search space is empty.",
        
        "2. **Input Parameters:**",
        "   - The function takes a sorted array and a target value as input. The array must be sorted for the binary search to work correctly.",
        
        "3. **Output:**",
        "   - The function returns the index of the target element if it exists in the array.",
        "   - If the target element is not found, the function returns `-1`.",
        
        "### How It Works:",
        
        "1. Initialize two pointers: `left` at the start of the array and `right` at the end of the array.",
        "2. Calculate the middle index of the current search range and retrieve the middle element.",
        "3. Compare the middle element with the target:",
        "   - If the middle element equals the target, return its index.",
        "   - If the middle element is less than the target, move the `left` pointer to `mid + 1` to search the right half.",
        "   - If the middle element is greater than the target, move the `right` pointer to `mid - 1` to search the left half.",
        "4. Repeat steps 2-3 until the `left` pointer exceeds the `right` pointer, indicating that the target is not in the array.",
        
        "### Complexity Analysis:",
        
        "**Time Complexity:**",
        "- In each iteration, the search space is halved, reducing the problem size from `n` to `n/2`, `n/4`, ..., down to `1`.",
        "- Since the maximum number of iterations is `log₂(n)`, the time complexity is **O(log n)**.",
        
        "**Space Complexity:**",
        "- The function uses a fixed number of variables (`left`, `right`, `mid`), leading to a space complexity of **O(1)**.",
        "- No additional data structures are used, as the search operates directly on the input array."
    ],
    
    "date": "2025-01-10"
}
,
{
    "title": "Finding the Three Largest Numbers in an Array",
    
    "content": [
        "This Python function efficiently identifies the three largest numbers in an array while maintaining their order."
    ],
    
    "images": [
        "algorithms_pics/three_largest_numbers.png"
    ],
    
    "description": [
        "### Key Features of the Three Largest Numbers Algorithm:",
        
        "1. **Tracking the Three Largest Numbers:**",
        "   - A list of three values is initialized with negative infinity to store the three largest numbers.",
        
        "2. **Iterating Through the Array:**",
        "   - The function goes through each number in the array and updates the list of three largest numbers accordingly.",
        
        "3. **Shifting and Updating Values:**",
        "   - If a new number is larger than any of the stored values, it is placed in the correct position while shifting the others to maintain order.",
        
        "4. **Efficiently Maintaining Order:**",
        "   - The function ensures that the three largest numbers are always sorted correctly by using a helper function to shift elements when necessary.",
        
        "### Complexity Analysis:",
        
        "**Time Complexity:**",
        "- The function iterates through the array **once**, making **O(n)** comparisons, where `n` is the length of the array.",
        "- Each number is checked and possibly inserted into the three largest numbers list in **constant time O(1)**.",
        "- Thus, the overall time complexity is **O(n)**.",
        
        "**Space Complexity:**",
        "- The function maintains a fixed-size list of three elements, requiring **O(1)** additional space.",
        "- Since no extra data structures that grow with `n` are used, the overall space complexity is **O(1)**."
    ],
    
    "date": "2025-01-11"
},
{
  "title": "Search in a Sorted Matrix (Top-Right Staircase Walk)",
  "content": [
    "This post explains an efficient way to search for a value in a 2D matrix where each row and each column is sorted in ascending order.",
    "Instead of running a binary search on every row, we start in the top-right corner and eliminate an entire row or column on each comparison."
  ],
  "images": [
    "algorithms_pics/search_in_sorted_matrix.png"
  ],
  "description": [
    "## Problem Statement",
    "Given a 2D matrix where:",
    "- each row is sorted left → right",
    "- each column is sorted top → bottom,",
    "",
    "find the coordinates `[row, col]` of a `target` value.",
    "If the target does not exist, return `[-1, -1]`.",
    "",
    "---",
    "## Key Insight: One Comparison Eliminates a Whole Row or Column",
    "The top-right corner gives you two “monotonic” directions:",
    "- moving **left** makes values smaller",
    "- moving **down** makes values larger",
    "",
    "So at any position `(row, col)` you can decide deterministically:",
    "- if `matrix[row][col] > target`, the target cannot be anywhere below in the same column (those values are even larger) → move left (discard a column).",
    "- if `matrix[row][col] < target`, the target cannot be anywhere left in the same row (those values are even smaller) → move down (discard a row).",
    "- otherwise you found the target.",
    "",
    "Each move shrinks the remaining search space by removing an entire row or an entire column.",
    "",
    "---",
    "## Algorithm Overview",
    "1. Start at the top-right cell:",
    "- `row = 0`",
    "- `col = numberOfColumns - 1`",
    "",
    "2. While you are still inside the matrix:",
    "- Compare `matrix[row][col]` with `target`",
    "  - Too large → `col -= 1`",
    "  - Too small → `row += 1`",
    "  - Equal → return `[row, col]`",
    "",
    "3. If you exit the bounds, the target is not present → return `[-1, -1]`.",
    "",
    "---",
    "## Complexity Analysis",
    "Let:",
    "- `r` = number of rows",
    "- `c` = number of columns",
    "",
    "### Time Complexity: `O(r + c)`",
    "Every iteration moves either:",
    "- one step left (reducing `col`), or",
    "- one step down (increasing `row`).",
    "",
    "You can move left at most `c` times and down at most `r` times, so the loop performs at most `r + c` comparisons.",
    "",
    "### Space Complexity: `O(1)`",
    "The algorithm uses only constant extra space (`row`, `col`).",
    "",
    "---",
    "## Common Pitfalls",
    "- Starting in the wrong corner: top-left does not let you eliminate a row/column with a single comparison in a consistent way.",
    "- Incorrect loop bounds: you must stop when `row` leaves the matrix or `col` becomes negative.",
    "- Not guarding for empty input (in real code you’d typically handle empty matrices before accessing `matrix[0]`).",
    "",
    "---",
    "## Summary",
    "The top-right “staircase” search is a standard matrix pattern:",
    "- it removes a full row or column per step",
    "- runs in `O(r + c)` time",
    "- uses `O(1)` extra space",
    "",
    "It’s one of the cleanest ways to search matrices sorted by both rows and columns."
  ],
  "date": "2026-02-01"
}



]
