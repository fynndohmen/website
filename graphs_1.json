[
{
    "title": "Depth-First Search (DFS) Traversal in a Tree",
    "content": [
        "This Python implementation demonstrates the Depth-First Search (DFS) traversal of a tree using recursion."
    ],
    "images": ["algorithms_pics/depth_first_search.png"],
    "description": [
        "### How the Depth-First Search Works:",
        "1. **Node Class:**",
        "   - Each node has a `name` and a list of `children`.",
        "   - The `addChild()` method allows adding child nodes dynamically.",
        "",
        "2. **DFS Traversal:**",
        "   - The function `depthFirstSearch()` starts at the root node.",
        "   - The current node is added to the result list.",
        "   - The function recursively calls DFS on each child node before moving to the next sibling.",
        "",
        "3. **Traversal Order:**",
        "   - DFS explores as deep as possible along each branch before backtracking.",
        "   - The traversal follows a top-to-bottom, left-to-right pattern for each subtree.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- Each node is visited exactly once during traversal.",
        "- Since there are `n` nodes in the tree, the total time complexity is **O(n)**.",
        "",
        "**Space Complexity:**",
        "- The space complexity depends on the recursion depth and the result list.",
        "- **Result List:** Stores all nodes, requiring **O(n)** space.",
        "- **Recursive Call Stack:**",
        "  - **Balanced Tree:** The recursion depth is **O(log n)**, leading to **O(log n)** space.",
        "  - **Unbalanced Tree (Linked List Structure):** The recursion depth is **O(n)**, leading to **O(n)** space.",
        "- Overall, the worst-case space complexity is **O(n)** due to the result list and recursion depth in an unbalanced tree."
    ],
    "date": "2025-01-13"
},
{
  "title": "Detecting a Single Cycle in an Array",
  "content": [
    "This Python function determines whether traversing through an array according to the values it contains forms a single cycle that visits every element exactly once before returning to the starting index."
  ],
  "images": ["algorithms_pics/single_cycle_check.png"],
  "description": [
    "### Problem Statement:",
    "- Given an array of integers where each element represents a number of steps to jump forward or backward (circularly), determine if the traversal starting at index `0` visits every index exactly once and returns to `0` at the end.",
    "- Positive numbers mean jumping forward, negative numbers mean jumping backward.",
    "",
    "---",
    "### How the Algorithm Works:",
    "1. **Initialization:**",
    "   - Start at index `0` with a counter `numElementsVisited` set to 0.",
    "",
    "2. **Main Loop:**",
    "   - Continue jumping through the array using the `getNextIdx()` helper function.",
    "   - If you revisit index `0` **before** visiting all elements, return `False` since that means more than one cycle exists.",
    "",
    "3. **Cycle Completion Check:**",
    "   - After visiting all elements, return whether you're back at index `0`. If so, a single valid cycle exists.",
    "",
    "### `getNextIdx(currentIdx, array)` Details:",
    "- Calculates the next index in a circular manner using modulo arithmetic.",
    "- It ensures wrapping around in both directions, including negative jumps.",
    "- If the result is negative, it corrects the index by adding the array's length to keep it in valid range.",
    "",
    "### Key Observations:",
    "- You must never return to index `0` before all elements are visited — this would split the cycle.",
    "- The use of `% len(array)` ensures wrapping around.",
    "- This algorithm ensures every node is part of exactly one cycle of full traversal.",
    "",
    "---",
    "### Time and Space Complexity:",
    "**Time Complexity:** O(n) — Each element is visited exactly once.",
    "**Space Complexity:** O(1) — Only a few variables are used regardless of input size.",
    "",
    "This solution is efficient and elegant, offering a constant-space approach to solving cycle detection problems in circular arrays."
  ],
  "date": "2025-07-09"
},
{
  "title": "Breadth-First Search (BFS) Traversal in a Tree Structure",
  "content": [
    "This Python class implements a tree structure and performs a Breadth-First Search (BFS) traversal to collect node names in the order they are visited."
  ],
  "images": ["algorithms_pics/bfs_traversal.png"],
  "description": [
    "### What Is Breadth-First Search (BFS)?",
    "- BFS is a tree or graph traversal algorithm that explores nodes level by level, starting from the root.",
    "- It uses a **queue** data structure to keep track of nodes to visit next.",
    "- This approach is ideal when the shortest path or shallowest node is desired.",
    "",
    "---",
    "### How the BFS Method Works:",
    "1. **Initialization:**",
    "   - A queue is initialized with the root node (`self`).",
    "   - An `array` is passed in to collect the names of visited nodes.",
    "",
    "2. **Traversal Loop:**",
    "   - While the queue is not empty, remove the first node from the queue (`current`).",
    "   - Append its `name` to the result `array`.",
    "   - Add all its `children` to the end of the queue for later processing.",
    "",
    "3. **Termination:**",
    "   - The loop continues until all reachable nodes have been visited.",
    "   - The function returns the filled `array`, which represents the BFS order.",
    "",
    "---",
    "### Class Structure Highlights:",
    "**Node Class:**",
    "- Each node stores a `name` and a list of `children`.",
    "- The `addChild` method allows for easy tree construction by appending new `Node` instances.",
    "",
    "**breadthFirstSearch(array) Method:**",
    "- Designed for use on any node (typically the root).",
    "- Returns an ordered list of names based on BFS traversal.",
    "",
    "---",
    "### Example Use Case:",
    "- This BFS logic can be used to solve problems like organizational chart processing, finding the shortest path in unweighted graphs, or level-order printing of trees.",
    "",
    "---",
    "### Time and Space Complexity:",
    "**Time Complexity:** O(n) — Each node is visited exactly once.",
    "**Space Complexity:** O(w) — Where `w` is the maximum width of the tree (i.e., the number of nodes at the largest level).",
    "",
    "This implementation is an efficient and intuitive way to traverse hierarchical data structures using Breadth-First Search."
  ],
  "date": "2025-07-10"
}



]
