[
{
    "title": "Depth-First Search (DFS) Traversal in a Tree",
    "content": [
        "This Python implementation demonstrates the Depth-First Search (DFS) traversal of a tree using recursion."
    ],
    "images": ["algorithms_pics/depth_first_search.png"],
    "description": [
        "### How the Depth-First Search Works:",
        "1. **Node Class:**",
        "   - Each node has a `name` and a list of `children`.",
        "   - The `addChild()` method allows adding child nodes dynamically.",
        "",
        "2. **DFS Traversal:**",
        "   - The function `depthFirstSearch()` starts at the root node.",
        "   - The current node is added to the result list.",
        "   - The function recursively calls DFS on each child node before moving to the next sibling.",
        "",
        "3. **Traversal Order:**",
        "   - DFS explores as deep as possible along each branch before backtracking.",
        "   - The traversal follows a top-to-bottom, left-to-right pattern for each subtree.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- Each node is visited exactly once during traversal.",
        "- Since there are `n` nodes in the tree, the total time complexity is **O(n)**.",
        "",
        "**Space Complexity:**",
        "- The space complexity depends on the recursion depth and the result list.",
        "- **Result List:** Stores all nodes, requiring **O(n)** space.",
        "- **Recursive Call Stack:**",
        "  - **Balanced Tree:** The recursion depth is **O(log n)**, leading to **O(log n)** space.",
        "  - **Unbalanced Tree (Linked List Structure):** The recursion depth is **O(n)**, leading to **O(n)** space.",
        "- Overall, the worst-case space complexity is **O(n)** due to the result list and recursion depth in an unbalanced tree."
    ],
    "date": "2025-01-13"
},
{
  "title": "Detecting a Single Cycle in an Array",
  "content": [
    "This Python function determines whether traversing through an array according to the values it contains forms a single cycle that visits every element exactly once before returning to the starting index."
  ],
  "images": ["algorithms_pics/single_cycle_check.png"],
  "description": [
    "### Problem Statement:",
    "- Given an array of integers where each element represents a number of steps to jump forward or backward (circularly), determine if the traversal starting at index `0` visits every index exactly once and returns to `0` at the end.",
    "- Positive numbers mean jumping forward, negative numbers mean jumping backward.",
    "",
    "---",
    "### How the Algorithm Works:",
    "1. **Initialization:**",
    "   - Start at index `0` with a counter `numElementsVisited` set to 0.",
    "",
    "2. **Main Loop:**",
    "   - Continue jumping through the array using the `getNextIdx()` helper function.",
    "   - If you revisit index `0` **before** visiting all elements, return `False` since that means more than one cycle exists.",
    "",
    "3. **Cycle Completion Check:**",
    "   - After visiting all elements, return whether you're back at index `0`. If so, a single valid cycle exists.",
    "",
    "### `getNextIdx(currentIdx, array)` Details:",
    "- Calculates the next index in a circular manner using modulo arithmetic.",
    "- It ensures wrapping around in both directions, including negative jumps.",
    "- If the result is negative, it corrects the index by adding the array's length to keep it in valid range.",
    "",
    "### Key Observations:",
    "- You must never return to index `0` before all elements are visited — this would split the cycle.",
    "- The use of `% len(array)` ensures wrapping around.",
    "- This algorithm ensures every node is part of exactly one cycle of full traversal.",
    "",
    "---",
    "### Time and Space Complexity:",
    "**Time Complexity:** O(n) — Each element is visited exactly once.",
    "**Space Complexity:** O(1) — Only a few variables are used regardless of input size.",
    "",
    "This solution is efficient and elegant, offering a constant-space approach to solving cycle detection problems in circular arrays."
  ],
  "date": "2025-07-09"
},
{
  "title": "Breadth-First Search (BFS) Traversal in a Tree Structure",
  "content": [
    "This Python class implements a tree structure and performs a Breadth-First Search (BFS) traversal to collect node names in the order they are visited."
  ],
  "images": ["algorithms_pics/bfs_traversal.png"],
  "description": [
    "### What Is Breadth-First Search (BFS)?",
    "- BFS is a tree or graph traversal algorithm that explores nodes level by level, starting from the root.",
    "- It uses a **queue** data structure to keep track of nodes to visit next.",
    "- This approach is ideal when the shortest path or shallowest node is desired.",
    "",
    "---",
    "### How the BFS Method Works:",
    "1. **Initialization:**",
    "   - A queue is initialized with the root node (`self`).",
    "   - An `array` is passed in to collect the names of visited nodes.",
    "",
    "2. **Traversal Loop:**",
    "   - While the queue is not empty, remove the first node from the queue (`current`).",
    "   - Append its `name` to the result `array`.",
    "   - Add all its `children` to the end of the queue for later processing.",
    "",
    "3. **Termination:**",
    "   - The loop continues until all reachable nodes have been visited.",
    "   - The function returns the filled `array`, which represents the BFS order.",
    "",
    "---",
    "### Class Structure Highlights:",
    "**Node Class:**",
    "- Each node stores a `name` and a list of `children`.",
    "- The `addChild` method allows for easy tree construction by appending new `Node` instances.",
    "",
    "**breadthFirstSearch(array) Method:**",
    "- Designed for use on any node (typically the root).",
    "- Returns an ordered list of names based on BFS traversal.",
    "",
    "---",
    "### Example Use Case:",
    "- This BFS logic can be used to solve problems like organizational chart processing, finding the shortest path in unweighted graphs, or level-order printing of trees.",
    "",
    "---",
    "### Time and Space Complexity:",
    "**Time Complexity:** O(n) — Each node is visited exactly once.",
    "**Space Complexity:** O(w) — Where `w` is the maximum width of the tree (i.e., the number of nodes at the largest level).",
    "",
    "This implementation is an efficient and intuitive way to traverse hierarchical data structures using Breadth-First Search."
  ],
  "date": "2025-07-10"
},
{
  "title": "Calculating River Sizes in a Matrix",
  "content": [
    "This Python algorithm efficiently calculates the sizes of all rivers (connected groups of 1s) in a 2D matrix. A river is represented by adjacent 1s (up, down, left, right), and the goal is to return a list of their sizes."
  ],
  "images": ["algorithms_pics/river_sizes.png"],
  "description": [
    "### Problem Overview:",
    "- You're given a 2D matrix of 0s and 1s, where 1 represents part of a river and 0 represents land.",
    "- A river is a group of 1s that are connected horizontally or vertically.",
    "- The task is to compute and return a list of sizes of all discovered rivers.",
    "",
    "---",
    "### How the Algorithm Works:",
    "1. **Initialization:**",
    "   - Create a `visited` matrix of the same shape as `matrix`, initially filled with `False`.",
    "   - Iterate over every cell in the matrix. If the cell has not been visited, call `traverseNode` on it.",
    "",
    "2. **River Traversal:**",
    "- In `traverseNode`, a BFS-like approach is used to explore connected river parts.",
    "- We initialize a queue (`nodesToExplore`) with the current coordinate `(i, j)`.",
    "- While there are nodes to explore:",
    "   - Pop the current node and check if it's already visited.",
    "     - If it is, **`continue`** (skip further processing).",
    "     - If not, mark it as visited.",
    "   - If the cell value is `0`, skip it.",
    "   - Otherwise, increment the current river size counter.",
    "   - Append all unvisited neighbors of the current cell to `nodesToExplore`.",
    "- After fully traversing a river, its size is added to the `sizes` list.",
    "",
    "---",
    "### Why `if visited[i][j]: continue` is Necessary:",
    "Even though we only add unvisited neighbors in `getUnvisitedNeighbors`, it's still possible for the same node to be added to the stack multiple times before it gets visited — especially in grid-based BFS or DFS.",
    "- This happens because two adjacent river tiles might both consider the same neighbor in separate steps.",
    "- Without the check, a node might be processed more than once, leading to incorrect river sizes.",
    "- Therefore, this line ensures **each node is processed only once** even if it's added to the stack multiple times.",
    "",
    "---",
    "### Time and Space Complexity:",
    "**Time Complexity:** O(w × h), where `w` is the width and `h` is the height of the matrix — every node is visited once.",
    "**Space Complexity:** O(w × h) for the `visited` matrix and, in the worst case, the stack/queue during traversal.",
    "",
    "---",
    "### Conclusion:",
    "This algorithm systematically explores the matrix using iterative depth-first search, tracks visited nodes to avoid double-counting, and builds the sizes of all connected components (rivers). It's an efficient solution to a classic connected-components problem on a grid."
  ],
  "date": "2025-07-11"
},
    {
"title": "Youngest Common Ancestor (YCA) in an Ancestral Tree",
"content": [
"This Python solution finds the youngest (lowest) common ancestor of two descendants in a tree where each node holds a pointer to its parent (`ancestor`)."
],
"images": ["algorithms_pics/youngest_common_ancestor.png"],
"description": [
"### Problem Statement:",
"- Given a tree with a known `topAncestor` (the root) and two nodes `descendantOne` and `descendantTwo`, find their **Youngest Common Ancestor (YCA)**—the deepest node that is an ancestor of both.",
"- Each node has a single pointer `ancestor` to its parent; children pointers are not required.",
"",
"---",
"### How the Algorithm Works:",
"1. **Measure Depths:**",
"   - `getDescendantDepth(node, topAncestor)` walks up via `ancestor` pointers to count how far `node` is from `topAncestor`.",
"",
"2. **Lift the Deeper Node:**",
"   - Using `backtrackAncestralTree(lowerDescendant, higherDescendant, diff)`, move the deeper node up by `diff` steps so both nodes are at the same depth.",
"",
"3. **Climb in Lockstep:**",
"   - Step both pointers upward together until they become equal. The meeting point is the **YCA**.",
"",
"---",
"### Why This Works (Intuition):",
"- If two nodes are at the same depth and you climb up one step at a time, they will first meet exactly at their youngest common ancestor.",
"- Aligning depths ensures you don't overshoot: the first equality after alignment must be the YCA.",
"",
"---",
"### Code Overview:",
"- **`getYoungestCommonAncestor(topAncestor, descendantOne, descendantTwo)`**",
"  - Computes depths, aligns levels, then returns the meeting node.",
"- **`getDescendantDepth(descendant, topAncestor)`**",
"  - Counts edges from `descendant` up to `topAncestor`.",
"- **`backtrackAncestralTree(lowerDescendant, higherDescendant, diff)`**",
"  - Lifts the deeper node by `diff`; then advances both until they coincide.",
"",
"---",
"### Time and Space Complexity:",
"**Time Complexity:** O(d) — where `d` is the distance from the deeper node up to the YCA (bounded by tree height). The algorithm performs two upward passes: one to measure depths, another to align and climb together.",
"",
"**Space Complexity:** O(1) — uses a constant number of pointers and counters.",
"",
"---",
"### Takeaways:",
"- Aligning depths converts the YCA problem into a simple synchronized climb.",
"- Parent pointers alone are sufficient; no extra data structures or full tree traversal is needed."
],
"date": "2025-10-28"
},
    {
"title": "Removing Islands in a Binary Matrix (Border-Connected Flood Fill)",
"content": [
"This Python implementation removes islands of 1s from a 2D binary matrix by preserving only the 1s that are connected (directly or indirectly) to the border."
],
"images": ["algorithms_pics/remove_islands1.png","algorithms_pics/remove_islands2.png"],
"description": [
"### Problem Statement:",
"- You’re given a matrix of 0s and 1s.",
"- An island is a connected component of 1s (4-directional: up, down, left, right) that does not touch the matrix border.",
"- Convert all island cells to 0 while keeping every 1 that is connected to the border intact."
,
"---",
"### How the Algorithm Works:",
"1. Scan the border only:",
" - Iterate through all cells but act only when a cell lies on the border and contains 1.",
" - For each such cell, run a flood fill (iterative DFS) that marks every border-reachable 1 as 2.",
"",
"2. Final sweep:",
" - Walk the whole matrix once:",
" - Any remaining 1 is an island → set it to 0.",
" - Any 2 was border-connected → revert it back to 1."
,
"---",
"### Key Functions:",
"- removeIslands(matrix)",
" - Two-pass driver: border flood-fills, then converts stray 1s to 0 and 2s back to 1.",
"- changeOnesConnectedToBorderToTwos(matrix, startRow, startCol)",
" - Iterative DFS using a stack; marks visited cells as 2 to indicate border reachability.",
"- getNeighbors(matrix, row, col)",
" - Returns up to four in-bounds neighbors (up, down, left, right)."
,
"---",
"### Why Mark with 2?",
"- Distinguishes border-connected 1s from island 1s without a separate visited matrix.",
"- Keeps memory overhead low: besides the DFS stack, marking is in-place.",
"- Simplifies the final sweep: 1 → island → 0; 2 → safe → 1."
,
"---",
"### Correctness Intuition:",
"- The only 1s we ever mark are those reachable from a border 1 through a path of 1s.",
"- After the marking phase, any unmarked 1 cannot be border-connected by definition and must be an island.",
"- The final sweep eliminates precisely those unmarked 1s."
,
"---",
"### Complexity:",
"Time Complexity: O(w × h) — Each cell is processed a constant number of times across scanning, flood-fill, and the final sweep.",
"Space Complexity: O(w × h) in the worst case due to the stack during flood fill (when many 1s are connected). Aside from the stack, the algorithm uses O(1) extra space by reusing the matrix (via the temporary value 2)."
,
"---",
"### Implementation Notes:",
"- The algorithm mutates the input matrix in place.",
"- It uses an iterative DFS to avoid recursion-depth limits.",
"- numCols = len(matrix[row]) lets it work with ragged rows; in a strict rectangular grid, all rows have equal length."
],
"date": "2025-10-29"
},
    {
"title": "Cycle Detection in a Directed Graph with DFS Coloring",
"content": [
"This Python implementation determines whether a directed graph contains a cycle using a depth-first search (DFS) with white–gray–black node coloring."
],
"images": ["algorithms_pics/cycle_detection_dfs_coloring.png"],
"description": [
"### What Problem Are We Solving?",
"- Input: a directed graph given as an adjacency list edges, where edges[i] lists the neighbors of node i.",
"- Goal: return True if any directed cycle exists; otherwise False.",
"- Works across disconnected graphs by scanning all nodes.",
"",
"---",
"### How the Algorithm Works (White–Gray–Black):",
"1. Color states:",
" - WHITE (unvisited), GREY (in current DFS path), BLACK (fully explored).",
"2. Scan all nodes:",
" - For each WHITE node, start a DFS via traverseAndColorNodes.",
"3. DFS rules:",
" - Color current node GREY on entry.",
" - For each neighbor:",
" - If neighbor is GREY → we found a back edge → cycle detected.",
" - If neighbor is WHITE → recurse.",
" - If neighbor is BLACK → ignore (already safe).",
" - When all neighbors are processed, color node BLACK and backtrack.",
"",
"---",
"### Key Functions:",
"- cycleInGraph(edges)",
" - Initializes colors and iterates nodes, launching DFS from each WHITE node.",
"- traverseAndColorNodes(node, edges, colors)",
" - Performs the DFS with coloring and returns True at the first sign of a back edge.",
"",
"---",
"### Correctness Intuition:",
"- A node marked GREY is on the active recursion stack. Reaching a GREY neighbor means we can follow directed edges from that neighbor back to the current node, forming a cycle.",
"- Nodes colored BLACK have had all outgoing paths checked; they cannot lead to a new cycle later.",
"- By starting DFS from every WHITE node, we cover disconnected components.",
"",
"---",
"### Edge Cases & Notes:",
"- Self-loop (edge u → u) is detected immediately when visiting the neighbor color GREY (the node itself).",
"- Multiple components are handled by the outer loop in cycleInGraph.",
"",
"---",
"### Complexity:",
"Time Complexity: O(V + E) — every vertex is colored at most once and each edge is inspected once.",
"Space Complexity: O(V) — for the colors array and the recursion stack (worst-case depth O(V))."
],
"date": "2025-10-30"
},
    {
"title": "Minimum Passes to Convert Negatives in a Matrix (Single-Queue BFS)",
"content": [
"This Python solution computes the minimum number of passes required to turn all negative numbers in a matrix positive, where a negative becomes positive if it is adjacent (up, down, left, right) to a positive in the previous pass. It uses a single queue for a clean, level-by-level multi-source BFS."
],
"images": ["algorithms_pics/minimum_passes_matrix.png"],
"description": [
"### Problem Statement:",
"- You’re given a matrix of integers (positive, zero, and negative).",
"- In each **pass**, any negative number that is adjacent to a positive number becomes positive.",
"- Return the **minimum number of passes** needed for all numbers to become non-negative, or **-1** if it’s impossible."
,
"---",
"### How the Algorithm Works:",
"1. **Seed the queue with all positives:**",
"   - Collect coordinates of every positive cell and push them into a single queue. These are simultaneous sources for the BFS.",
"",
"2. **Level-order spread using one queue:**",
"   - Each iteration processes exactly the current queue size (`currentSize`), representing one **pass**.",
"   - For each popped cell, look at its four neighbors. If a neighbor is negative, flip it to positive and enqueue it.",
"   - When the `currentSize` batch is finished, increment the pass counter; the queue now holds precisely the frontier for the next pass.",
"",
"3. **Final check:**",
"   - After BFS completes, scan the matrix once. If any negative remains, return **-1**; otherwise return `passes - 1` (because the last increment happens after the final effective spread)."
,
"---",
"### Key Functions:",
"- **`minimumPassesOfMatrix(matrix)`**: Orchestrates the process and returns the final answer (`passes - 1` or `-1`).",
"- **`convertNegatives(matrix)`**: Performs the single-queue, level-by-level BFS to flip reachable negatives.",
"- **`getAllPositivePositions(matrix)`**: Finds all starting sources for the BFS.",
"- **`getAdjacentPositions(row, col, matrix)`**: Returns valid neighbors (4-directional).",
"- **`containsNegative(matrix)`**: Linear check for any remaining negatives."
,
"---",
"### Why a Single Queue?",
"- Using a single queue with a **fixed `currentSize` per loop** captures pass boundaries without juggling two separate queues.",
"- It preserves the exact wavefront semantics of the spread: all flips caused by the same frontier count as one pass."
,
"---",
"### Complexity:",
"**Time Complexity:** O(w × h) — Each cell is enqueued and processed at most once; adjacency checks are constant per cell.",
"**Space Complexity:** O(w × h) in the worst case for the queue when many cells are on the frontier simultaneously."
,
"---",
"### Implementation Notes:",
"- Zeros don’t flip neighbors but can be traversed as positions that don’t contribute to spreading positivity.",
"- Returning `passes - 1` accounts for the final increment after processing the last frontier."
],
"date": "2025-10-31"
}






]
