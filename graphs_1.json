[
{
    "title": "Depth-First Search (DFS) Traversal in a Tree",
    "content": [
        "This Python implementation demonstrates the Depth-First Search (DFS) traversal of a tree using recursion."
    ],
    "images": ["algorithms_pics/depth_first_search.png"],
    "description": [
        "### How the Depth-First Search Works:",
        "1. **Node Class:**",
        "   - Each node has a `name` and a list of `children`.",
        "   - The `addChild()` method allows adding child nodes dynamically.",
        "",
        "2. **DFS Traversal:**",
        "   - The function `depthFirstSearch()` starts at the root node.",
        "   - The current node is added to the result list.",
        "   - The function recursively calls DFS on each child node before moving to the next sibling.",
        "",
        "3. **Traversal Order:**",
        "   - DFS explores as deep as possible along each branch before backtracking.",
        "   - The traversal follows a top-to-bottom, left-to-right pattern for each subtree.",
        "",
        "### Complexity Analysis:",
        "**Time Complexity:**",
        "- Each node is visited exactly once during traversal.",
        "- Since there are `n` nodes in the tree, the total time complexity is **O(n)**.",
        "",
        "**Space Complexity:**",
        "- The space complexity depends on the recursion depth and the result list.",
        "- **Result List:** Stores all nodes, requiring **O(n)** space.",
        "- **Recursive Call Stack:**",
        "  - **Balanced Tree:** The recursion depth is **O(log n)**, leading to **O(log n)** space.",
        "  - **Unbalanced Tree (Linked List Structure):** The recursion depth is **O(n)**, leading to **O(n)** space.",
        "- Overall, the worst-case space complexity is **O(n)** due to the result list and recursion depth in an unbalanced tree."
    ],
    "date": "2025-01-13"
},
{
  "title": "Detecting a Single Cycle in an Array",
  "content": [
    "This Python function determines whether traversing through an array according to the values it contains forms a single cycle that visits every element exactly once before returning to the starting index."
  ],
  "images": ["algorithms_pics/single_cycle_check.png"],
  "description": [
    "### Problem Statement:",
    "- Given an array of integers where each element represents a number of steps to jump forward or backward (circularly), determine if the traversal starting at index `0` visits every index exactly once and returns to `0` at the end.",
    "- Positive numbers mean jumping forward, negative numbers mean jumping backward.",
    "",
    "---",
    "### How the Algorithm Works:",
    "1. **Initialization:**",
    "   - Start at index `0` with a counter `numElementsVisited` set to 0.",
    "",
    "2. **Main Loop:**",
    "   - Continue jumping through the array using the `getNextIdx()` helper function.",
    "   - If you revisit index `0` **before** visiting all elements, return `False` since that means more than one cycle exists.",
    "",
    "3. **Cycle Completion Check:**",
    "   - After visiting all elements, return whether you're back at index `0`. If so, a single valid cycle exists.",
    "",
    "### `getNextIdx(currentIdx, array)` Details:",
    "- Calculates the next index in a circular manner using modulo arithmetic.",
    "- It ensures wrapping around in both directions, including negative jumps.",
    "- If the result is negative, it corrects the index by adding the array's length to keep it in valid range.",
    "",
    "### Key Observations:",
    "- You must never return to index `0` before all elements are visited — this would split the cycle.",
    "- The use of `% len(array)` ensures wrapping around.",
    "- This algorithm ensures every node is part of exactly one cycle of full traversal.",
    "",
    "---",
    "### Time and Space Complexity:",
    "**Time Complexity:** O(n) — Each element is visited exactly once.",
    "**Space Complexity:** O(1) — Only a few variables are used regardless of input size.",
    "",
    "This solution is efficient and elegant, offering a constant-space approach to solving cycle detection problems in circular arrays."
  ],
  "date": "2025-07-09"
}


]
